Option Explicit		'Enabled to enforce correct usage of variables (and to catch errors in typing variable names)

dim secST '   STANDARDS
	'*************************************************************************************************************************
	'*************************************************************************************************************************
	' TESCO HFM - Rules File
	' Created By: Bulent Yildiz
	' 
	' Naming Conventions:
	' Constants are capitalised
	' All variables (including function/sub-routine parameters) are mixed case preceded by type identifier as below
	' e.g. bIsBaseEntity, nPeriodNumber, sAccount, dData
	' Boolean (logical) Variables begin with b
	' Object Variables begin with o
	' Array Variables begin with a
	' String Variables begin with s
	' Numeric Variables begin with n or i
	' Data Variables begin with d
	' Member ID Variables begin with id
	' 
	'****************************************************************sAccountParent*********************************************************
	
	
dim secUL '   UPDATE LOG and RULES_VERSION
	' ===============================================================================================================
	'	Version		Who				Updates
	'	--------	-------------	----------------------------------------------------------------------------------------------------------------------------------------------------
	'	20180221	Bulent Yildiz	Initial draft version - functions and subs, initial draft versions
	'	20180226	Bulent Yildiz	Initial draft version - cleaning, parameter checks, custom 5 updates
	'	20180227	Bulent Yildiz	Initial draft version - updated debugging parameters, added WriteToCellTextLog() sub-routine
	'	20180301	Bulent Yildiz	Initial draft version - some more cleaning, and change of if/elseif structure in CALCULATE sub-routine to make it Value based.
	'	20180323	Bulent Yildiz	Draft version of Opening Balance, Movement Calcs and Translations
	'	20180327	Bulent Yildiz	Conversion to new Period names (P0x -> Px) and new Custom Nones (Cx_None -> [None])
	'	20180404	Srinivas H.		Added Entity dimension to Parametric No Input Rules
	'	20180423	Srinivas H.		Updated Debug Rules to write to file in HFM server
	'	20180424	Bulent Yildiz	Added Scenario to Parametric No Input rules and GetUDA() func. to be used later.
	'	20180426	Bulent Yildiz	Fixed the debug rules - WriteToFile() and SetDebugParameters().
	'	20180515	Bulent Yildiz	Added IsApplicableToPOV(), GetArrayValue() and SetArrayValue().
	'	20180521	Bulent Yildiz	Added ConsDefault() and Eliminate_ICP().
	'	20180522	Bulent Yildiz	Added CalcValidations(), CalcValidationAccount() and CalcValidationResults().
	'	20180523	Bulent Yildiz	Added ConsStandardTreatment().
	'	20180530	Bulent Yildiz	Updated GetParameterValue() for cases where the parameter value includes member(s) with space(s) in their name(s) (e.g. [ICP None]). 
	'	20180530	Bulent Yildiz	Enabled Opening Balance rules for [Proportion] and [Elimination]
	'	20180531	Bulent Yildiz	Updated GetParameterValue() and IsParameter() for 'SEE RULES' as the value (e.g. NOINPUT:SEE RULES)
	'	20180605	Bulent Yildiz	Moved Impact rule conditions from CALCULATE main sub-routine into ImpactCalcStatus()
	'	20180612	Bulent Yildiz	Added Historic Translation Rules - TransHistoric(), and updated CalcFXRates() for historic rates.
	'	20180613	Srinivas H.		Added the validation for FIXRATE_SC_CI that checks if there is a spot rate input for every periodic movement.
	'	20180618	Bulent Yildiz	Enabled opening balance rules at <Parent Currency> for CTR account
	'	20180621	Bulent Yildiz	Updated TransHistoric() to calculate the FX from historic accounts directly on the CTR.
	'	20180702	Bulent Yildiz	Added blended rate calculation and multiple movements in UDA parameter.
	'	20180716	Bulent Yildiz	Added TransHistoricForAlternateRates() and TransHistoricCalc() for historic translations. Added historic opening rate (from blended closing rate) calculations into CalcFXRates().
	'	20180717	Bulent Yildiz	Added ConsJVorAssociate().
	'	20180721	Bulent Yildiz	Added GetMemberList() and parametric no input rules that block members of a member list.
	'	20180726	Bulent Yildiz	Added ConsDiscontinuedOps(). Added conditions for first year to avoid pulling data from prior year.
	'	20180802	Bulent Yildiz	Fixed the issue with the historic translations for non-ICP historic accounts.
	'	20180806	Bulent Yildiz	Updated ConsJVorAssociate() with the additional B/S account cases and SF accounts for conditional consolidation (based on total investment being positive or negative).
	'	20180813	Bulent Yildiz	Updated TransHistoric() and TransHistoricForAlternateRates() to allow historic translations on SF accounts which do not feed into CTR (no 'FXCTR' parameter).
	'	20180821	Bulent Yildiz	Added conditional consolidation rules into ConsJVorAssociate() for loss making JVs. Fixed the issue with CBLOAD (C1_9999) translation in TransHistoricCalc() for the accounts this member is invalid.
	'	20180824	Bulent Yildiz	Updated TransHistoric() to clear FXAVG calculated by the standard translation for the accounts which keep FX on themselves (rather than on CTR) and to clear FXOPE and FXAVG for CTR itself.
	'	20180828.1	Bulent Yildiz	Replaced HS.IsValidDest in TransHistoricCalc() with an alternative method to check if CBLOAD is valid for the historic account it is being translated for.
	'	20180828.2	Bulent Yildiz	Updated TransHistoricForAlternateRates() to clear FXAVG calculated by the standard translation for the accounts which keep FX on themselves and to clear FXOPE and FXAVG for CTR itself.
	'	20180829	Bulent Yildiz	Updated JV consolidation rules to separate the consolidation of alternate rate translation (C5_TRANS) data from the consolidation of all other data.
	'	20180830	Bulent Yildiz	Added Recursive() functionn to highlight recursive calls to functions. Updated calculation of [C1_7213 Other reserves] in ConsJVorAssociateCalc() to include Translation Reserve movements.
	'	20180903	Bulent Yildiz	Added Holding Consolidation rules (ConsHolding()) and Equity Elimination / EER rules into ConsDefault() and ConsHolding().
	'	20180910	Bulent Yildiz	Added GetTargetElimC5() functionn that returns which C5 member the elimination adjs should be posted to. Also updated Eliminate_ICP() with this.
	'	20180912	Bulent Yildiz	Updated CalcMovements() to restrict the calculation of C1_9998 to the C5_GLLOAD level only, so that the adjs don't get reversed.
	'	20180913	Bulent Yildiz	Added the calculation of CTR for CBLOAD into TransHistoricCalc(). Updated CopyDataForReTranslation to include the journal adjs (in <ECA>) in the data copied to the retranslation members.
	'	20180918	Bulent Yildiz	Added the Non-Controlling Interest (NCI) rules into ConsDefault().
	'	20180919	Bulent Yildiz	Fixed the issue with the signage of calculated P&L reserves in CalcRetainedEarnings and the accounts it contributes to in ConsJVorAssociateCalc()
	'	20180920.1	Bulent Yildiz	Added rules into TransHistoricForAlternateRates() to recalculate CTR opening balance correctly with restated rates.
	'	20180920.2	Bulent Yildiz	Added impact status and opening balance rules and for Forecast 7+5 Closing -> Budget Working Opening.
	'	20180925	Bulent Yildiz	Fixed impact rules for Forecast and Budget scenarios, so that they don't impact themselves for P1 next year.
	'	20180926.1	Bulent Yildiz	Added 'CUSTOMELIM' parameter to prevent double elimination of EER accounts (Share Cap. etc.) by standard ICP eliminations run in Eliminate_ICP().
	'	20180926.2	Bulent Yildiz	Restricted the elimination of EER accounts (Share Cap. etc.) to base entity level in ConsDefault() to prevent double elimination in upper level parents.
	'	20180927	Bulent Yildiz	Fixed the applicability check in CalcParametric() so that it makes the decision based on the 'AppliesTo' parameter in UDA.
	'	20180928	Bulent Yildiz	Added Acquisition Translation Rules into and updated various sections in TransHistoric() to make these rules work.
	'	20181005	Bulent Yildiz	Updated CONSOLIDATE() to run JV/Associate consolidation rules for JVs/Associates even if the method is not assigned.
	'	20181009	Bulent Yildiz	Added [C1_5026 Fair Value Adjustments] translation rules into TransHistoric() and fixed the issue with [C1_5016 Acquisitions] contributing to the FXAVG in CTR.
	'	20181010	Bulent Yildiz	Added rules into CalcFXRates() to bring forward the acquisition rates from prior year P12 to current year P1.
	'	20181011	Bulent Yildiz	Updated the Acqusition Translation Rules in TransHistoric() to exclude the acquisition/disposal movements that need translating at a spot rate (e.g. Investment in Subs for the Acquiring entity).
	'	20181015	Bulent Yildiz	Commented out the check for real data before calculating Historic Opening Rates in CalcFXRates() because these rates should never be manually input (this needs to be validated by Business).
	'	20181016.1	Bulent Yildiz	Disabled the no input rule blocking <PCA> - (for segmental adjustments for CRP). We may need to find an alternative solution and re-enable it.
	'	20181016.2	Bulent Yildiz	Fixed the issue with the the calculation of CTR FXAVG in TransHistoric(), now looping through all historic accounts instead of only the ones with a historic movement balance.
	'	20181016.3	Bulent Yildiz	Added CalcOther() to calculate [C5_EXCEPT Exceptional Items]. Changed the folder name and path the HFM debug files are kept in.
	'	20181022.1	Bulent Yildiz	Corrected the formulae in calculation of the adjusted percentage in ConsJVorAssociate() for negative and zero opening/closing cases in line with the agreed simplified model (CR by Sara).
	'	20181022.2	Bulent Yildiz	Improved the conditions that decide upon the JV's profitability and calculations of the adjusted percentage in ConsJVorAssociate() with new formulae and variable names.
	'	20181022.3	Bulent Yildiz	Changed the rule regarding other reserves (Share of Other Compr. Income) in JV Equity so that they consolidate @ the adjusted % (less or in some cases greater than the ownership %)
	'	20181023	Bulent Yildiz	Fixed the division by zero error in calculation of the adjusted percentage in ConsJVorAssociate().
	'	20181029	Bulent Yildiz	Removed the call to WriteToCellTextLog() within WriteToDebugLog() so that it only writes to the log file in the server. Added WriteToAllDebugLogs() which writes to both log file and celltext log.
	'	20181030	Bulent Yildiz	Removed references to [C1_5026 Fair Value Adjustments] which has been removed from the metadata as requested by Sara Recber.
	'	20181205.1	Bulent Yildiz	Added Parametric Input Rules (INPUT parameter).
	'	20181205.2	Bulent Yildiz	Added CalcDataMigrationRelated() for Data Migration, to help with the reconciliations. It calculates MVCALC from CBLOAD at [C5_GCS  GCS Parent Entity Data (<ECT>)] x Parent Entity levels.
	'	20190114	Bulent Yildiz	Fixed the double elimination happening in standard ICP elimination rules in Eliminate_ICP() at the 2nd common parent and above.
	'	20190118	Bulent Yildiz	Temporary: Added temporary code into CalcValidationLockAccounts() to populate the lock account for Data Integration tests.
	'	20190124	Bulent Yildiz	Updated CONSOLIDATE() with the holding company check based on a UDA parameter to trigger the HOLDING method even if the method isn't assigned to the holding entity.
	'	20190129.1	Bulent Yildiz	Updated ConsStandardTreatment() for the new ISCONS parameter to skip the consolidation of certain C5 members.
	'	20190129.2	Bulent Yildiz	Added AbortRules() and replaced the existing lines of code (that deliberately cause rules to abort) with calls to AbortRules().
	'	20190131	Bulent Yildiz	Temporary: Added code into CalcValidationLockAccounts to prevent it from populating the lock account in the data migration application (HFMDMDEV) because this will make the FDMEE load fail.
	'	20190215	Bulent Yildiz	Updated ConsDefault() to eliminate [BB1641 Investment in Subsidiaries] and [BB1647 Impairment of Investment in Subsidiaries] for subsidiriaries too (these were eliminated for Holding Company only.)
	'	20190227	Bulent Yildiz	Re-enabled the check for real data before calculating Historic Opening Rates in CalcFXRates() to allow manual input for Data Migration (for after Go-Live, this needs to be validated by Business).
	'	20190302	Bulent Yildiz	Disabled opening balance calculations at [Proportion] and [Elimination] for 2018 and enabled opening balance consolidations in ConsStandardTreatment() to allow opening balances translated at correct historic opening rates consolidate up to Group.
	'	20190314	Bulent Yildiz	Reverted back the OB changes on 20190302 as agreed with the Data Migration Team and Group Finance (Taj Plaha, Arun Wilson). They will try to get 2017 P12 closing balances right at all levels.
	'	20190318.1	Bulent Yildiz	Temporary: Added temporary checks into parametric rules in Inputs_All() and NoInputs_All() for Year 2036 to prevent errors in the old Dev apps, HFMDEVNEW and HFMDMDEV which don't have this year.
	'	20190318.2	Bulent Yildiz	Added AbortRules for ELSE cases in Parametric No Input and Input rules. These ELSE cases should be defined and code should be added to cover these.
	'	20190319	Bulent Yildiz	Updated ConsDefault() to contribute the minority share of the CTR into [BB9805 CTR on Minority Interest] - requested by Arun.
	'	20190321	Bulent Yildiz	Updated TransHistoric() with the calculation of [BB9805 CTR on Minority Interest] in line with the change of use of FXCTR parameter. Same updates are needed in TransHistoricForAlternateRates()
	'	20190323	Bulent Yildiz	Reverted back the change made in CalcFXRates() on 20190227 as DM team decided to correct 2017 closing balances instead. Added HS_ImpactStatus().
	'	20190412	Bulent Yildiz	Added bBeforeCutover and bAfterCutover checks and turned off the loss making JV/Assoc rules for Data Migration periods (before cutover). Fixed the call to Recursive() in ConsJVorAssociate().
	'	20190415	Bulent Yildiz	Updated CalcDataMigrationRelated() and CalcMovements() to calculate MVCALC(C1_9998) for adjustments in C5 for Data Migration periods (before Cutover).
	'	20190416	Bulent Yildiz	Temporary: Updated ConsJVorAssociate() to skip consolidation of [PS9900 External Dividends] accounts for Data Migration (Arun Confirmed). Different treatment may be required after Cutover.
	'	20190426	Bulent Yildiz	---  LAST VERSION FROM ORACLE CONSULTING  ---
	'	//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
	'	\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//
	'	20190429	Bulent Yildiz	---  FIRST TESCO VERSION  ---
	'	20190429	Bulent Yildiz	Updated CalcRetainedEarnings() for Dividend and Dividend MI movements, and renamed it as CalcRetainedEarningsAndNCI(). Changed the consolidation of P&L Reserves movements in ConsJVorAssociate().
	'	20190430	Bulent Yildiz	Updated ConsJVorAssociate() to exclude [BB9511 Profit and Loss Reserve].[C1_9990 Data Migration] from JV consolidations (requested by Arun).
	'	20190507	Bulent Yildiz	Updated ConsJVorAssociate() to exclude FX on CTR from [C2_BB9511 Source - Profit and Loss Reserve].[C1_9990 Data Migration] from JV consolidations (requested by Arun).
	'	20190513	Bulent Yildiz	Fixed the issue with mistyped account code in the CALC parameter formula getting replaced by the target account in ConvertToExpression(). The rule is now aborting if an incorrect account code is used.
	'	20190514	Bulent Yildiz	Disabled metadata (UD1) driven consolidation method triggering for JVs/Assoc in CONSOLIDATE() so that method and ownership % have to be assigned using the ownership management screen (Arun confirmed)
	'	20190516.1	Santosh Pai		Updated EER elimination rules in ConsDefault() and ConsHolding() to write eliminations always to [C1_9995 Equity Elimination Movement] (requested by Arun).
	'	20190516.2	Bulent Yildiz	Switched debugging OFF (bDEBUG) so nothing is written on the log files but kept cell text logging ON (bCELLTEXTLOG) for WriteToCellTextLog() to still work if needed.
	'								Added MAXCELLTEXTLOGNUMBEROFLINES and updated WriteToCellTextLog() to automatically clear the logs when this limit is reached.
	'	20190517.1	Bulent Yildiz	Added TransOtherCalc() to clear translated OBLOAD:[C1_9997 Opening Balance Load] and updated ConsStandardTreatment() to skip consolidation of OBLOAD.
	'	20190517.2	Bulent Yildiz	Updated IsApplicableToPOV() for NotAppliesTo (Exceptions) parameter so that it also checks the POV for exceptional cases.
	'	20190521.2	Santosh Pai 	Enable CalcCashFlow() for Value [PROPORTION] to enable the calcualtion for CB1010 and CB1030 run though JV and Assoc.
	'   20190522.1	Bulent Yildiz	Disabled TransAlternateRates() and TransHistoricForAlternateRates() rules for now.
	'	20190524.2	Santosh Pai 	Updated CalcCashFlow() for CB9910 to calc at [proportion] Level for FX movement on BS2850 - Cash and Cash Equivalents
	'   20190529.1	Bulent Yildiz	Updated calculation of exceptionals in C5 in CalcOther(), now calculating C5_EXCDED rather than C5_EXCEPT.
	'   20190529.2	Bulent Yildiz	Updated CalcDataMigrationRelated() to enable MVCALC calculation for C5_GRPADJ, C5_SYNADJ, C5_EXCEPT, C5_P13ADJ, C5_P14ADJ
	'   20190609.1	Bulent Yildiz	Added Intercompany Eliminations into ConsDiscontinuedOps() - before they were being collapsed together with other accounts.
	'	20190609.2	Bulent Yildiz	Fixed IsApplicableToPOV() for the issue with Accounts having only 'NotAppliesTo' parameter getting skipped for all entities.
	'	20190615	Bulent Yildiz	Updated CopyDataForReTranslation() in line with the new design (hierarchies under C5_TRANS, new parameters: SOURCE, ACCS and NotAppliesTo)
	'	20190617.1	Bulent Yildiz	Updated ImpactCalcStatus() for Actual Management Scenario. Replaced Budget_W1 with Budget_Pre.
	'	20190617.2	Bulent Yildiz	Added Process Unit POV information into the error message in AbortRules() also force-enabled debugging for these errors even when debugging is turned off.
	'	20190617.3	Bulent Yildiz	Added discontinued operations consolidation to ConsDefault(), applied to all accounts except for the ones there is a special consolidation rule in ConsDefault(). Removed ConsDiscontinuedOps().
	'	20190618.1	Bulent Yildiz	Updated CalcRetainedEarningsAndNCI() to add C2 Source Account detail to the calculation of [BB9801 Minority Interest]. Added bABORTRULES switch to turn on/off AbortRules() functionality.
	'	20190618.2	Bulent Yildiz	Temporary: Added temporary code into CalcCashFlow() and CalcParametric() to disable these rules for HFMDMDEV and HFMDMPPE because parametric CF calculations are currently taking too long.  
	'	20190619.1	Bulent Yildiz	Commented out codes clearing standard FX on CTR (for data coming from GL) in TransHistoric() and TransHistoricForAlternateRates() because CTR is now a calculated account (no standard fx).
	'	20190619.2	Bulent Yildiz	Disabled ConsJVorAssociateCalc() as the decision is to not to automate the treatment of loss making JVs (approved by business). Replaced VTSTBS with VL0001.
	'	20190619.3	Bulent Yildiz	Updated CopyDataForReTranslation() with the change in the usage of ACCS parameter.
	'	20190619.4	Bulent Yildiz	Updated TransAlternateRates() in line with the new design (hierarchies under C5_TRANS, new parameters: ACCS, AppliesTo and NotAppliesTo) and added retranslation of Cash Flow and Flash Accounts.
	'	20190619.5	Bulent Yildiz	Enabled calculation of opening and alternate rates (CalcFXRates()) at the base entity level in addition to [None] entity to cover for entities with a different rate (e.g. rate of 2 months prior)
	'	20190619.6	Bulent Yildiz	Updated CalcFXRates() to copy rates from Actual scenario into other scenarios for standard and alternate rate translations.
	'	20190620.1	Bulent Yildiz	Fixed the defect with parametric rules in Inputs_All() and NoInputs_All() that is triggered if the member itself is included in the parameter value.
	'	20190620.2	Bulent Yildiz	Added rules into ImpactCalcStatus() to impact [Actual_M - Actual for Management Reporting], Flash and [Budget Budget Post Actualisation] scenarios when calculating Actual scenario.
	'	20190621.1	Bulent Yildiz	Added opening rate calculations into CalcFXRates() for [Actual_M - Actual for Management Reporting], [Budget_Pre Budget Pre Actualisation] and [Budget Budget Post Actualisation] scenarios.
	'	20190621.2	Bulent Yildiz	Updated CalcFXRates() to pull current year Actual rates into Actual_M, Flash and Forecast scenarios. 
	'	20190621.3	Bulent Yildiz	Updated CalcFXRates() to pull the Actual rates from correct year/period into the alternate rate accounts only for the applicable scenarios.
	'	20190621.4	Bulent Yildiz	Updated CalcFXRates() to enable clearing the fixed rates and acquisition rates recurring from prior periods for Forecast periods of Forecast scenarios.
	'	20190621.5	Bulent Yildiz	Temporary: Disabled CopyDataForReTranslation() for the DM apps and added a lighter version of Impact Rules (ImpactCalcStatus_Temp_ForDM) to run for the DM apps to reduce consolidation time.
	'	20190621.6	Bulent Yildiz	Updated ImpactCalcStatus() to impact <EC> next year when a translation is run in Actual P12 to ensure that historic opening rates next year are recalculated as a result of retranslation.
	'	20190621.7	Bulent Yildiz	Updated CalcOpeningBalances() for [Budget Budget Post Actualisation] scenario (Closing Balances from Actual are brought forward to Budget openings).
	'	20190621.8	Bulent Yildiz	Added calculation of PY (Prior Year) alternate rates into CalcFXRates().
	'	20190621.9	Bulent Yildiz	Added PRIORYEAR constant to be used in Constant Rate Alternate Translation rules. Added a check to ensure that PRIORYEAR always equals CURRENTYEAR - 1
	'	20190622.1	Bulent Yildiz	Added calculations for Budget, Profit Plan and Constant Rates into CalcFXRates(). Enabled TransAlternateRates() and TransHistoricForAlternateRates() for all apps other than the DM apps.
	'	20190624.1	Bulent Yildiz	Added a parameter to TransHistoric() to run it only for historic opening balances for [Budget Budget Post Actualisation] scenario so that the fixed rate movements are translated at YTD average rate.
	'	20190624.2	Bulent Yildiz	Removed TransHistoricForAlternateRates() and commented out the alternate rate section in TransHistoricCalc() as the requirement has now changed to translation of historic accounts in the same way as other B/S accounts (confirmed by Shuj and Business at CRP 5).
	'	20190626.1	Bulent Yildiz	Fixed a defect (IsParameterValue() -> IsParameter()) in TransAlternateRates()
	'	20190626.2	Bulent Yildiz	Added code into CalcFXRates() to pull the Actual FX rates from the correct year & period into Budget, Budget_Pre and Forecast scenarios.
	'	20190626.3	Bulent Yildiz	Updated the calculation of [PP_OPE_RATE Profit Plan Opening Rate (PY P12 Forecast Rate)] so that it pulls the closing rate from the Forecast 7+5 scenario rather than Actual (so it will be Actual PY P7 closing rate being pulled).
	'	20190626.4	Bulent Yildiz	Enabled Historic Opening Rate calculations in CalcFXRates() also for [Budget Budget Post Actualisation] scenario, so that historic accounts' opening balances match Actual scenario.
	'	20190626.5	Bulent Yildiz	Fixed the issue in SetDebugParameters() with the application name variable (sApplication) not getting populated when the debug and timer logs are both disabled.
	'	20190628.1	Bulent Yildiz	Updated WriteToAllDebugLogs() to make WriteToCellTextLog() calls work even if bDEBUG is switched off (but bCELLTEXTLOG must be switched on). Updated WriteToCellTextLog to include current date & time in the log entries.
	'	20190701.1	Bulent Yildiz	Added validation rules for [VL9001 FD Sign Off PIN must be correctly entered] into CalcValidationAccount().
	'	20190708.1	Santosh Pai		Validation for FIXRate VL8101, Updated BS Imbalance VL1001 in VALAccount  calculations
	'	20190711.1	Bulent Yildiz	Enabled Parametric calculations for GROUPHFM (for Arun to test in SIT application)
	'	20190715.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190715.2	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190716.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190716.2	Santosh Pai 	Updated KP account calculations in Dynamic() sub-routine 
	'	20190718.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190722.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190722.2	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190723.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190726.1	Santosh Pai		HS.Dynamic Formulae changes as per the new CR files by Arun - e.g. LFL Growth % = ( Sales of last year - Sales of Curr Year) - 1
	'	20190729.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190801.1	Bulent Yildiz	DRM Update: Replaced references to C1_FXOP, C1_FXAV, C1_FXAQ, C1_FXHM, C1_FXDM with C1_5501, C1_5502, C1_5503, C1_5504, C1_5509.
	'	20190805.1	Bulent Yildiz	Fixed the share captial/share premium elimination issue in ConsDefault() (defect: elimination was at ownership % whereas plug account was populated at 100%).
	'	20190806.1	Bulent Yildiz	Updated ConsDefault() and ConsJVorAssociate() for CTR manual input account (BB9362) so that it is consolidated in the same way as calculated CTR (BB9361).
	'	20190806.2	Bulent Yildiz	Updated CalcOpeningBalances(), TransHistoricCalc() and TransAlternateRatesCalc() for [BB9805 CTR on Minority Interest] so that the same rules apply to both CTR and CTR on MI.
	'	20190807.2	Bulent Yildiz	Fixed the issue in ConvertToExpression() for formulas which use accounts that have [None] instead of blank assigned as its custom top member.
	'	20190809.1	Bulent Yildiz	Removed/replaced references to the removed scenario [Actual_M - Actual for Management Reporting] with Actual in TRANSLATE(), CalcFXRates(), ImpactCalcStatus(), CopyDataForReTranslation()
	'	20190809.2	Bulent Yildiz	Removed/commented out references to Flash scenario and accounts in TransAlternateRates(), CalcFXRates(), ImpactCalcStatus(), CopyDataForReTranslation() because Flash data will be input in GBP (not translated)
	'	20190812.1	Santosh Pai 	Flash Input at <EC> to rertive Opening Balance from Actuals
	'	20190812.2	Bulent Yildiz	Updated CalcValidations() to make validations run at <ECT> level rather than <EC> level.
	'	20190813.1	Bulent Yildiz	Defined sPOV variable in Inputs_All(), which was preventing calculation rules from running (however no error given to the user)
	'	20190813.2	Bulent Yildiz	Enabled IsParameter check in CalcFlash() and disabled looping through FLASHINPUT entities.
	'	20190813.3	Bulent Yildiz	Commented out calculation of SF9150 for loss making JVs in SetPOVVariables() (the automation of treatment of loss making JVs was scoped out)
	'	20190813.3	Bulent Yildiz	Added CalcRecurringBalances() to carry forward the default validation tolerance so that FSS will not have to input it every month.
	'	20190815.2	Santosh Pai 	Added VL8401  and VL1101- ***UPDATE NEEDED for C1_9998 for selective accounts only**
	'	20190819.1	Bulent Yildiz	Fixed rules for [VL1101 - Movements Calculated Nets to Nil] validation in CalcValidationAccount() and made it run only for a subset of B/S accounts which need correct movement split.
	'	20190819.2	Bulent Yildiz	Replaced HS.Exp with HS.ABSExp for accumulate method used in CalcValidationResults() to prevent equal and opposite balances from making the actual result zero (this confuses users)
	'	20190821.1	Bulent Yildiz	Updated CalcValidations(), CalcValidationAccount(), CalcValidationResults(), CalcValidationLockAccounts() and TransPrimary() for C4_VALREF1 and C4_VALREF2 (new children under C4_VALREF)
	'	20190821.2	Santosh Pai		Updated CalcValidationAccount() for fixed Rate validations VL8101 and VL8401 to make them call CalcValidationResults() instead of writing the results directly.
	'	20190822.1	Bulent Yildiz	Added sCustomAnalysis parameter into CalcValidationResults() to enable C2 split for VL8101. Updated calls to it from CalcValidationAccount()
	'	20190822.2	Santosh Pai 	Correction to VL8401 calc to run on C4#VALTYPE, removed hard coded lines from rules 
	'	20190823.1	Bulent Yildiz	Added a check into CalcValidationAccount() for UD1 of parametric validations to make rule abort if UD1 is blank. Set tolerance for VL8401 to zero and made it check spot rate only if there is data.
	'	20190823.2	Bulent Yildiz	Enabled AbortRules() for On Demand Rules. Moved OnDemand_TEST_CODE() subs from On Demand Rules section into Debug Rules section.
	'	20190823.3	Bulent Yildiz	Added SendEmail() functionn to be triggered from different sub-routines and updated OnDemand_Request_FD_Review() with this change.
	'	20190826.1	Bulent Yildiz	ENTER DETAILS OF UPDATES HERE !!!
	'	20190827.1	Bulent Yildiz	Added code into AbortRules() to notify FSS with an email about the rules being forced to abort.
	'	20190829.1	Bulent Yildiz	Re-enabled CopyDataForReTranslation(), alternate rate translation in TRANSLATE(), CalcCashFlow(), CalcParametric() for GROUPHFM in SIT and PPE.
	'	20190829.2	Bulent Yildiz	Updated GetTargetElimC5() and calls to it for ELIM parameter change (now accounts are also using this parameter).
	'	20190829.3	Bulent Yildiz	Fixed the issue with consolidation of minority share of the CTR manual input (BB9362) to CTR on NCI (BB9805) in ConsDefault().
	'	20190830.1	Bulent Yildiz	Updated Request_FD_Review() and SetPOVVariables() for the change in value member (from <ECT> to [None]) used in forms (in preparation for the planned updates on VL9002 & VL9007)
	'	20190830.2	Bulent Yildiz	Added HS_CalcStatus() for debugging.
	'	20190831.1	Bulent Yildiz	Added code into Request_FD_Review() to copy data into C5_XXXX_SIGN members (in preparation for the planned updates on VL9002 & VL9007)
	'	20190831.2	Bulent Yildiz	Added code into CalcValidationAccount() for VL9002 & VL9007 to compare current balances with the balances at the time of FD sign off and make the validation fail for any difference.
	'	20190905.1	Bulent Yildiz	Fixed issues with FD Sign Off validations (VL9001, VL9006, VL9002 and VL9007) in CalcValidationAccount(). Added a loop for members in C5_DifferencesSinceSignOff because dataunit doesn't pull data for a list of parent members.
	'	20190909.1	Santosh Pai		Amended all Synamic Calc KP account calculations in Dynamic() due to change in C1_D150 new hierarchy, NLU_C2_F1000
	'	20190909.2	Bulent Yildiz	Added code into CalcOpeningBalances() to calculate the non-financial opening balance [C1_6059 - Store - Opening Balance], used currently by one KP analysis group of accounts only.
	'	20190910.1	Bulent Yildiz	Fixed defect (EPMFT-52) in validation rule VL8101, it is now checking balances at <ECT> level rather than <EC>.
	'	20190911.1	Bulent Yildiz	Updated SendEmail() for email attachments so that files on server can be attached to the emails sent. Removed date & time from debug log and timer log file names in SetDebugParameters().
	'	20190911.2	Bulent Yildiz	Updated SetDebugParameters() for debug/timer log paths (folder) and currently disabled logging in SIT, PPE and PROD environments a folder needs to be setup in each of these environments.
	'	20190912.1	Bulent Yildiz	Added code into CALCULATE() to send an email when the consolidation is completed for Group. This is to help with UAT preperations but can be used later on for a different purpose.
	'	20190912.2	Bulent Yildiz	Updated impact rules in ImpactCalcStatus() for Actual impacting Forecast to improve consolidation performance. Actual now impacts only one forecast scenario.
	'   20200414.4  Santosh Pai     EPFT - 1122 Defect Code Calc PL()
	
	Const RULES_VERSION = 20190912.2 	' <<<--- REMEMBER TO UPDATE THIS VALUE !!!
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secFC '   FILE CONTENTS
		  ' =============================================================================================================
		  ' |																											|
		  ' |		!!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!!		|
		  ' |		!!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!!		|
		  ' |		!!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!!		|
		  ' |		!!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!! UPDATE NEEDED !!!		|
		  ' |																											|
		  ' =============================================================================================================
	
	
dim secA1 '   Section A1 - GLOBAL CONSTANTS
		  ' ==========================================================================================================
	
	'DEBUGGING----------------------------------------------------------------------------------------------------------
	'Const bTIMER = True						'Set "True" to enable performance timing using the WriteToTimerLog() calls
	Const bTIMER = False						'Set "False" to disable performance timing using the WriteToTimerLog() calls
	
	'Const bDEBUG = True 						'Set "True" to enable debug logging using the WriteToDebugLog() calls
	Const bDEBUG = False						'Set "False" to disable debug logging using the WriteToDebugLog() calls
	
	Const bCELLTEXTLOG = True 					'Set "True" to enable cell text debug logging using the WriteToCellTextLog() calls
	'Const bCELLTEXTLOG = False					'Set "False" to disable cell text debug logging using the WriteToCellTextLog() calls
	
	Const bABORTRULES = True 					'Set "True" to enable rule aborting using the AbortRules() calls when a critical error is found
	'Const bABORTRULES = False					'Set "False" to disable rule aborting using the AbortRules() calls when a critical error is found
	
	Const bNOTIFYADMINABOUTRULEABORT = True 	'Set "True" to enable rule aborting using the AbortRules() calls when a critical error is found
	'Const bNOTIFYADMINABOUTRULEABORT = False	'Set "False" to disable rule aborting using the AbortRules() calls when a critical error is found
	
	Const DEBUGFILEPREFIX = "HFM_Rules_DEBUG"	'Set to prefix file name for log files etc.
	Const TIMERFILEPREFIX = "HFM_Rules_TIMER"	'Set to prefix file name for timer files etc.
	' Full file name will be DEV_yyyymmdd_DEBUGFILEPREFIX_Log.txt
	
	' Set MAXDEBUGFILESIZE to the maximum size (in MB) you would like the log file to grow before being deleted
	Const MAXDEBUGFILESIZE = 3
	
	' Set MAXDEBUGNUMBEROFLINES to the maximum number of lines that can be written from a single rule session (calculation, translation, noinput etc.)
	Const MAXDEBUGNUMBEROFLINES = 250000
	
	' Set MAXCELLTEXTLOGNUMBEROFLINES to the maximum number of lines that can be written to the Cell Text Log for each Scenario x Year x Period combination. Once the number is reached, the log is cleared.
	'Const MAXCELLTEXTLOGNUMBEROFLINES = 1000
	Const MAXCELLTEXTLOGNUMBEROFLINES = 99
	
	' Standard Constants for full cross-dimensional member names
	Const ALLTOPS			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1			= ".C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC2			= ".C1#C1_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC3			= ".C1#C1_TOP.C2#C2_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC4			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC5			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxI			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC1C2			= ".C3#C3_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C3			= ".C2#C2_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C4			= ".C2#C2_TOP.C3#C3_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C5			= ".C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC1I			= ".C2#C2_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC2C3			= ".C1#C1_TOP.C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC2C4			= ".C1#C1_TOP.C3#C3_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC2C5			= ".C1#C1_TOP.C3#C3_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC2I			= ".C1#C1_TOP.C3#C3_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC3C4			= ".C1#C1_TOP.C2#C2_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC3C5			= ".C1#C1_TOP.C2#C2_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC3I			= ".C1#C1_TOP.C2#C2_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC4C5			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.I#[ICP Top]"
	Const TOPSxC4I			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C5#C5_TOP"
	Const TOPSxC5I			= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP.C4#C4_TOP"
	Const TOPSxC1C2C3		= ".C4#C4_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C2C4		= ".C3#C3_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C2C5		= ".C3#C3_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC1C2I		= ".C3#C3_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC1C3C4		= ".C2#C2_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C3C5		= ".C2#C2_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC1C3I		= ".C2#C2_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC1C4C5		= ".C2#C2_TOP.C3#C3_TOP.I#[ICP Top]"
	Const TOPSxC1C4I		= ".C2#C2_TOP.C3#C3_TOP.C5#C5_TOP"
	Const TOPSxC1C5I		= ".C2#C2_TOP.C3#C3_TOP.C4#C4_TOP"
	Const TOPSxC2C3C4		= ".C1#C1_TOP.C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC2C3C5		= ".C1#C1_TOP.C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC2C3I		= ".C1#C1_TOP.C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC2C4C5		= ".C1#C1_TOP.C3#C3_TOP.I#[ICP Top]"
	Const TOPSxC2C4I		= ".C1#C1_TOP.C3#C3_TOP.C5#C5_TOP"
	Const TOPSxC2C5I		= ".C1#C1_TOP.C3#C3_TOP.C4#C4_TOP"
	Const TOPSxC3C4C5		= ".C1#C1_TOP.C2#C2_TOP.I#[ICP Top]"
	Const TOPSxC3C4I		= ".C1#C1_TOP.C2#C2_TOP.C5#C5_TOP"
	Const TOPSxC3C5I		= ".C1#C1_TOP.C2#C2_TOP.C4#C4_TOP"
	Const TOPSxC4C5I		= ".C1#C1_TOP.C2#C2_TOP.C3#C3_TOP"
	Const TOPSxC1C2C3C4		= ".C5#C5_TOP.I#[ICP Top]"
	Const TOPSxC1C2C3C5		= ".C4#C4_TOP.I#[ICP Top]"
	Const TOPSxC1C2C3I		= ".C4#C4_TOP.C5#C5_TOP"
	Const TOPSxC1C2C4C5		= ".C3#C3_TOP.I#[ICP Top]"
	Const TOPSxC1C2C4I		= ".C3#C3_TOP.C5#C5_TOP"
	Const TOPSxC1C2C5I		= ".C3#C3_TOP.C4#C4_TOP"
	Const TOPSxC1C3C4C5		= ".C2#C2_TOP.I#[ICP Top]"
	Const TOPSxC1C3C4I		= ".C2#C2_TOP.C5#C5_TOP"
	Const TOPSxC1C3C5I		= ".C2#C2_TOP.C4#C4_TOP"
	Const TOPSxC1C4C5I		= ".C2#C2_TOP.C3#C3_TOP"
	Const TOPSxC2C3C4C5		= ".C1#C1_TOP.I#[ICP Top]"
	Const TOPSxC2C3C4I		= ".C1#C1_TOP.C5#C5_TOP"
	Const TOPSxC2C3C5I		= ".C1#C1_TOP.C4#C4_TOP"
	Const TOPSxC2C4C5I		= ".C1#C1_TOP.C3#C3_TOP"
	Const TOPSxC3C4C5I		= ".C1#C1_TOP.C2#C2_TOP"
	Const TOPSxC1C2C3C4C5	= ".I#[ICP Top]"
	Const TOPSxC1C2C3C4I	= ".C5#C5_TOP"
	Const TOPSxC1C3C4C5I	= ".C2#C2_TOP"
	Const TOPSxC2C3C4C5I	= ".C1#C1_TOP"
	
	Const ALLNONES			= ".C1#[None].C2#[None].C3#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC1			= ".C2#[None].C3#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC2			= ".C1#[None].C3#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC3			= ".C1#[None].C2#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC4			= ".C1#[None].C2#[None].C3#[None].C5#[None].I#[ICP None]"
	Const NONESxC5			= ".C1#[None].C2#[None].C3#[None].C4#[None].I#[ICP None]"
	Const NONESxI			= ".C1#[None].C2#[None].C3#[None].C4#[None].C5#[None]"
	Const NONESxC1C2		= ".C3#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C3		= ".C2#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C4		= ".C2#[None].C3#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C5		= ".C2#[None].C3#[None].C4#[None].I#[ICP None]"
	Const NONESxC1I			= ".C2#[None].C3#[None].C4#[None].C5#[None]"
	Const NONESxC2C3		= ".C1#[None].C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC2C4		= ".C1#[None].C3#[None].C5#[None].I#[ICP None]"
	Const NONESxC2C5		= ".C1#[None].C3#[None].C4#[None].I#[ICP None]"
	Const NONESxC2I			= ".C1#[None].C3#[None].C4#[None].C5#[None]"
	Const NONESxC3C4		= ".C1#[None].C2#[None].C5#[None].I#[ICP None]"
	Const NONESxC3C5		= ".C1#[None].C2#[None].C4#[None].I#[ICP None]"
	Const NONESxC3I			= ".C1#[None].C2#[None].C4#[None].C5#[None]"
	Const NONESxC4C5		= ".C1#[None].C2#[None].C3#[None].I#[ICP None]"
	Const NONESxC4I			= ".C1#[None].C2#[None].C3#[None].C5#[None]"
	Const NONESxC5I			= ".C1#[None].C2#[None].C3#[None].C4#[None]"
	Const NONESxC1C2C3		= ".C4#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C2C4		= ".C3#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C2C5		= ".C3#[None].C4#[None].I#[ICP None]"
	Const NONESxC1C2I		= ".C3#[None].C4#[None].C5#[None]"
	Const NONESxC1C3C4		= ".C2#[None].C5#[None].I#[ICP None]"
	Const NONESxC1C3C5		= ".C2#[None].C4#[None].I#[ICP None]"
	Const NONESxC1C3I		= ".C2#[None].C4#[None].C5#[None]"
	Const NONESxC1C4C5		= ".C2#[None].C3#[None].I#[ICP None]"
	Const NONESxC1C4I		= ".C2#[None].C3#[None].C5#[None]"
	Const NONESxC1C5I		= ".C2#[None].C3#[None].C4#[None]"
	Const NONESxC2C3C4		= ".C1#[None].C5#[None].I#[ICP None]"
	Const NONESxC2C3C5		= ".C1#[None].C4#[None].I#[ICP None]"
	Const NONESxC2C3I		= ".C1#[None].C4#[None].C5#[None]"
	Const NONESxC2C4C5		= ".C1#[None].C3#[None].I#[ICP None]"
	Const NONESxC2C4I		= ".C1#[None].C3#[None].C5#[None]"
	Const NONESxC2C5I		= ".C1#[None].C3#[None].C4#[None]"
	Const NONESxC3C4C5		= ".C1#[None].C2#[None].I#[ICP None]"
	Const NONESxC3C4I		= ".C1#[None].C2#[None].C5#[None]"
	Const NONESxC3C5I		= ".C1#[None].C2#[None].C4#[None]"
	Const NONESxC4C5I		= ".C1#[None].C2#[None].C3#[None]"
	Const NONESxC1C2C3C4	= ".C5#[None].I#[ICP None]"
	Const NONESxC1C2C3C5	= ".C4#[None].I#[ICP None]"
	Const NONESxC1C2C3I		= ".C4#[None].C5#[None]"
	Const NONESxC1C2C4C5	= ".C3#[None].I#[ICP None]"
	Const NONESxC1C2C4I		= ".C3#[None].C5#[None]"
	Const NONESxC1C2C5I		= ".C3#[None].C4#[None]"
	Const NONESxC1C3C4C5	= ".C2#[None].I#[ICP None]"
	Const NONESxC1C3C4I		= ".C2#[None].C5#[None]"
	Const NONESxC1C3C5I		= ".C2#[None].C4#[None]"
	Const NONESxC1C4C5I		= ".C2#[None].C3#[None]"
	Const NONESxC2C3C4C5	= ".C1#[None].I#[ICP None]"
	Const NONESxC2C3C4I		= ".C1#[None].C5#[None]"
	Const NONESxC2C3C5I		= ".C1#[None].C4#[None]"
	Const NONESxC2C4C5I		= ".C1#[None].C3#[None]"
	Const NONESxC3C4C5I		= ".C1#[None].C2#[None]"
	Const NONESxC1C2C3C4C5	= ".I#[ICP None]"
	Const NONESxC1C2C3C4I	= ".C5#[None]"
	Const NONESxC1C3C4C5I	= ".C2#[None]"
	Const NONESxC2C3C4C5I	= ".C1#[None]"
	
	Const sValueEC 			= ".V#<Entity Currency>"
	Const sValueECA 		= ".V#<Entity Curr Adjs>"
	Const sValueECT 		= ".V#<Entity Curr Total>"
	Const sValueNone 		= ".V#[None]"
	
	' ------------------------------------------------------------------------------------------------------------------
	'		01.11 	APPLICATION SPECIFIC CONSTANTS
	' ------------------------------------------------------------------------------------------------------------------
	'GO_LIVE -----------------------------------------------------------------------------------------------------------
	'Const FIRSTLIVEYEAR 	 = 2014
	'Const FIRSTLIVEPERIOD 	 = "Jun"
	'Const FIRSTLIVEPERIODNUM = 6
	
	'Years & Periods ---------------------------------------------------------------------------------------------------
	Const FIRSTAPPYEAR		= 2017
	Const LASTAPPYEAR		= 2036					'UPDATE NEEDED: Change it back to 2036 (used 2035 in old app - HFMDEVNEW)
	Const LASTPERIOD		= "P12"
	Const FIRSTYEAROPENINGS	= 2018					' First year with opening balances (loaded or pulled from prior year)	'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
	Const CUTOVERYEAR		= 2020
	Const CUTOVERPERIOD		= "P6"
	Const CUTOVERYEARPERIOD = 202006
	
	Const CURRENTYEAR		= 2020					'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
	Const PRIORYEAR			= 2019					'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
	'Const CURRENTPERIOD 	= 3						'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
	
	'Entities ----------------------------------------------------------------------------------------------------------
	Const GROUPENTITY		= "Geographic_TOT"		' Main Group Entity
	
	'Accounts ----------------------------------------------------------------------------------------------------------
	Const OPENINGRATE 		= "OPE_RATE"			' Opening Rate Account for the year
	Const CLOSINGRATE 		= "CLO_RATE"			' Closing Rate Account - month end closing rate
	Const AVERAGERATE 		= "AVG_RATE"			' Average Rate Account - year-to-date average rate
	Const CTR 				= "BB9361"				' Foreign Currency Translation Reserves - Calculated
	Const EER 				= "BB9991"				' Equity Elimination Reserve
	
	'Custom1 -----------------------------------------------------------------------------------------------------------
	Const OBCALC			= "C1_1000"				' Opening Balance Calculated - calculated in HFM (base member)
	Const OBADJ				= "C1_1010"				' Opening Balance Adjustment - posted in HFM (base member)
	Const OBTOT				= "C1_M000"				' Opening Balance Total - parent member in HFM
	Const MVCALC			= "C1_9998"				' Movement Calculated - calculated in HFM (base member)
	Const MVATOT	 		= "C1_M110"				' Movement Analysis Total - parent member in HFM
	Const MVTOT 			= "C1_M100"				' Movements Total - parent member in HFM
	Const FXINP				= "C1_1119"				' FX Movement - from GL
	Const FXOPE				= "C1_5501"				' FX Opening to Closing
	Const FXAVG				= "C1_5502"				' FX Average to Closing
	Const FXACQ				= "C1_5503"				' FX Acquisition to Closing
	Const FXHMV				= "C1_5504"				' FX Historic Movement to Closing
	Const FXTOT				= "C1_M200"				' FX Diff Total - parent member in HFM
	Const OBLOAD 			= "C1_9997"				' Opening Balance Loaded - from GL
	Const CBLOAD 			= "C1_9999"				' Closing Balance Loaded - from GL
	Const CBTOT 			= "C1_T000"				' Closing Balance Total - parent member in HFM
	
	'Custom2 -----------------------------------------------------------------------------------------------------------
	
	'Custom3 -----------------------------------------------------------------------------------------------------------
	
	'Custom4 -----------------------------------------------------------------------------------------------------------
	
	'Custom5 -----------------------------------------------------------------------------------------------------------
	
	'Others ------------------------------------------------------------------------------------------------------------
	Const GROUPCURR = "GBP"				' Group / Reporting currency
	
	Const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	Const NUMBERS = "0123456789"
	
	
dim secA2 '   Section A2 - GLOBAL VARIABLES & OBJECTS
		  ' ==========================================================================================================
	'NoInput Variables -------------------------------------------------------------------------------------------------
	Dim aYearsToLoopInNoInput
	
	'Data Conversion Variables -----------------------------------------------------------------------------------------
	
	'POV Variables -----------------------------------------------------------------------------------------------------
	Dim sPOVScenario, sPOVEntity, sPOVYear, iPOVYear, sPOVPeriod, iPOVPeriodNum, iPOVYearPeriod, sPOVValue, sPOVCurrency, sPOVEntityDefCurrency
	Dim sPOVParent, sPOVEntityDefParent, sProcessUnitPOV, sPUPOVshort, sPOVConsolMethod
	
	'Scenario Variables
	Dim bIsActual, bIsFlash, bIsBudget_Pre, bIsBudget, bIsForecast, bIsForecast7plus5, bIsForecastActualPeriod, bIsForecastForecastPeriod, sNextForecast
	
	'Entity Variables --------------------------------------------------------------------------------------------------
	Dim bIsBaseEntity			'base entity but not [None]
	Dim bIsNoneEntity
	Dim bIsParentEntity
	Dim bIsGBPEntity, bIsGroupEntity, sDefaultParent
	Dim bIsJV, bIsAssociate, bIsJVorAssociate, bIsHolding
	
	'Value Variables ---------------------------------------------------------------------------------------------------
	Dim bValueIsEC, bValueIsECA, bValueIsECorECA, bValueIsPC, bValueIsAdjusts, bValueIsTrans, bValueIsNone, bValueIsElimination, bValueIsProportion, bValueIsGBP
	
	'Period Variables --------------------------------------------------------------------------------------------------
	Dim bIsFirstPeriod, bIsLastPeriod, bIsHY, bIsYE, bIsHYorYE, bIsQtr, bCutoverPeriod, bCutoverPriorYearEnd, bBeforeCutover, bAfterCutover, bIsLive
	
	'Year Variables ----------------------------------------------------------------------------------------------------
	Dim bIsFirstYear, bIsFirstYearWithOpenings, bIsLastYear, bIsSecondYear, bIsThirdYear
	
	'Other variables ---------------------------------------------------------------------------------------------------
	Dim bIsHistoricPeriod, nGBPClosingRate, bIsMethodGLOBAL, bIsMethodHOLDING, bIsMethodJV, bIsMethodASSOCIATE, bIsMethodDISCONTINUED, bIsMethodNOCONSOL, bIsMethodUnknown
	Dim bElseCaseFound, sActiveRules, sActiveCodeBlock
	Dim sSubject, sTextBody, sHTMLBody, sAttachmentFilePath, sSendFrom, sSendTO, sSendCC, sSendBCC, sReplyTo
	
	'Lists / Arrays ----------------------------------------------------------------------------------------------------
	Dim aPeriods, aP6P12, aPeriodsExP12, aPeriodsExP1, aPeriodsExP6P12, aPeriodsExQtrs, aYears, aAccountsProcessed, aParameterValues_NOT_USED(100,10)				'REMOVE NOT USED ITEMS LATER
	
	'Objects -----------------------------------------------------------------------------------------------------------
	Dim oSendEmail, oEmailConfig, oConfigFields
	Dim oCustom5_UDA_NOT_USED, oParameterValues_NOT_USED																											'REMOVE NOT USED ITEMS LATER
	
	'Debugging variables -----------------------------------------------------------------------------------------------
	Dim sDebugFolderPath, sFileDeleteLogPath, sEnvironment, sDate, bDebugIsON, bTimerIsON, bDebugSwitchWas, sApplication, sApplication_Environment
	Dim nMaxDebugFileSize, sTimerFileName, sDebugFileName, nNumberOfLinesWritten
	
dim secB3 '   Section B3 - CONSOLIDATION
		  ' ==========================================================================================================
	Dim dConsolidationPercentage, dOwnershipPercentage, dMinorityPercentage, n100Percent, bHasMinority, bEliminated, sDataWithPOV
	Dim dOwnershipPercentage_Prior, dConsolidationPercentage_PY_P12, dOwnershipPercentage_PY_P12, dMinorityPercentage_PY_P12
	
	
dim secB1 '   Section B1 - CALCULATION
		  ' ==========================================================================================================
	Sub CALCULATE()
		sActiveRules = "CALCULATE"
		sActiveCodeBlock = sActiveRules
		
		'Set profile parameters for debugging, POV and Global variables to be used in all Calculate sub-routines and functions
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		Call WriteCurrentRuleVersion
		Call WriteToDebugLog(Now() & "  Sub Calculate for: " & sProcessUnitPOV)
		'Call WriteToCellTextLog("TEST BY")
		'Call AbortRules("TEST BY", "TEST BY")
		CALL TEST_CODE		'used for debugging
		
		If bIsLastYear Then
			'The last year of the app shouldn't be used. Make the HFM Rules abort with a message to the HFM Admin.
			Call AbortRules("LAST-YEAR", "Last year of the application should not be used - " & sPOVYear & " - Add years to the application to be able to use " & sPOVYear)
			
		ElseIf bIsFlash Then
			If bValueIsEC Then   Call CalcFlash
			
		ElseIf bIsNoneEntity And bValueIsNone Then
			Call WriteToDebugLog (">>> NONE Entity - CONSOLIDATION may have been triggered for " & sPOVPeriod & Right(sPOVYear, 2) & vbTab & Now())
			Call ImpactCalcStatus
			
			Call CalcFXRates("Opening Rate")
			Call CalcFXRates("Copy Rates from Actual")
			Call CalcFXRates("Alternate Rates")
			
			'Call CalcForWebforms_NOT_USED	'column suppression accounts etc.
			Call CalcRecurringBalances
			'Call SystemHealthCheck_NOT_USED
			
		ElseIf bValueIsECorECA Then
			Call ImpactCalcStatus
			
			'Call ClearPreviousCalculationResults
			Call CalcRecurringBalances
			
			'Call CalcEnrichmentSelections
			'Call CalcEnforcePeriodicZero("A{EnforcedForPeriodicZero}")
			
			If bIsBaseEntity Then
				If bValueIsEC Then
					Call CopyDataFromAnotherSubCube		'conditional
					Call CalcOpeningBalances("ALL")
				End If
				
				Call CalcRetainedEarningsAndNCI
				If bValueIsEC Then   Call CalcMovements
				Call CalcOther
				
				'If bIsJVorAssociate Then   Call ConsJVorAssociateCalc_NOT_USED			'UPDATE NEEDED: Remove if not needed    (for loss making JVs)
				
			Else
				'If bBeforeCutover Then   Call CalcDataMigrationRelated("Calculate MVCALC for Temporary Members")		'UPDATE NEEDED: REMOVE LATER - added for Data Migration, to help with Reconciliations.
				
			End If
			
			If bValueIsEC Then
				If bIsBaseEntity Then
					Call CalcFXRates("Opening Rate")
					Call CalcFXRates("Historic Opening Rates")
					Call CalcFXRates("Clear Recurring Fixed Rates")
					Call CalcFXRates("Copy Rates from Actual")
					'Call CalcFXRates("Alternate Rates")			'UPDATE NEEDED: do we need to enable this at base entity level?
					
					Call CalcParametric(sValueECT)
				End If
				'Call CalcCashFlow(sValueECT)
				'Call Calc PL()
				'Call ClearCellText("System")
				'Call CalcCopyTBBalancesAsCellText
				
				If bIsBaseEntity Then   Call CopyDataForReTranslation
				
				Call CalcValidations
				Call CalcValidationLockAccounts
			End If
			
		ElseIf bValueIsTrans Then
			Call ImpactCalcStatus
			
			Call CalcOpeningBalances("CTR")
			'Call CalcFXRates("Blended Rates")   					'UPDATE NEEDED: REMOVE IF NOT NEEDED !!!
			Call TransHistoricCalc
			Call TransAlternateRatesCalc
			Call TransOtherCalc
			Call TransParametricCalc_WIP
			'Call CalcRetainedEarningsAndNCI								'UPDATE NEEDED: do we need to run it for isTrans? 20150724: enabled, does it cause any issue?
			
			'If bIsJVorAssociate Then   Call ConsJVorAssociateCalc_NOT_USED			'UPDATE NEEDED: Remove if not needed (for loss making JVs)
			
			'Call TransFX1andFX2
			
			'Call TransClearFXonC4("HISTORIC")
			'Call TransHistoricCostAndFX3
			'Call TransFXTranslationReserve_NOT_USED							'UPDATE NEEDED: REMOVE !!!
			'Call CalcEnforcePeriodicZero("C2#FX3")
			'Call CalcEnforcePeriodicZero("C2#FX4.C4{CONS_IFRS.[Base]}")
			
			'Call TransOffTBatWeightedAverageRate
			
			'Call CalcOpeningBalances
			
			
			'Call CalcParametric("")
			'Call CalcCashFlow("")
			
		ElseIf bValueIsProportion Then
			Call ImpactCalcStatus
			
			'Call CalcRetainedEarningsAndNCI
			Call CalcOpeningBalances("ALL")
			'Call ConsChangeInOwnership
			'Call ConsProfitAttributableToOwners
			
			'Call ConsParametricCalc_WIP
			
			'Call CalcParametric("")
			Call CalcCashFlow("")
			
		ElseIf bValueIsElimination Then
			Call ImpactCalcStatus
			
			'Call CalcRetainedEarningsAndNCI
			Call CalcOpeningBalances("ALL")
			'Call ConsChangeInOwnership
			'Call ConsProfitAttributableToOwners
			
			'Call ConsParametricCalc_WIP
			
			'Call CalcParametric("")
			Call CalcCashFlow("")
			
		ElseIf bValueIsNone Then
			'Calculation is running for [None] value for a base or parent entity. A user may have triggered it by running calculation using a form where [none] value is in the POV/rows/cols (e.g. FD01, VL9002). Do nothing.
			
		Else
			bElseCaseFound = True
		End If
		
		Call ClearGlobalObjects
		
		If bElseCaseFound Then
			'There shouldn't be an else case, because all cases must be caught by if/elseif above. Make the HFM Rules abort with a message to the HFM Admin.
			'Consolidate All' force calculates unused adjustment values (<PCA>, [Parent Adjs], [Contr. Adjs]) which are not covered in if/elseif above but these value members shouldn't get calculated or impacted so it is better to abort the rule.
			Call AbortRules("ELSE-CALC", "I am in ELSE within the If/ElseIf/Else block in SUB CALCULATE() - Process Unit POV:" & sProcessUnitPOV & " - There shouldn't be an Else case. Check if 'Consolidate All' was run, which can cause this, because it can force calculate unused adjustment values (e.g. [Parent Adjs], [Contr. Adjs]). Add this case as an ElseIf condition only if absolutely necessary.")
		End If
		
	'___________________________________________________________________________________________________________________________________________________________________________________________________
		
		
		' SEND EMAIL
		' ==========
		Dim sEmailStatus
		
		If bIsGroupEntity And bValueIsEC Then
			Call WriteToDebugLog (">>> GROUP Entity - CONSOLIDATION may have completed for " & sPOVScenario & " " & sPOVPeriod & " " & sPOVYear & vbTab & vbTab & Now())
			
			sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
			sSendTO    = "bulent.yildiz2@tesco.com"
			sSendCC    = "santosh.pai1@tesco.com"
			'sSendBCC  = ""
			
			sSubject = "Consolidation Completed for " & sPOVScenario & " " & sPOVPeriod & " " & sPOVYear
			
			sHTMLBody = ">>> GROUP Entity - CONSOLIDATION may have completed for " & sPOVScenario & " " & sPOVPeriod & " " & sPOVYear & ". <BR><BR>" & _
						"<B> Process Unit: </B>"		& sProcessUnitPOV 	& "<BR><BR>" & _
						"<B> Date & Time: </B>" 		& CStr(Now()) 		& "<BR><BR>" & _
						"<B> Application: </B>"			& sApplication & " in " & sEnvironment
			sEmailStatus = SendEmail()
		End If
	End Sub   'CALCULATE
	
	
	Sub TRANSLATE()
		sActiveRules = "TRANSLATE"
		sActiveCodeBlock = sActiveRules
		
		'Set Profile Parameters for Debugging, POV and Global variables to be used in all Translate sub-routines and functions
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		CALL TEST_CODE		'used for debugging
		
		'  1. Default Translation
		' --------------------------------------
		' 	HFM is translating all movements at YTD Average Rate by default 		(P&L, B/S movements that are switched for flow type, CF movements and all other Revenue & Expense type accounts)
		'	HFM is translating all balances at Month-End Closing Rate by default	(B/S Opening Balances, Closing Balances and any Asset & Liability type accounts and their custom members that are not switched for flow type)
			
		'  2. Primary Translation
		' --------------------------------------
		'	Translate Opening Balances at Opening Rate and calculate the standard FX movements for all B/S accounts including historic accounts.
			Call TransPrimary
			
		'  3. Historic Translation
		' --------------------------------------
		'	Translate Historic Accounts - Opening Balances at Historic Opening Rates, Equity movements at Fixed (Spot) Rates, Acquisition/Disposal movement(s) at acquisition/disposal rate (in case of an acquisition/disposal)
		'	These rules first clear what have been translated at the standard rates in previous steps and then retranslate using the historic/fixed/acquisition/disposal rates.
			If bIsActual Or bIsForecastActualPeriod Then
				'Full historic translation
				Call TransHistoric("ALL")
				
			ElseIf bIsBudget Then
				'Only the historic balances @ historic opening rates. All movements will be at the YTD average rate by default. This is for the [Budget Budget Post Actualisation] data where the fixed/spot rates are not available.
				Call TransHistoric("Opening Balances")
				
			Else
				'All other scenarios x periods - skip (Flash, [Budget_Pre Budget Pre Actualisation] and Forecast Periods of the Forecast scenarios)
				'No historic translation. All opening balances at the opening rate and all movements at the YTD average rate by default. 
			End If
			
		'  4. Alternate Rate Translations
		' --------------------------------------
		'	Translate Historic Accounts - Opening Balances at Historic Opening Rates, Equity movements at Fixed (Spot) Rates, Acquisition/Disposal movement(s) at acquisition/disposal rate (in case of an acquisition/disposal)
		'	These rules first clear what have been translated at the standard rates in previous steps and then retranslate using the historic/fixed/acquisition/disposal rates.
			If sApplication = "HFMDMDEV" Or sApplication = "HFMDMPPE" Then				'UPDATE NEEDED: remove this later.
				'Skip it for now in these applications, alternate rate translations are taking extra time.
				
			'ElseIf sApplication_Environment = "GROUPHFM_PPE" Then				'UPDATE NEEDED: REMOVE LATER
			'	'Skip it for now in these applications, alternate rate translations are taking extra time.
				
			ElseIf bIsFlash Then
				'No alternate rate translations for the Flash data.
				
			Else
				'All scenarios except Flash need to be retranslated at the alternate rates.
				Call TransAlternateRates
				'Call TransHistoricForAlternateRates_NOT_USED		'REMOVED from Requirements (Business approved during CRP5)		'UPDATE NEEDED: REMOVE
			End If
			
		'  5. Historic Translation Calculations
		' --------------------------------------
		'	TransHistoricCalc sub-routine is called from CALCULATE sub-routine after TRANSLATE ends.
			
		'  6. Alternate Rate Translation Calculations
		' --------------------------------------------
		'	TransAlternateRatesCalc sub-routine is called from CALCULATE sub-routine after TRANSLATE ends.
		
		Call ClearGlobalObjects
	End Sub   'TRANSLATE
	
	
	Sub CONSOLIDATE()
		sActiveRules = "CONSOLIDATE"
		sActiveCodeBlock = sActiveRules
		
		'Set the parameters for Debugging and POV and Global variables to be used in all Consolidate sub-routines and functions
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		CALL TEST_CODE		'used for debugging
		
		bHasMinority  = False
		n100Percent   = 1		'1 = 100%
		
		dConsolidationPercentage 	= HS.Node.PCon("")									'PCon: percentage consolidation
		dOwnershipPercentage 		= HS.Node.POwn("")									'POwn: percentage ownership
		dMinorityPercentage 		= dConsolidationPercentage - dOwnershipPercentage	'PMin: minority ownership
		
		If dMinorityPercentage <> 0 Then bHasMinority = True
		
		If Not bIsFirstPeriod Then
			'dOwnershipPercentage_Prior	= HS.Node.POwn("P#PRIOR")					'percentage ownership for prior period	'UPDATE NEEDED: Remove if not needed
		End If
		'dConsolidationPercentage_PY_P12	= HS.Node.PCon("Y#Prior.P#Last")			'percentage consolidation for prior year end
		'dOwnershipPercentage_PY_P12		= HS.Node.POwn("Y#Prior.P#Last")			'percentage ownership for prior year end
		'dMinorityPercentage_PY_P12			= dConsolidationPercentage_PY_P12 - dOwnershipPercentage_PY_P12	'minority ownership for prior year end
		
		If bIsMethodNOCONSOL Then
			'Not consolidated - skip it			'UPDATE NEEDED: we may need to run Hs.Clear in CALCULATE () - in JVAS_CUR hierarchy zeros are contributing (see data grid Chris G sent on Wed 19/06/2019 14:42)
			
		ElseIf bIsMethodGLOBAL Then
			Call ConsDefault("")
			'Call ConsNCI
			
		ElseIf bIsMethodHOLDING Then
			Call ConsHolding
			
		ElseIf bIsMethodJV Or bIsMethodASSOCIATE Then
			'Call ConsJVorAssociate_OLD("EXCEPT_C5_TRANS")		'UPDATE NEEDED: Remove Later (these are for loss making JVs)
			'Call ConsJVorAssociate_OLD("C5_TRANS")				'UPDATE NEEDED: Remove Later (these are for loss making JVs)
			Call ConsJVorAssociate
			
		ElseIf bIsMethodDISCONTINUED Then
			Call ConsDefault("DISCONTINUED")
			
		ElseIf bIsMethodUnknown Then
			If bIsHolding Then
				'Treat it as the Holding Company
				Call ConsHolding
			Else
				'Treat all other entities with no method as GLOBAL method (subsidiaries, adjustment entities, parent entities etc.)
				If bIsBaseEntity Then
					Call ConsDefault("")
					'Call ConsNCI
				Else
					Call ConsDefault("")
					'Call ConsNCI
				End If
			End If
		Else
			'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
			Call AbortRules("ELSE-CONSOL", "I am in ELSE within the If/ElseIf/Else block in SUB CONSOLIDATE() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
		End If
		
		Call ClearGlobalObjects
	End Sub   'CONSOLIDATE
	
	
dim secB4 '   Section B4 - DYNAMIC
		  ' ==========================================================================================================	
	Sub DYNAMIC()
		sActiveRules = "DYNAMIC"
		sActiveCodeBlock = sActiveRules
		
				
		'KP2510 - LFL Growth ex IFRIC %,   UD01 = FORMULA: (KP2512.C1_6005 / KP2512.C1_6006) - 1
		HS.Dynamic "A#KP2510"& NONESxC2C3C4C5  & " = (A#KP2512.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2512.C1#C1_6006"& TOPSxC1C2C3C4C5 &") - 1"
		
		'KP2515 - LFL Growth inc IFRIC %, UD01 = FORMULA: (KP2511.C1_6005 / KP2511.C1_6006) - 1
		HS.Dynamic "A#KP2515"& NONESxC2C3C4C5  & " = (A#KP2511.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2511.C1#C1_6006"& TOPSxC1C2C3C4C5 &") -1"
		
		'KP2520 - LFL IFRIC Impact %, UD01 =  (KP2515 - KP2510)
		HS.Dynamic "A#KP2520"& NONESxC2C3C4C5 & " = (A#KP2511.C1#C1_6005" & TOPSxC1C2C3C4C5 & " / A#KP2511.C1#C1_6006"& TOPSxC1C2C3C4C5 &" ) - (A#KP2512.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2512.C1#C1_6006"& TOPSxC1C2C3C4C5 &")"
		
		'KP2530 - LFL Volume Growth %, UD01 = FORMULA: (KP2513.C1_6005 / KP2513.C1_6006) -1
		HS.Dynamic "A#KP2530"& NONESxC2C3C4C5  & " = (A#KP2513.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2513.C1#C1_6006"& TOPSxC1C2C3C4C5 &") - 1"
		
		'KP2540 - LFL ASP Growth %, UD01 = FORMULA: ((KP2512.C1_6005 / KP2518.C1_6005) / (KP2512.C1_6006 / KP2518.C1_6006)) - 1
		HS.Dynamic "A#KP2540"& NONESxC2C3C4C5  & " = ((A#KP2512.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2518.C1#C1_6005"& TOPSxC1C2C3C4C5 &")  / (A#KP2512.C1#C1_6006"& TOPSxC1C2C3C4C5 & " / A#KP2518.C1#C1_6006"& TOPSxC1C2C3C4C5 &") ) - 1"
		
		'KP2560 - Mix Growth %, UD01 = FORMULA: KP2515 - KP2530 - KP2555
		HS.Dynamic "A#KP2560"& NONESxC2C3C4C5  & " = (((A#KP2511.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2511.C1#C1_6006"& TOPSxC1C2C3C4C5 &") -1) - ((A#KP2513.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2513.C1#C1_6006"& TOPSxC1C2C3C4C5 &") - 1) - (A#KP2555" & TOPSxC3C4C5 & " ))"
						
		'KP2570	- LFL Transactions Growth %, UD01 = FORMULA: (KP2565.C1_6005 - KP2565.C1_6006) / KP2565.C1_6006
		HS.Dynamic "A#KP2570"& NONESxC2C3C4C5  & " = (A#KP2565.C1#C1_6005"& TOPSxC1C2C3C4C5 & " / A#KP2565.C1#C1_6006"& TOPSxC1C2C3C4C5 &") -1" 
		
	End Sub
	
	
dim secB5 '   Section B5 - NOINPUT and INPUT RULES
		  ' ==========================================================================================================
	Sub NOINPUT()
		sActiveRules = "NOINPUT"
		sActiveCodeBlock = sActiveRules
		
		'Set Profile Parameters for Debugging and Global variables to be used in all NoInput sub-routines and functions
		Call SetGlobalVariables
		Call SetDebugParameters
		CALL TEST_CODE		'used for debugging
		
		Call WriteToDebugLog ("") : Call WriteLineToDebugLog
		Call WriteToDebugLog ("    RULES VERSION: " & RULES_VERSION)
		Call WriteToDebugLog ("    NOINPUT RULES STARTED    " & Now())
		
		Call NoInputs_All
		
		Call ClearGlobalObjects
		Call WriteToDebugLog ("    NOINPUT RULES ENDED      " & Now())
	End Sub   'NOINPUT
	
	Sub INPUT()
		sActiveRules = "INPUT"
		sActiveCodeBlock = sActiveRules
		
		'Set Profile Parameters for Debugging and Global variables to be used in all NoInput sub-routines and functions
		Call SetGlobalVariables
		Call SetDebugParameters
		CALL TEST_CODE		'used for debugging
		
		Call WriteToDebugLog("    INPUT RULES STARTED      " & Now())
		
		Call Inputs_All
		
		Call ClearGlobalObjects
		Call WriteToDebugLog("    INPUT RULES ENDED        " & Now())
		Call WriteLineToDebugLog
	End Sub   'INPUT
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secB2 '   Section B2 - TRANSLATION
		  ' ==========================================================================================================
	
	Sub TransPrimary()
		sActiveCodeBlock = "TransPrimary"
		
		Dim nOpeningRate, nClosingRate, nAverageRate, sDataSource
		
		' GET THE FX RATES
		' ----------------
			nOpeningRate = HS.GetRate("A#" & OPENINGRATE)
			nAverageRate = HS.GetRate("A#" & AVERAGERATE)
			nClosingRate = HS.GetRate("A#" & CLOSINGRATE)
			
			If nOpeningRate = 0 Then
				'Must be the first year, opening rates are zero (if not loaded/input manually). Use the month-end closing rate instead.
				nOpeningRate = nClosingRate
			End If
			
		'Loop through the members of C5_TOTAL, to avoid translating [C5_TRANS Translations at Different Rate] members at the actual rates
		For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
			
			' INCOME STATEMENT
			' ----------------
			' Default Translation - YTD translation (VAL) at YTD average rate (PVA disabled)
				
				
			' B/S - OPENING BALANCE
			' ---------------------
			' OBCALC:[C1_1000 Opening balance] and OBADJ:[C1_1010 Opening balance adjustment]
				'BY: We may need to loop through C5 if we need to translate some C5 members differently !!!
				HS.Trans "C1#" & OBCALC & ".C5#" & sDataSource, "", nOpeningRate, ""
				HS.Trans "C1#" & OBADJ  & ".C5#" & sDataSource, "", nOpeningRate, ""
				
			' [??? Opening balance input] data loaded from GL for validation purposes don't need to be consolidated (clear what was translated by default translation)
				'HS.Clear "C1#???"		'UPDATE NEEDED: BY: REMOVE IF NOT REQUIRED !!!
				
				
			' B/S - MOVEMENTS
			' ---------------
			' Default Translation - YTD translation (VAL) at YTD average rate (PVA disabled)
				
				
			' B/S - FX ADJS
			' -------------
			' Translate whatever FX difference (if any) is coming from children, at the month-end closing rate. 
			'   FXINP:[C1_1119 FX Movement] is treated just like any other movement and translated by default translation at the average rate.
			' BY: isn't this done by the default translation? 'UPDATE NEEDED: REMOVE IF NOT REQUIRED !!!
				' FXOPE:[C1_5501 FX Opening to Closing], FXAVG:[C1_5502 FX Average to Closing]
					HS.Clear "C1#" & FXOPE & ".C5#" & sDataSource
					HS.Clear "C1#" & FXAVG & ".C5#" & sDataSource
					
					HS.Trans "C1#" & FXOPE & ".C5#" & sDataSource, "", nClosingRate, ""
					HS.Trans "C1#" & FXAVG & ".C5#" & sDataSource, "", nClosingRate, ""
					
				'Calculate the FX, translation exchange differences from this entity to the translation currency. These FX difference will be added to the ones coming from children.
				' FXOPE:[C1_5501 FX Opening to Closing]
					'OBTOT:[C1_M000 Opening balance Total]
					HS.Trans "C1#" & FXOPE & ".C5#" & sDataSource, "C1#" & OBTOT & ".C5#" & sDataSource, nClosingRate, nOpeningRate
					
				' FXAVG:[C1_5502 FX Average to Closing]
					'MVTOT:[C1_M100 Movements]
					HS.Trans "C1#" & FXAVG & ".C5#" & sDataSource, "C1#" & MVTOT & ".C5#" & sDataSource, nClosingRate, nAverageRate
					
				
			' B/S - CLOSING BALANCE
			' ---------------------
			' CBTOT:[C1_T000 Closing Balance]			Parent member - not translated, must match CBLOAD(C1_9999)
			' CBLOAD:[C1_9999 Closing Balance Load]		Default Translation - YTD translation at month-end closing rate (PVA disabled)
			' OBLOAD:[C1_9997 Opening Balance Load]		Default Translation - Translation cleared in TransOtherCalc() - C1_9997 is loaded from GL for validation purposes and does not need to be translated
			
			
			' VALIDATIONS
			' -----------
			'Actual Result (VALRAC) - default translation, no need to apply any custom rules
			
			'Effective Result - translate at the rate of 1
				HS.Trans "C4#C4_VALREF1", "", "1", ""
				HS.Trans "C4#C4_VALREF2", "", "1", ""
				
			'Type and Tolerance - do not translate (clear what was translated by default translation)
				HS.Clear "C4#C4_VALTYP"
				HS.Clear "C4#C4_VALTOL"
				
		Next  'data source member (C5)
	End Sub   'TransPrimary
	
	Sub TransHistoric(sWhichBalances)
		sActiveCodeBlock = "TransHistoric"
		
		'All opening balances are translated at opening rate, and movements at average rate by default and these are retranslated at historic rates if those rates exists (i.e. input by the user), but if not then the standard translation is kept.
		
		Dim nOpeningRate, nClosingRate, nAverageRate, sDataSource, sRateAccount, nHistoricOpeningRate, nSpotRate, nClosingRatePriorMonth, sAcquisitionOrDisposalRate
		Dim sUDA, sHistAccount, sHistMovements, aHistAccounts, aHistMovements, sHistOpening ,sHistMovement, sHistFX, sAcquisitionOrDisposalMvmt, sSourcePOV, sTargetPOV
		Dim sTranslatedAtSpotRate, sTranslatedAtAcquisitionOrDisposalRate, sMovement, sC1TopMember, sTargetICP, bFXonCTR, sCTRaccount, sClearedFXAVGfor
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData
		
		' ==========
		'  FX RATES
		' ==========
			nClosingRate = HS.GetRate("A#" & CLOSINGRATE)
			nOpeningRate = HS.GetRate("A#" & OPENINGRATE)
			nAverageRate = HS.GetRate("A#" & AVERAGERATE)
			
			If Not bIsFirstPeriod Then
				nClosingRatePriorMonth 	= HS.GetRate("A#" & CLOSINGRATE & ".P#PRIOR")
			End If
			
			' If nOpeningRate = 0 Then				'UPDATE NEEDED: REMOVE LATER  -  commented out for now, if first year then there is no opening balance, so no need for an opening rate.
				' 'Must be the first year, opening rates are zero (if not loaded/input manually). Use the month-end closing rate instead.
				' nOpeningRate = nClosingRate
			' End If
			
		' ================================
		'  HISTORIC OPENING BALANCES & FX
		' ================================
			Select Case sWhichBalances
			Case "Opening Balances", "ALL", ""
				
				For Each sRateAccount In HS.Account.List("HISTORIC_RATES", "[Base]")
					
					' GET THE HISTORIC RATE
					' ---------------------
					'Formula: Historic Opening Rate = Prior year-end blended closing rate (<PC>.BB12345.C1_T000.YTD / <EC>.BB12345.C1_T000.YTD)
					nHistoricOpeningRate = HS.GetRate("A#" & sRateAccount)
					sUDA = Trim(HS.Account.UD1(sRateAccount))
					
					If sUDA = "" Then
						'UDA parameters not defined. Make the HFM Rules abort with a message to the HFM Admin.
						Call AbortRules("BLANK-UDA-FX1", "Missing Metadata Attribute - UDA parameters not defined for " & sRateAccount)
						
					' ElseIf nHistoricOpeningRate = 0 Then			'UPDATE NEEDED: REMOVE LATER  -  commented out for now, historic opening rates should be calculated correctly, let it translate at zero so this can be noticed.
						' 'No historic rate exists probably due to no opening balance in the account, standard translation applies - skip to the next rate account
						
					Else
						sHistAccount   = GetParameterValue(sUDA, "ACC")
						sHistMovements = GetParameterValue(sUDA, "MVT")
						aHistMovements = Split(sHistMovements, ",")
						
						sUDA 	 = HS.Account.UD1(sHistAccount)
						bFXonCTR = IsParameter(sUDA, "FXCTR")
						If bFXonCTR Then 	sCTRaccount = GetParameterValue(sUDA, "FXCTR")   Else   sCTRaccount = ""
						If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""    Else   sTargetICP = ".I#[ICP None]"
						
						' Clear Standard FX on CTR		'Commented Out - 'UPDATE NEEDED: REMOVE THIS SECTION IF NOT NEEDED - C2#[None] is now invalid for CTR since we changed custom top member (from C2_TOP to C2_S1000)
						' ------------------------
							' 'If sHistAccount = CTR And bFXonCTR Then		'UPDATE NEEDED: REMOVE IF NOT NEEDED (replaced with the condition below)
							' If IsEqual(sHistAccount, sCTRaccount) Then
								' 'CTR account itself. The FX calculated by Standard Translation (TransPrimary) for the data (if there is any) in C2#[None] (coming from CTR.<EC>) should be cleared, because it'll be recalculated by the code below and put into C2_<CTR account> (e.g. C2_BB9361, C2_BB9805). If not cleared, it causes double counting.
								' For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
									' 'Clear previous FX calculated by TransPrimary() @ Closing Rate - Opening Rate by recalculating it in reverse at Opening Rate - Closing Rate
									' sSourcePOV = "A#" & sHistAccount & ".C1#" & OBTOT & ".C2#[None].C5#" & sDataSource
									' sTargetPOV = "A#" & sHistAccount & ".C1#" & FXOPE & ".C2#[None].C5#" & sDataSource
									
									' HS.Trans sTargetPOV, sSourcePOV, nOpeningRate, nClosingRate
								' Next  'data source member (C5)
							' End If
							
						' Translate @ Historic Rate
						' -------------------------
						'Loop through the movements this historic rate applies to (normally one movement per rate)
						For Each sHistOpening In aHistMovements
							'Loop through the members of C5_TOTAL to avoid translating [C5_TRANS Translations at Different Rate] members at the actual rates
							For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
								
								' Clear Standard Translation
								' --------------------------
									'Clear previous translation data produced by TransPrimary() @ Opening Rate by retranslating at the minus opening rate
									HS.Trans "A#" & sHistAccount & ".C1#" & sHistOpening & ".C5#" & sDataSource, "", nOpeningRate * (-1), ""
									
								' ReTranslate @ Historic Rate
								' ---------------------------
									'Retranslate @ Historic Opening Rate
									HS.Trans "A#" & sHistAccount & ".C1#" & sHistOpening & ".C5#" & sDataSource, "", nHistoricOpeningRate, ""
									
								' Clear Standard FX - not needed
								' ------------------------------
									'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) and there shouldn't be any fx movement valid for the historic accounts, so no FX to clear. For exceptional accounts (e.g. [BB1671 Investment in JVs], [SF9110 Investment in JV / Associate]) the FX is on the account, however this doesn't require a change in calculation of FXOPE:[C1_5501 FX Opening to Closing], so the standard calculation is correct.
									
								' Calculate FX
								' ------------
									'FXOPE:[C1_5501 FX Opening to Closing]
									If bFXonCTR Then
										'The FX element related to the historic (blended) opening rate to standard opening rate (i.e. prior year-end blended rate to closing rate) is brought forward in the Opening Balance of CTR (accounts not tagged with FXCTR have this FX fed into their opening balance). What is left to calculate is the standard opening rate to month-end closing rate.
										sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistOpening & ".C2#C2_TOP"			 	& ".C5#" & sDataSource & sTargetICP
										sTargetPOV = "A#" & sCTRaccount	 & ".C1#" & FXOPE		 & ".C2#C2_" & sHistAccount & ".C5#" & sDataSource & sTargetICP
										
										HS.Trans sTargetPOV, sSourcePOV, nClosingRate, nOpeningRate
									Else
										'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) and there shouldn't be any fx movement valid for the historic accounts,
										'FX calculated by the standard translation rules (TransPrimary) is correct, no need to recalculate.
									End If
							Next  'data source member (C5)
						Next  'historic movement (C1)
					End If
				Next  'historic opening rate
			End Select  'which balances
			
		' =========================
		'  HISTORIC MOVEMENTS & FX
		' =========================
			Select Case sWhichBalances
			Case "Movements", "ALL", ""
				
				For Each sRateAccount In HS.Account.List("FIXED_RATES", "[Base]")
					
					' GET THE FIXED/SPOT RATE
					' -----------------------
					'nSpotRate = The spot/blended rate for the transaction(s) in the month that make(s) up this monthly movement (PERIODIC.BB?????.C1_####)
					nSpotRate = HS.GetRate("A#" & sRateAccount)
					sUDA = Trim(HS.Account.UD1(sRateAccount))
					
					If sUDA = "" Then
						'UDA parameters not defined. Make the HFM Rules abort with a message to the HFM Admin.
						Call AbortRules("BLANK-UDA-FX2", "Missing Metadata Attribute - UDA parameters not defined for " & sRateAccount)
						
					ElseIf nSpotRate = 0 Then
						'No rate input by the user, there is a validation checking this - skip it (so don't override translation at YTD average rate)
						
					Else
						'UPDATE NEEDED: REMOVE this comment if not required: If spot rate is zero (no rate input), still translate at zero rate to clear the effect of default translation (at average) and standard fx calc (average to closing)
						sHistAccount   = GetParameterValue(sUDA, "ACC")
						sHistMovements = GetParameterValue(sUDA, "MVT")
						sHistFX 	   = GetParameterValue(sUDA, "FX")
						aHistMovements = Split(sHistMovements, ",")
						
						sUDA 	 = HS.Account.UD1(sHistAccount)
						bFXonCTR = IsParameter(sUDA, "FXCTR")
						If bFXonCTR Then 	sCTRaccount = GetParameterValue(sUDA, "FXCTR")   Else   sCTRaccount = ""
						If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""   Else   sTargetICP = ".I#[ICP None]"
						
						' Clear Standard FX on CTR		'Commented Out - UPDATE NEEDED: REMOVE THIS SECTION IF NOT NEEDED - C2#[None] is now invalid for CTR since we changed custom top member (from C2_TOP to C2_S1000)
						' ------------------------
							' If InStr(sClearedFXAVGfor, sHistAccount) Then
								' 'Standard FX for this account has already been cleared - skip
								
							' 'ElseIf sHistAccount = CTR And bFXonCTR Then		'UPDATE NEEDED: REMOVE IF NOT NEEDED (replaced with the condition below)
							' ElseIf IsEqual(sHistAccount, sCTRaccount) Then
								' 'CTR account itself. The FX calculated by Standard Translation Rules (TransPrimary) for the data (if there is any) in C2#[None] (coming from CTR.<EC>) should be cleared, because it'll be recalculated by the code below and put into C2_<CTR account> (e.g. C2_BB9361, C2_BB9805). If not cleared, it causes double counting.
								' For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
									' 'Clear previous FX calculated by TransPrimary() @ Closing Rate - Averate Rate by recalculating it in reverse at Average Rate - Closing Rate
									' sSourcePOV = "A#" & sHistAccount & ".C1#" & MVTOT & ".C2#[None].C5#" & sDataSource
									' sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG & ".C2#[None].C5#" & sDataSource
									
									' HS.Trans sTargetPOV, sSourcePOV, nAverageRate, nClosingRate
								' Next  'data source member (C5)
								
								' sClearedFXAVGfor = sClearedFXAVGfor & sHistAccount & ","
							' End If
							
						' Translate @ Spot Rate
						' ---------------------
						'Loop through the movements this historic rate applies to (normally one movement per rate)
						For Each sHistMovement In aHistMovements
							'Call WriteToDebugLog ("sRateAccount:" & sRateAccount & " sUDA:" & sUDA & "__sHistAccount:" & sHistAccount & " sHistMovement:" & sHistMovement)
							
							'Loop through the members of C5_TOTAL, to avoid translating [C5_TRANS Translations at Different Rate] members at the actual rates
							For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
								
								' Clear Default Translation
								' -------------------------
									'Clear previous translation data produced by HFM Default Translation Rules @ Average Rate
									HS.Clear "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sDataSource
									
								' ReTranslate @ Spot Rate
								' -----------------------
									HS.TransPeriodic "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sDataSource, "", nSpotRate, ""
									
									'HS.Trans "A#" & sHistAccount & ".C1#" & sHistFX & ".C5#" & sDataSource, "", nClosingRate, ""	'UPDATE NEEDED !!! - is this needed? this is for the second translation e.g. EUR->GBP->USD, EUR->USD->GBP etc.
									
								' Clear Standard FX
								' -----------------------------
									If bFXonCTR Then
										'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) so there is nothing to clear.
									Else
										'Exceptional to the design principle stated above (e.g. [BB1671 Investment in JVs], [SF9110 Investment in JV / Associate])
										'Clear previous FX calculated by TransPrimary() @ Closing Rate - Averate Rate by recalculating it in reverse at Average Rate - Closing Rate. This will deduct from the total FXAVG (from MVTOT) only the portion of FXAVG arising from this movement.
										sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sDataSource
										sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG		  & ".C5#" & sDataSource
										
										HS.Trans sTargetPOV, sSourcePOV, nAverageRate, nClosingRate
									End If
									
								' Calculate Historic FX
								' ---------------------
									'Add FX to Historic FX for this movement (e.g. FXHMV:[C1_5504 FX Historic Movement to Closing])
									'Part 1: FX adjustment due to the difference between closing and spot rates
										If bFXonCTR Then
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sDataSource & sTargetICP
											sTargetPOV = "A#" & sCTRaccount	 & ".C1#" & sHistFX		  & ".C2#C2_" & sHistAccount & ".C5#" & sDataSource & sTargetICP
										Else
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sDataSource
											sTargetPOV = "A#" & sHistAccount & ".C1#" & sHistFX		  & ".C5#" & sDataSource
										End If
										
										HS.TransPeriodic sTargetPOV, sSourcePOV, nClosingRate, nSpotRate
										
									'Part 2: FX adjustment due to the difference between closing and prior month closing rates, applicable to the prior month YTD number which was translated at prior month closing rate.
										If Not bIsFirstPeriod Then
											If bFXonCTR Then
												sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sDataSource & ".P#PRIOR.W#YTD" & sTargetICP
												sTargetPOV = "A#" & sCTRaccount	 & ".C1#" & sHistFX		  & ".C2#C2_" & sHistAccount & ".C5#" & sDataSource & ".W#Periodic"    & sTargetICP
											Else
												sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sDataSource & ".P#PRIOR.W#YTD"
												sTargetPOV = "A#" & sHistAccount & ".C1#" & sHistFX		  & ".C5#" & sDataSource & ".W#Periodic"
											End If
											
											HS.Trans sTargetPOV, sSourcePOV, nClosingRate, nClosingRatePriorMonth
										End If
							Next  'data source member (C5)
							
							sTranslatedAtSpotRate = sTranslatedAtSpotRate & sHistAccount & "." & sHistMovement & ","
							Call AddUniqueToArray(aHistAccounts, sHistAccount)
						Next  'historic movement (C1)
					End If
				Next  'fixed/spot rate
			End Select  'which balances
			
		' ======================================
		'  ACQUISITION / DISPOSAL MOVEMENT & FX
		' ======================================
			'If there is a new acquisition/disposal (or stepped acquisition/disposal), the periodic balance in [C1_5016 Acquisitions]/[C1_5017 Disposals] movement should be translated at the Acquisition/Disposal Rate for all B/S accounts (except some, e.g. Investment in Subs.).
			
			Select Case sWhichBalances
			Case "Movements", "ALL", ""
				
				For Each sRateAccount In HS.Account.List("ACQ_RATES", "[Base]")
					sUDA = Trim(HS.Account.UD1(sRateAccount))
					
					sHistMovements = GetParameterValue(sUDA, "MVT")
					aHistMovements = Split(sHistMovements, ",")
					
					For Each sAcquisitionOrDisposalMvmt In aHistMovements
						'Loop through the members of C5_TOTAL, to avoid translating [C5_TRANS Translations at Different Rate] members at the actual rates
						'For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
							'Pull the data for B/S accounts that have a acquisition balance at the total levels.
							Set oDataUnit = HS.OpenDataUnit("C1#" & sAcquisitionOrDisposalMvmt & ".C5{C5_TOTAL.[Base]}" & TOPSxC1C5 & sValueECT)	'& ".W#Periodic")
							nNumItems = oDataUnit.GetNumItems
							
							If nNumItems > 0 Then
								sAcquisitionOrDisposalRate = HS.GetRate("A#" & sRateAccount)
								
								If sAcquisitionOrDisposalRate = 0 Then
									'No rate input by the user, there is a validation checking this - skip it (so don't override translation at YTD average rate)
								Else
									For i = 0 To nNumItems - 1
										'Get the next item from the data unit
										sAccount 	= oDataUnit.Item(i).Account
										sDataSource = oDataUnit.Item(i).Custom("Custom5")
										
										If InStr(sTranslatedAtSpotRate, sAccount & "." & sAcquisitionOrDisposalMvmt) Then
											'This movement has been translated at spot rate and the FX for it has already been calculated - skip
											'Example: Investment In Subsidiaries x Acquisition movement will need to be translated at a spot rate input into a fixed rate account, because the acquisition rate is used for the Acquired Entity, whereas the invesment amount will be in the Acquiring Entity/Holding Company. The spot rate and the acquisition rate must be same.
										Else
											sCTRaccount = "" : sTargetICP = ""		'by default
											sUDA 	 = HS.Account.UD1(sAccount)
											bFXonCTR = IsParameter(sUDA, "FXCTR")
											
											If bFXonCTR Then
												sCTRaccount = GetParameterValue(sUDA, "FXCTR")
												If Not HS.Account.IsICP(sAccount) Then	sTargetICP = ".I#[ICP None]"
											End If
											
											' Clear Default Translation
											' -------------------------
												'Clear previous translation data produced by HFM Default Translation Rules @ Average Rate
												HS.Clear "A#" & sAccount & ".C1#" & sAcquisitionOrDisposalMvmt & ".C5#" & sDataSource
												
											' ReTranslate @ Acquisition Rate
											' ------------------------------
												HS.TransPeriodic "A#" & sAccount & ".C1#" & sAcquisitionOrDisposalMvmt & ".C5#" & sDataSource, "", sAcquisitionOrDisposalRate, ""
												
												'HS.Trans "A#" & sAccount & ".C1#" & FXACQ & ".C5#" & sDataSource, "", nClosingRate, ""	'UPDATE NEEDED !!! - is this needed? this is for the second translation e.g. EUR->GBP->USD, EUR->USD->GBP etc.
												
											' Clear Standard FX
											' -----------------------------
												If bFXonCTR Then
													'As a design principle, no FX is kept on the historic B/S accounts (FX mvts are invalid) but kept on CTR instead, so there is nothing to clear.
												Else
													'Asset and Liabilities have their FX in their movements (not on CTR), which should be cleared and recalculated for the FXACQ:[C1_5503 FX Acquisition to Closing].
													'Clear previous FX calculated by TransPrimary() @ Closing Rate - Averate Rate by recalculating it in reverse at Average Rate - Closing Rate. FXAVG:[C1_5502 FX Average to Closing]
													sSourcePOV = "A#" & sAccount & ".C1#" & sAcquisitionOrDisposalMvmt & ".C5#" & sDataSource
													sTargetPOV = "A#" & sAccount & ".C1#" & FXAVG				 	   & ".C5#" & sDataSource
													
													HS.Trans sTargetPOV, sSourcePOV, nAverageRate, nClosingRate
												End If
												
											' Calculate Acquisition FX
											' ------------------------
												'Add FX to Acquisition FX for this movement (i.e. FXACQ:[C1_5503 FX Acquisition to Closing])
												'Part 1: FX adjustment due to the difference between closing and spot rates
													If bFXonCTR Then
														sSourcePOV = "A#" & sAccount	& ".C1#" & sAcquisitionOrDisposalMvmt & ".C2#C2_TOP"			& ".C5#" & sDataSource & sTargetICP
														sTargetPOV = "A#" & sCTRaccount	& ".C1#" & FXACQ					  & ".C2#C2_" & sAccount	& ".C5#" & sDataSource & sTargetICP
													Else
														sSourcePOV = "A#" & sAccount & ".C1#" & sAcquisitionOrDisposalMvmt & ".C5#" & sDataSource
														sTargetPOV = "A#" & sAccount & ".C1#" & FXACQ				 	   & ".C5#" & sDataSource
													End If
													
													HS.TransPeriodic sTargetPOV, sSourcePOV, nClosingRate, sAcquisitionOrDisposalRate
													
												'Part 2: FX adjustment due to the difference between closing and prior month closing rates, applicable to the prior month YTD number which was translated at prior month closing rate.
													If Not bIsFirstPeriod Then
														If bFXonCTR Then
															sSourcePOV = "A#" & sAccount	& ".C1#" & sAcquisitionOrDisposalMvmt & ".C2#C2_TOP"		 & ".C5#" & sDataSource & ".P#PRIOR.W#YTD" & sTargetICP
															sTargetPOV = "A#" & sCTRaccount	& ".C1#" & FXACQ					  & ".C2#C2_" & sAccount & ".C5#" & sDataSource & ".W#Periodic"    & sTargetICP
														Else
															sSourcePOV = "A#" & sAccount & ".C1#" & sAcquisitionOrDisposalMvmt & ".C5#" & sDataSource & ".P#PRIOR.W#YTD"
															sTargetPOV = "A#" & sAccount & ".C1#" & FXACQ				 	   & ".C5#" & sDataSource & ".W#Periodic"
														End If
														
														HS.Trans sTargetPOV, sSourcePOV, nClosingRate, nClosingRatePriorMonth
													End If
													
											If ExistsIn(aHistAccounts, sAccount) Then
												'add this to the list, so an FXAVG doesn't get calculated for this account x movement combination.
												sTranslatedAtAcquisitionOrDisposalRate = sTranslatedAtAcquisitionOrDisposalRate & sAccount & "." & sAcquisitionOrDisposalMvmt & ","
											End If
										End If
									Next  'account with acquisition movement
								End If
							End If
							
							Set oDataUnit = Nothing
						'Next  'data source member (C5)
					Next  'movement to translate @ acquisition/disposal Rate
				Next  'acquisition/disposal rate
			End Select  'which balances
			
		' =================
		'  CLOSING BALANCE
		' =================
			'CBTOT:[C1_T000 Closing Balance]			Parent member - not translated
			'CBLOAD:[C1_9999 Closing Balance Load]		Translated in TransHistoricCalc() @ blended rate (historic opening & spot rates) to match CBTOT(C1_T000)
			
		' =============================
		'  CTR - FX AVERAGE TO CLOSING
		' =============================
			'Calculate FXAVG:[C1_5502 FX Average to Closing] for historic accounts' movements that have not been retranslated at a fixed(spot), acquisition or disposal rate
			'UPDATE NEEDED: this is looping through 1000s of combinations, need to convert to a data unit loop, so we don't run hs.trans for no data
			
			Select Case sWhichBalances
			Case "Movements", "ALL", ""
				
				For Each sHistAccount In HS.Account.List("", "A_AccountsForCTR")
					sUDA 	 = HS.Account.UD1(sHistAccount)
					'bFXonCTR = IsParameter(sUDA, "FXCTR")
					bFXonCTR = True
					If bFXonCTR Then 	sCTRaccount = GetParameterValue(sUDA, "FXCTR")   Else   sCTRaccount = ""
					sC1TopMember = HS.Account.CustomTop(sHistAccount, "Custom1")
					If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""   Else   sTargetICP = ".I#[ICP None]"
					
					'MVTOT:[C1_M100 Movements]
					For Each sMovement In HS.Custom("Custom1").List(MVTOT, "[Base]")
						If Not HS.Custom("Custom1").IsBase(sC1TopMember, sMovement) Then
							'This movement is not a valid movement for this historic account - skip
							
						ElseIf InStr(sTranslatedAtSpotRate, sHistAccount & "." & sMovement) Then
							'This movement has been translated at spot rate and the FX for it has already been calculated - skip
							
						ElseIf InStr(sTranslatedAtAcquisitionOrDisposalRate, sHistAccount & "." & sMovement) Then
							'This movement has been translated at the acquisition rate and the FX for it has already been calculated - skip
							
						Else
							'Recalculate FXAVG:[C1_5502 FX Average to Closing] for this movement
							For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
								If bFXonCTR Then
									sSourcePOV = "A#" & sHistAccount & ".C1#" & sMovement & ".C2#C2_TOP"			 & ".C5#" & sDataSource & sTargetICP
									sTargetPOV = "A#" & sCTRaccount  & ".C1#" & FXAVG     & ".C2#C2_" & sHistAccount & ".C5#" & sDataSource & sTargetICP
									
									HS.Trans sTargetPOV, sSourcePOV, nClosingRate, nAverageRate
								Else
									'FX calculated by the standard translation rules (TransPrimary) has already been adjusted above for historic movements, no need to recalculate.
									
									'sSourcePOV = "A#" & sHistAccount & ".C1#" & sMovement & ".C5#" & sDataSource
									'sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG	  & ".C5#" & sDataSource
								End If
							Next  'data source member (C5)
						End If
					Next  'movement
				Next  'historic account
			End Select  'which balances
	End Sub   'TransHistoric
	
	Sub TransHistoricCalc()
		sActiveCodeBlock = "TransHistoricCalc"
		
		'Historic Translation Rules continued in CALCULATE sub-routine
		Dim sRateAccount, sHistAccount, sDataSource, sUDA, nBlendedRate, dEntityCurr, dTransCurr, sReTransMember, sCustom1TopMember
		
		For Each sRateAccount In HS.Account.List("HISTORIC_RATES", "[Base]")
			sUDA = Trim(HS.Account.UD1(sRateAccount))
			
			If sUDA = "" Then
				'UDA parameters not defined. Make the HFM Rules abort with a message to the HFM Admin.
				Call AbortRules("BLANK-UDA-FX3", "Missing Metadata Attribute - UDA parameters not defined for " & sRateAccount)
			Else
				sHistAccount 	  = GetParameterValue(sUDA, "ACC")
				sCustom1TopMember = HS.Account.CustomTop(sHistAccount, "Custom1")
				
				'Check if CBLOAD:[C1_9999 Closing Balance Load] is valid for this historic account, skip if not.
				If HS.Custom("Custom1").IsBase(sCustom1TopMember, CBLOAD) Then
					' ==========================
					'  CB Loaded @ Blended Rate
					' ==========================
						' Blended Closing Rate
						' --------------------
							dEntityCurr = HS.GetCell("A#" & sHistAccount & ALLTOPS & sValueECT)
							dTransCurr  = HS.GetCell("A#" & sHistAccount & ALLTOPS & ".V#" & sPOVCurrency & " Total")
							
							If dEntityCurr = 0 Or dTransCurr = 0 Then
								'No data / zero at the closing balance level in <EC>, no translation is needed
								nBlendedRate = 0
							Else
								'nBlendedRate = 1 / (dTransCurr / dEntityCurr)
								nBlendedRate = dTransCurr / dEntityCurr
							End If
							
						' Translate Closing Balance Loaded at the Blended Rate
						' ----------------------------------------------------
							If nBlendedRate <> 0 Then
								For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
									
									' Clear Default Translation
									' -------------------------
										'Clear previous translation data produced by HFM Default Translation Rules @ Closing Rate. CBLOAD:[C1_9999 Closing Balance Load]
										HS.Clear "A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sDataSource
										
									' Clear Standard FX - not needed
									' ------------------------------
										'There is no FX calculated on CBLOAD(C1_9999)
										
									' ReTranslate at the Blended Rate
									' -------------------------------
										'Retranslate @ Blended Closing Rate
										HS.Exp "A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sDataSource & " = A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sDataSource & sValueECT & " * " & nBlendedRate
										
									' Calculate FX - not needed
									' -------------------------
										'There is no FX calculated on CBLOAD(C1_9999)
										
								Next  'data source member (C5)
							End If
						
					' =====================================
					'  CB Loaded @ Alternate Blended Rates				UPDATE NEEDED: REMOVE LATER - at the CRP5 a decision was made to translate historic accounts in the same way as other B/S accounts (i.e. at the alternate rates).
					' =====================================
						'Do the same for the re-translation members
						' For Each sReTransMember In HS.Custom("Custom5").List("C5_TRANS", "[Base]")
							
							' ' Blended Closing Rate
							' ' --------------------
								' dEntityCurr = HS.GetCell("A#" & sHistAccount & ".C5#" & sReTransMember & TOPSxC5 & sValueECT)
								' dTransCurr  = HS.GetCell("A#" & sHistAccount & ".C5#" & sReTransMember & TOPSxC5 & ".V#" & sPOVCurrency & " Total")
								
								' If dEntityCurr = 0 Or dTransCurr = 0 Then
									' 'No data / zero at the closing balance level in <EC>, no translation is needed
									' nBlendedRate = 0
								' Else
									' 'nBlendedRate = 1 / (dTransCurr / dEntityCurr)
									' nBlendedRate = dTransCurr / dEntityCurr
								' End If
								
							' ' Translate Closing Balance Loaded at the Blended Rate
							' ' ----------------------------------------------------
								' If nBlendedRate <> 0 Then
									' 'Clear Alternate Rate Translation - produced by TransAlternateRates() @ Alternate Closing Rate. CBLOAD:[C1_9999 Closing Balance Load]
										' HS.Clear "A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sReTransMember
										
									' 'Clear Standard FX - not needed - there is no FX calculated on CBLOAD(C1_9999)
										
									' 'ReTranslate @ Blended Closing Rate
										' HS.Exp "A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sReTransMember & " = A#" & sHistAccount & ".C1#" & CBLOAD & ".C5#" & sReTransMember & sValueECT & " * " & nBlendedRate
										
									' 'Calculate FX - not needed - there is no FX calculated on CBLOAD(C1_9999)
										
								' End If
								
						' Next  're-translation member (C5)
						
				End If  'cbload is valid
			End If  'uda is not blank
		Next  'historic opening rate
		
		' ==========================
		'  Calculate CTR for CBLOAD
		' ==========================
			'There is no FX calculated on CBLOAD(C1_9999), however CTR will have a balance at closing balance level, pull it to CBLOAD so that B/S still balances at CBLOAD level at <PC>.
			'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [BB9805 CTR on Minority Interest], CBTOT:[C1_T000 Closing Balance]
			HS.Exp "A#" & CTR 	   & ".C1#" & CBLOAD & " = A#" & CTR 	  & ".C1#" & CBTOT
			HS.Exp "A#" & "BB9805" & ".C1#" & CBLOAD & " = A#" & "BB9805" & ".C1#" & CBTOT
		
		
		' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		' !!!  TEMPORARY CODE FOR CRP5  !!!		- REMOVE LATER
		' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		'Make B/S balance by putting the difference into the CTR account		- REMOVE LATER
		'HS.Exp "A#" & CTR & ".C1#C1_5015.C2#C2_" & CTR & NONESxC1C2C4C5 & " = A#" & CTR & ".C1#C1_5015.C2#C2_" & CTR & NONESxC1C2C4 & " + A#TSTBS" & TOPSxC5
		
	End Sub   'TransHistoricCalc()
	
	Sub TransAlternateRates()
		sActiveCodeBlock = "TransAlternateRates"
		
		Dim nAlternateOpeningRate, nAlternateClosingRate, nAlternateAverageRate, sRateAccountPrefix, bOneRate, sRateAccount, nAlternateRate
		Dim sUDA, sReTransGroup, sReTransMember, aReTransMembers, sApplicability, sExceptions, sAccountGroup, aAccountGroups, sAccountParent
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sMember, sMovement, bOpeningAndClosingRatesAreDifferent
				
		'[C5_TRANS Translations at Reporting Rates]
		For Each sReTransGroup In HS.Custom("Custom5").List("C5_TRANS", "[Children]")
			
			' CHECK APPLICABILITY
			' -------------------
			sUDA = HS.Custom("Custom5").UD3(sReTransGroup)
			sApplicability = GetParameterValue(sUDA, "AppliesTo")
			sExceptions    = GetParameterValue(sUDA, "NotAppliesTo")
			
			If IsApplicableToPOV(sApplicability, sExceptions, "Scenario") Then				'UPDATE NEEDED: it may be worth to add period condition in case they want to retranslate only one period (e.g. P12) at a different rate
				
				' GET RATES
				' ---------
				sUDA = HS.Custom("Custom5").UD1(sReTransGroup)
				bOneRate = IsParameter(sUDA, "RATE")
				
				If bOneRate Then
					'One rate account - get the rate
					sRateAccount = GetParameterValue(sUDA, "RATE")
					nAlternateRate = HS.GetRate("A#" & sRateAccount)
					
					'Call WriteToDebugLog("OneRate, sReTransMember: " & sReTransMember & "   sRateAccount: " & sRateAccount & "   nAlternateRate: " & nAlternateRate)
					
				Else
					'Three rate accounts: opening, average and closing
					sRateAccountPrefix = GetParameterValue(sUDA, "RATEPREFIX")
					
					nAlternateOpeningRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & OPENINGRATE)
					nAlternateAverageRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & AVERAGERATE)
					nAlternateClosingRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & CLOSINGRATE)
					
					If nAlternateOpeningRate <> nAlternateClosingRate Then 
						bOpeningAndClosingRatesAreDifferent = True
					Else
						bOpeningAndClosingRatesAreDifferent = False
					End If
				End If
				
				' LOOP: C5 TRANSLATION MEMBERS
				' ----------------------------
				aAccountGroups = Split(GetParameterValue(sUDA, "ACCS"), ",")
				
				If HS.Custom("Custom5").IsBase("", sReTransGroup) Then
					'Not a hierarhcy but a single member
					aReTransMembers = Array(sReTransGroup)
				Else
					aReTransMembers = HS.Custom("Custom5").List(sReTransGroup, "[Base]")
				End If
				
				For Each sReTransMember In aReTransMembers
					sUDA = HS.Custom("Custom5").UD1(sReTransMember)
					
					If IsNotParameter(sUDA, "DATA") Then
						'No source C5 member speficied so no retranslation needed, it will be populated with data later (e.g. eliminations) - skip
						
					ElseIf bOneRate Then
						'Translate all data at one rate. No FX calculation is required as there is no other rate for FX difference to occur except for the Historic Accounts (see TransHistoricForAlternateRates_NOT_USED()).
						HS.Clear "C5#" & sReTransMember			'BY: is this hs.clear needed? is it working? check
						HS.Trans "C5#" & sReTransMember, "", nAlternateRate, ""
						
					Else
						' LOOP: ACCOUNTS
						' --------------
						For Each sAccountGroup In aAccountGroups
							Select Case sAccountGroup
								Case "PL"	  :  sAccountParent = "PM9999"	'[PM9999 Retained Profit]
								Case "BS"	  :  sAccountParent = "TSTBS"	'[TSTBS Balance Sheet]
								Case "CF"	  :  sAccountParent = "CS9999"	'[CS9999 Cash and Cash Equivalents at End of Period]
								'Case "FLASH"  :  sAccountParent = "FLASH"	'[FLASH Flash Reporting]			'UPDATE NEEDED: REMOVE LATER if not needed
								Case Else
									'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
									Call AbortRules("ELSE-TRANS", "I am in ELSE within the Select Case block in TransAlternateRates() where there shouldn't be an Else case. Add this case into this Select Case block. Case -> sReTransGroup:" & sReTransGroup &"  sAccountGroup:" & sAccountGroup)
							End Select
							
							Select Case sAccountGroup
								Case "PL", "CF"					', "FLASH"				'UPDATE NEEDED: REMOVE LATER flash bit if not needed
									' =================
									'  P&L - Cash Flow
									' =================
									Set oDataUnit = HS.OpenDataUnit("A{" & sAccountParent & ".[Base]}.C5#" & sReTransMember & TOPSxC5 & sValueECT)
									nNumItems = oDataUnit.GetNumItems
									
									For i = 0 To nNumItems - 1
										'Get the next item from the data unit
										'Call oDataUnit.GetItem(i, sAccount, sICP, sC1, sC2, sC3, sC4, dData)
										dData = oDataUnit.Item(i).Data
										If dData <> 0 Then
											sAccount = oDataUnit.Item(i).Account
											HS.Trans "A#" & sAccount & ".C5#" & sReTransMember, "", nAlternateAverageRate, ""
										End If
									Next
									
									Set oDataUnit = Nothing
									
								Case "BS"
									' ===============
									'  Balance Sheet
									' ===============
									' B/S - Opening Balance
									' ---------------------
									' OBCALC:[C1_1000 Opening balance] and OBADJ:[C1_1010 Opening balance adjustment]
										'BY: We may need to loop through C5 if we need to translate some C5 members differently !!!
										HS.Trans "C1#" & OBCALC & ".C5#" & sReTransMember, "", nAlternateOpeningRate, ""
										HS.Trans "C1#" & OBADJ  & ".C5#" & sReTransMember, "", nAlternateOpeningRate, ""
										
									' [??? Opening balance input] data loaded from GL for validation purposes don't need to be consolidated (clear what was translated by default translation)
										'HS.Clear "C1#???"		'BY: REMOVE IF NOT REQUIRED !!!
										
									' B/S - Movements
									' ---------------
									' MVTOT:[C1_M100 Movements]
										For Each sMovement In HS.Custom("Custom1").List(MVTOT, "[Base]")
											HS.Trans "C1#" & sMovement & ".C5#" & sReTransMember, "", nAlternateAverageRate, ""
										Next  'movement
										
									' B/S - FX ADJS
									' -------------
									' Translate whatever FX difference (if any) is coming from children, at the closing rate.
									'   FXINP:[C1_1119 FX Movement] is treated just like any other movement and translated at the average rate.
									' UPDATE NEEDED: Do we need this? REMOVE IF NOT REQUIRED !!!
									' FXOPE:[C1_5501 FX Opening to Closing], FXAVG:[C1_5502 FX Average to Closing], C1_FXACQ:[C1_5503 FX Acquisition to Closing], FXHMV:[C1_5504 FX Historic Movement to Closing]
										HS.Trans "C1#" & FXOPE & ".C5#" & sReTransMember, "", nAlternateClosingRate, ""
										HS.Trans "C1#" & FXAVG & ".C5#" & sReTransMember, "", nAlternateClosingRate, ""
										'HS.Trans "C1#C1_5503.C5#" & sReTransMember, "", nAlternateClosingRate, ""
										'HS.Trans "C1#C1_5504.C5#" & sReTransMember, "", nAlternateClosingRate, ""
										
									'Calculate the FX, translation exchange differences from this entity to the translation currency. These FX difference will be added to the ones coming from children.
									' FXOPE:[C1_5501 FX Opening to Closing]
										'OBTOT:[C1_M000 Opening balance Total]
										If bOpeningAndClosingRatesAreDifferent Then
											HS.Trans "C1#" & FXOPE & ".C5#" & sReTransMember, "C1#" & OBTOT, nAlternateClosingRate, nAlternateOpeningRate
										End If
									' FXAVG:[C1_5502 FX Average to Closing]
										'MVTOT:[C1_M100 Movements]
										HS.Trans "C1#" & FXAVG & ".C5#" & sReTransMember, "C1#" & MVTOT, nAlternateClosingRate, nAlternateAverageRate
										
									' B/S - CLOSING BALANCE
									' ---------------------
									' CBLOAD:[C1_9999 Closing Balance Load]
										HS.Trans "C1#" & CBLOAD & ".C5#" & sReTransMember, "", nAlternateClosingRate, ""			'BY: Do we need to translate CBLOAD? What about OBLOAD?
									
							End Select
						Next  'account group
					End If  'one rate vs three rates
				Next  're-translation member (base)
			Else
				'Not applicable to this scenario - clear the data that may have been pulled from another sub-cube (e.g. opening balances)
				'HS.Clear "C5#" & sReTransMember		'UPDATE NEEDED: remove if not needed - if enabled, should be fixed because currently clearing GL_LOAD. Maybe we can run this clear at <EC> level
			End If  'rate is applicable to the scenario
		Next  're-translation group
	End Sub   'TransAlternateRates
	
	Sub TransAlternateRatesCalc()
		sActiveCodeBlock = "TransAlternateRatesCalc"
		
		'Alternate Rate Translation Rules continued in CALCULATE sub-routine
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sReTransMember, sTargetPOV
		
		' ==========================
		'    Calculate FX on CTR
		' ==========================
			'[TSTBS Balance Sheet], [C5_TRANS Translations at Reporting Rates]
			Set oDataUnit = HS.OpenDataUnit("A#TSTBS.C5{C5_TRANS.[Base]}" & TOPSxC5)
			nNumItems = oDataUnit.GetNumItems
			
			For i = 0 To nNumItems - 1
				'Get the next item from the data unit
				'Call oDataUnit.GetItem(i, sAccount, sICP, sC1, sC2, sC3, sC4, dData)
				dData = oDataUnit.Item(i).Data
				If dData <> 0 Then
					'Make B/S balance by putting the difference into CTR. CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [C1_5015 Foreign Currency Translation], [TSTBS Balance Sheet]
					sReTransMember = oDataUnit.Item(i).Custom("Custom5")
					sTargetPOV = "A#" & CTR & ".C1#C1_5015.C2#C2_" & CTR & ".C5#" & sReTransMember & NONESxC1C2C4C5
					HS.Exp sTargetPOV & " = " & sTargetPOV & " - A#TSTBS.C5#" & sReTransMember & TOPSxC4C5
				End If
			Next
			
			Set oDataUnit = Nothing
			
		' ==========================
		'  Calculate CTR for CBLOAD
		' ==========================
			'There is no FX calculated on CBLOAD(C1_9999), however CTR will have a balance at closing balance level, pull it to CBLOAD so that B/S still balances at CBLOAD level at <PC>.
			'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [BB9805 CTR on Minority Interest], CBTOT:[C1_T000 Closing Balance]
			HS.Exp "A#" & CTR 	   & ".C1#" & CBLOAD & " = A#" & CTR 	  & ".C1#" & CBTOT
			HS.Exp "A#" & "BB9805" & ".C1#" & CBLOAD & " = A#" & "BB9805" & ".C1#" & CBTOT
			
	End Sub   'TransAlternateRatesCalc
	
	Sub TransOtherCalc()
		sActiveCodeBlock = "TransOtherCalc"
		
		'Any other translation rules continued in CALCULATE sub-routine
		
		'OBLOAD:[C1_9997 Opening Balance Load]
			'Clear previous translation data produced by HFM Default Translation Rules @ Closing Rate.			'UPDATE NEEDED: make this parametric and use TransParametricCalc if possible
			HS.Clear "C1#" & OBLOAD
		
	End Sub   'TransOtherCalc
	
	Sub TransParametricCalc_WIP()				'UPDATE NEEDED: REMOVE IF NOT USED
		sActiveCodeBlock = "TransParametricCalc"
		
		'Parametric Translation Rules using Parameters in Metadata (continued in CALCULATE sub-routine). This sub-routine must run last in the Translation Rules.
		Dim sDimension, aDimensions, sDimensionRef, aMembers, aListOfMembers, sMemberListDimension, sMemberListDimRef, sMemberInList, sMember, sUDA
		Dim sTargetCur, sFormula
		'aDimensions = Array("Account", "Custom1", "Custom2", "Custom3", "Custom4", "Custom5", "Entity", "Scenario")
		'aDimensions = Array("Account", "Custom1", "Custom5")
		aDimensions = Array("Custom5")
		
		For Each sDimension In aDimensions
			Select Case UCase(sDimension)
				Case "ACCOUNT" :	aMembers = HS.Account.List("", "[Base]")
				Case "ENTITY"  :	aMembers = HS.Entity.List("", "E_ParentEntities")
				Case "SCENARIO":	aMembers = HS.Scenario.List("", "[Hierarchy]")
				Case Else	   :	aMembers = HS.Custom(sDimension).List("", "[Base]")
			End Select
			
			sDimensionRef = GetDimensionNameOrReference(sDimension)
			
			For Each sMember In aMembers
				'sUDA = HS.Account.UD1(sAccount)
				sUDA = GetUDA(sDimension, sMember, "ALL")
				
				If IsParameterValue(sUDA, "ISTRANS", "N") Then
					'No translation - clear what HFM translated
					HS.Clear sDimensionRef & "#" & sMember
				End If
				
				If IsParameter(sUDA, "TRANSCALC") Then
					sFormula = GetParameterValue(sUDA, "TRANSCALC")
					
					sTargetCur = Left(sFormula, 3)
					
					'UPDATE NEEDED! - temporary solution below, hardcoded rules - need to make parametric
					'TEMP: C5_GCS_ACT_RATE, C5_GCS_BUD_RATE, C5_GCS_GBP	-> their UDA: TRANSCALC: GBP=<EC>
					If IsEqual(sPOVCurrency, sTargetCur) Then
						HS.Exp sDimensionRef & "#" & sMember & " = " & sDimensionRef & "#" & sMember & sValueEC
					End If
					
					' 'Prepare and split sections if there is more than one (delimited with comma)
					' sParameterValue = GetParameterValue(sUDA, "INPUT")
					' If sParameterValue = "" Then
						' 'INPUT parameter without a value - open this member for input for all intersections (e.g. all entities etc. where applicable)
						' HS.Input sDimensionRef & "#" & sMember
						
					' Else
						' If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
							' 'Extra parentheses, remove them.
							' sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
						' End If
						
						' aParamSections = Split(sParameterValue, ",")
						
						' For Each sParamSection In aParamSections
							' sParamSection = Trim(sParamSection)
							
							' If BeginsWith(sParamSection, "{") And EndsWith(sParamSection, "}") Then
								' 'A member list in parameter value, get the list of members into an array
								' aListOfMembers    = GetMemberList(sParamSection, sMemberListDimension)
								' sMemberListDimRef = GetDimensionNameOrReference(sMemberListDimension)
								
								' For Each sMemberInList In aListOfMembers
									' sPOV = sDimensionRef & "#" & sMember & "." & sMemberListDimRef & "#" &  sMemberInList
									
									' HS.Input sPOV
								' Next  'member in the member list
								
							' ElseIf Not BeginsWith(sParamSection, sMember) Then			'UPDATE NEEDED: defect, currently no issues but if the member itself is included in the POV, this will not work.
								' 'The member itself is not included in the POV part. Let's add it to the beginning of it.
								' sParamSection = sDimensionRef & "#" & sMember & "." & sParamSection
								' sPOV = ConvertToPOV(sParamSection)
								
								' HS.Input sPOV
							' End If
						' Next  'section in parameter value
					' End If
				End If  'uda has input parameter
			Next  'member
		Next  'dimension
		
	End Sub   'TransParametricCalc_WIP
	
	Sub CalcFXRates(sWhatToDo)
		sActiveCodeBlock = "CalcFXRates"
		
		Dim dRate, bIsRealData, sCellPOV, sCellPOVPriorPeriod, sAccount, sRateAccount, sHistAccount, sCurrency, sUDA, nBlendedRate, dEntityCurr, dTransCurr, aFixedRates, aRateGroups, sRateGroup, sApplicability, sExceptions, sSourcePOV, aParentCurrenciesForPOVEntity, sParentEntity
			
			'Call WriteToCellTextLog("sWhatToDo:" & sWhatToDo & "  bIsActual:" & bIsActual & "  bIsFirstPeriod:" & bIsFirstPeriod & "  bIsFirstYear:" & bIsFirstYear)
			
		Select Case UCase(sWhatToDo)
			Case "OPENING RATE"
				If bIsFirstYear Then
					'No prior year to pull the rates from - skip
				Else
					'Calculate the Opening FX rate (Period 1: pulled from Closing FX rate of prior year, Period 2 - 12: Pulled from Period 1)
					
					If bIsFirstPeriod Then
						If bIsActual Then
							HS.Clear "A#" & OPENINGRATE
							HS.Exp "A#" & OPENINGRATE & " = A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST"
							
						'ElseIf bIsFlash Or bIsBudget_Pre Or bIsBudget Or bIsForecast Then			'UPDATE NEEDED: REMOVE LATER if not required (Flash scenario translation)
						ElseIf bIsBudget_Pre Or bIsBudget Or bIsForecast Then
							'see Case "COPY RATES FROM ACTUAL"
							
						Else
							'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
							Call AbortRules("ELSE-FX-1", "I am in ELSE within the If/ElseIf/Else block in CalcFXRates() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
						End If
					Else
						'For Period 2 to 12, pull Opening FX rate from Period 1 within the current scenario itself
						HS.Exp "A#" & OPENINGRATE & " = A#" & OPENINGRATE & ".P#FIRST"			'UPDATE NEEDED: Is this needed? If not pulled, will P1 rates not get carried forward to P2-P12?
					End If
				End If
				
			' Case "ENTITY SPECIFIC RATES"				'UPDATE NEEDED: NOT NEEDED, REMOVE LATER (Alex from Group Finance confirmed)
				' If bIsActual And IsEqual(sPOVEntity, "XXXX") Then
					' 'UPDATE NEEDED: Replace XXXX with the correct entity
					' 'Copy Average and Closing rates from Current Period - 2 for this entity
					' For Each sRateAccount In Array (AVERAGERATE, CLOSINGRATE)
						' HS.Exp "A#" & sRateAccount & " = A#" & sRateAccount & ".E#[NONE].P#CUR-2"		'UPDATE NEEDED: Check if this is working when the period extends past the current year
					' Next  'rate account
				' End If
				
			Case "COPY RATES FROM ACTUAL"
				If bIsForecastActualPeriod Then
					'Copy all rates from Actual scenario
					If bIsNoneEntity Then
						aRateGroups = Array("REPORTED_RATES")
					Else
						aRateGroups = Array("REPORTED_RATES", "HISTORIC_RATES", "FIXED_RATES", "ACQ_RATES")
					End If
					
					For Each sRateGroup In aRateGroups
						For Each sRateAccount In HS.Account.List(sRateGroup, "[Base]")
							HS.Exp "A#" & sRateAccount & " = A#" & sRateAccount & ".S#Actual"
						Next  'rate account
					Next  'rate account group
					
				' ElseIf bIsFlash Then															'UPDATE NEEDED: REMOVE LATER if not required (Flash scenario translation)
					' 'Copy YTD Averate rate from Actual scenario
					' HS.Exp "A#" & AVERAGERATE & " = A#" & AVERAGERATE & ".S#Actual"
					
				ElseIf bIsBudget_Pre Then
					'UPDATE NEEDED: this should be made parametric so that they can pull closing balances from a different Forecast scenario into Budget Opening B. if they need to.
					HS.Clear "A#" & OPENINGRATE   :   HS.Exp "A#" & OPENINGRATE & " = A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Forecast_P7"		'same as [PP_OPE_RATE Profit Plan Opening Rate (PY P12 Forecast)]
					HS.Clear "A#" & AVERAGERATE   :   HS.Exp "A#" & AVERAGERATE & " = A#" & AVERAGERATE & ".Y#CUR-2.P#LAST.S#Actual"			'same as [PP_AVG_RATE Profit Plan Average Rate (CY-2 P12)]
					HS.Clear "A#" & CLOSINGRATE   :   HS.Exp "A#" & CLOSINGRATE & " = A#" & CLOSINGRATE & ".Y#CUR-2.P#LAST.S#Actual"			'same as [PP_CLO_RATE Profit Plan Closing Rate (CY-2 P12)]
					
				ElseIf bIsBudget Then
					HS.Clear "A#" & OPENINGRATE   :   HS.Exp "A#" & OPENINGRATE & " = A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Actual"			'same as [BUD_OPE_RATE Budget Opening Rate (PY P12)]
					HS.Clear "A#" & AVERAGERATE   :   HS.Exp "A#" & AVERAGERATE & " = A#" & AVERAGERATE & ".Y#PRIOR.P#LAST.S#Actual"			'same as [BUD_AVG_RATE Budget Average Rate (PY P12)]
					HS.Clear "A#" & CLOSINGRATE   :   HS.Exp "A#" & CLOSINGRATE & " = A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Actual"			'same as [BUD_CLO_RATE Budget Closing Rate (PY P12)]
					
				ElseIf bIsForecastForecastPeriod Then
					'There is no need to calculate, the last Actual period's rates will be used for Forecast periods and these will be carried forward until the end of the year by default.
					
				ElseIf bIsActual Then
					'Actual scenario itself - skip
				Else
					'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
					Call AbortRules("ELSE-FX-2", "I am in ELSE within the If/ElseIf/Else block in CalcFXRates() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
				End If
				
			Case "ALTERNATE RATES"
				If bIsFirstYear Then
					'No prior year to pull the rates from - skip
				Else
					For Each sRateAccount In HS.Account.List("ALTERNATE_RATES", "[Base]")
						sUDA = HS.Account.UD3(sRateAccount)
						sApplicability = GetParameterValue(sUDA, "AppliesTo")
						sExceptions    = GetParameterValue(sUDA, "NotAppliesTo")
						
						If IsApplicableToPOV(sApplicability, sExceptions, "Scenario") Then
							sSourcePOV = ""
							sRateAccount = UCase(sRateAccount)
							
							Select Case sRateAccount
								Case "PY_OPE_RATE"	 :	sSourcePOV = "A#" & OPENINGRATE & ".Y#PRIOR.S#Actual"						'[PY_OPE_RATE Prior Year Same Period Opening Rate]
								Case "PY_AVG_RATE"	 :	sSourcePOV = "A#" & AVERAGERATE & ".Y#PRIOR.S#Actual"						'[PY_AVG_RATE Prior Year Same Period Average Rate]
								Case "PY_CLO_RATE"	 :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#PRIOR.S#Actual"						'[PY_CLO_RATE Prior Year Same Period Closing Rate]
								
								Case "BUD_OPE_RATE"	 :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Actual"				'[BUD_OPE_RATE Budget Opening Rate (PY P12)]
								Case "BUD_AVG_RATE"	 :	sSourcePOV = "A#" & AVERAGERATE & ".Y#PRIOR.P#LAST.S#Actual"				'[BUD_AVG_RATE Budget Average Rate (PY P12)]
								Case "BUD_CLO_RATE"	 :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Actual"				'[BUD_CLO_RATE Budget Closing Rate (PY P12)]
								
								'UPDATE NEEDED: PP_OPE_RATE should be made parametric so that they can pull closing balances from a different Forecast scenario into Budget Opening B. if they need to.
								Case "PP_OPE_RATE"	 :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#PRIOR.P#LAST.S#Forecast_P7"			'[PP_OPE_RATE Profit Plan Opening Rate (PY P12 Forecast)]
								Case "PP_AVG_RATE"	 :	sSourcePOV = "A#" & AVERAGERATE & ".Y#CUR-2.P#LAST.S#Actual"				'[PP_AVG_RATE Profit Plan Average Rate (CY-2 P12)]
								Case "PP_CLO_RATE"	 :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#CUR-2.P#LAST.S#Actual"				'[PP_CLO_RATE Profit Plan Closing Rate (CY-2 P12)]
								
								Case "CONS_OPE_RATE" :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#" & PRIORYEAR & ".P#LAST.S#Actual"	'[CONS_OPE_RATE Constant Opening Rate (Prior FY P12)]
								Case "CONS_AVG_RATE" :	sSourcePOV = "A#" & AVERAGERATE & ".Y#" & PRIORYEAR & ".P#LAST.S#Actual"	'[CONS_AVG_RATE Constant Average Rate (Prior FY P12)]
								Case "CONS_CLO_RATE" :	sSourcePOV = "A#" & CLOSINGRATE & ".Y#" & PRIORYEAR & ".P#LAST.S#Actual"	'[CONS_CLO_RATE Constant Closing Rate (Prior FY P12)]
								
								Case Else
									'Unknown rate account, must be a new account. Rules should be written here for it. Make the rule abort with a message to the HFM Admin.
									Call AbortRules("UNKNOWN-RATE", "Unknown FX rate account. This account (" & sRateAccount & ") is unknown to the HFM rules. Please add the necessary code into CalcFXRates() and ImpactCalcStatus() if applicable")
							End Select
							
							If sSourcePOV <> "" Then
								HS.Clear "A#" & sRateAccount
								HS.Exp "A#" & sRateAccount & " = " & sSourcePOV
							End If
						End If
					Next  'rate account
				End If
				
			Case "HISTORIC OPENING RATES"
				'If bIsGBPEntity Then
					'GBP entities don't need translation in the main hierarchy - skip. UPDATE NEEDED: there may be a need for translation to other currencies in other hierarchies (e.g. local, management) - UPDATED on 15 Jul 2019 - see below
				'ElseIf bIsFirstYear Then
				If bIsFirstYear Then
					'No prior year to pull the rates from - skip
				ElseIf bIsFirstPeriod And (bIsActual Or bIsBudget) Then
					'Only for Actual or Budget Post Actualisation  (other scenarios will pull these rates from Actual scenario current year data (if applicable))
					'Period 1: pulled from P12 x Prior Year		Period 2 - 12: no need to pull from prior periods because HFM does this by default
					
					'Dynamic POV List: Currencies of the parent entities the POV entity is a child of. (Member List: C1_ParentCurrenciesForEntity(@POV))
					For Each sParentEntity In HS.Entity.List(sPOVEntity, "[Parents]")
						sCurrency = HS.Entity.DefCurrency(sParentEntity)
						If sCurrency = sPOVEntityDefCurrency Then
							'<PC> same as <EC> - no need to add - skip
						Else
							Call AddUniqueToArray(aParentCurrenciesForPOVEntity, sCurrency)
						End If
					Next  'parent entity
					
							' For Each sCurrency In aParentCurrenciesForPOVEntity
								' Call WriteToCellTextLog ("sPOVEntity: " & sPOVEntity & "   sCurrency In aParentCurrenciesForPOVEntity: " & sCurrency)			'FOR DEBUGGING - REMOVE LATER
							' Next
					
					'  Historic Opening Rates
					' ------------------------
					'Calculate the historic opening from the blended closing rate for each historic account if translation is needed in any of the entity hierarchies
					If IsArray(aParentCurrenciesForPOVEntity) Then
						For Each sRateAccount In HS.Account.List("HISTORIC_RATES", "[Base]")
							'sCellPOV = "A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2
							'dRate = HS.GetCellRealData(sCellPOV, bIsRealData)			'UPDATE NEEDED: Commented out for CRP - see additional info below.
							
							'If bIsRealData Then
								'Don't touch - rate input by the user
								
								'UPDATE NEEDED: Commented out for CRP. The need for manual input needs to be validated by Business. Luke had requested this to be open for input (Luke: "Yes we need to enter in some historic rates some times when rules are not fulfilling enough and leave the historic rate and blank and therefore no translation happens and incorrect numbers are given. For example there is a GBP entity that needs to translate into INR in the local currency hierarchy. There is a handful of entities that these manual entries need to happen on an annual roll over activity." on 4/7/2018)
							'Else
								'Calculate it from the prior year end's blended closing rate
								sUDA = Trim(HS.Account.UD1(sRateAccount))
								
								If sUDA = "" Then
									'UDA parameters not defined. Make the HFM Rules abort with a message to the HFM Admin.
									Call AbortRules("BLANK-UDA-FX4", "Missing Metadata Attribute - UDA parameters not defined for " & sRateAccount)
								Else
									'Period 1: pulled from blended closing rate of prior year
									sHistAccount = GetParameterValue(sUDA, "ACC")
									
									For Each sCurrency In aParentCurrenciesForPOVEntity
										sCellPOV = "A#" & sRateAccount & ".C1#" & sCurrency & ".C2#" & sPOVEntityDefCurrency & NONESxC1C2
										
										dEntityCurr = HS.GetCell("A#" & sHistAccount & ALLTOPS & sValueECT & ".Y#PRIOR.P#LAST.S#Actual")
										dTransCurr  = HS.GetCell("A#" & sHistAccount & ALLTOPS & ".V#" & sCurrency & " Total" & ".Y#PRIOR.P#LAST.S#Actual")
										
										If dEntityCurr = 0 Or dTransCurr = 0 Then
											'No data / zero at the closing balance level in <EC>, no translation is needed
										Else
											nBlendedRate = 1 / (dTransCurr / dEntityCurr)
											HS.Exp sCellPOV & " = " & nBlendedRate
										End If
									Next  'parent currency for the pov entity
								End If
							'End If
						Next  'historic rate
					End If
					
					'  Acquisition / Disposal Rates
					' ------------------------------
					If bIsActual Then
						For Each sRateAccount In HS.Account.List("ACQ_RATES", "[Base]")
							sCellPOV = "A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2
							dRate = HS.GetCellRealData(sCellPOV, bIsRealData)
							
							If bIsRealData Then
								'Don't touch - rate input by the user
							Else
								'Period 1: pulled from P12 x Prior Year
								HS.Exp sCellPOV & " = " & sCellPOV & ".Y#PRIOR.P#LAST"
							End If
						Next  'historic rate
					End If
				End If
				
			Case "CLEAR RECURRING FIXED RATES"
				'Clear the fixed rates and acquisition rates recurring from prior periods
				
				If bIsGBPEntity Or bIsFirstPeriod Then
					'GBP entities don't need translation in the main hierarchy - skip. UPDATE NEEDED: there may be a need for translation to other currencies in other hierarchies (e.g. local, managemenet)
					'Not needed for Period 1.
				ElseIf bIsActual Or bIsForecastForecastPeriod Then
					aFixedRates = HS.Account.List("FIXED_RATES", "[Base]")
					'Call AddToArray(aFixedRates, "ACQRATE")			'BY: DISABLED for now, ENABLE BACK if necessary.
					
					For Each sRateAccount In aFixedRates
						sCellPOV = "A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2
						dRate = HS.GetCellRealData(sCellPOV, bIsRealData)
						
						If bIsRealData Then
							'Don't touch - rate input by the user
						Else
							'Check prior period's rate
							sCellPOVPriorPeriod = "A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2 & ".P#PRIOR"
							dRate = HS.GetCell(sCellPOVPriorPeriod)
							If dRate <> 0 Then
								'Set it to zero so it doesn't use prior period's rate. User must input a new spot rate if there is a periodic movement in this period
								HS.Exp sCellPOV & " = 0"
							End If
						End If
					Next  'fixed rate
				Else
					'Other scenarios will pull these rates from ACTUAL (if applicable)
				End If
		End Select
	End Sub   'CalcFXRates
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secB6 '   Section B6 - ONDEMAND RULES
		  ' ==========================================================================================================
	Sub OnDemand_Request_FD_Review_Phase1()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_Request_FD_Review_Phase1"
		
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		
		If bValueIsNone Then  Call Request_FD_Review("Phase 1")
		
	End Sub   'OnDemand_Request_FD_Review_Phase1
	
	Sub OnDemand_Request_FD_Review_Phase2()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_Request_FD_Review_Phase2"
		
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		
		If bValueIsNone Then  Call Request_FD_Review("Phase 2")
		
	End Sub   'OnDemand_Request_FD_Review_Phase2
	
	Sub OnDemand_Invalidate_PIN_Phase1()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_Invalidate_PIN_Phase1"
		
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		
		If bValueIsNone Then  Call Invalidate_PIN("Phase 1")
		
	End Sub   'OnDemand_Invalidate_PIN_Phase1
	
	Sub OnDemand_Invalidate_PIN_Phase2()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_Invalidate_PIN_Phase2"
		
		Call SetDebugParameters
		Call SetGlobalVariables
		Call SetPOVVariables
		
		If bValueIsNone Then  Call Invalidate_PIN("Phase 2")
		
	End Sub   'OnDemand_Invalidate_PIN_Phase2
	
	Sub Request_FD_Review(sPhase)
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "Request_FD_Review"
		
		Dim oDataUnit, sDataUnitPOV, nNumItems, sAccountsForPhase, sAccount, sC5ReviewPoint, sC5Source, sCustom5TopMember
		Dim sRequestor, sEntityDescription, iPIN, iUpperBound, iLowerBound, sReportInHTMLformat, sCalcStatus, sPINstatus, sEmailStatus, sPhaseC4, sDataSet, sEmailTO, sEmailCC
		'Call WriteToAllDebugLogs(sActiveCodeBlock & " is running... " & Now())
		
		'On Error GoTo ErrorOccurred
		
			'Call WriteToAllDebugLogs(HS.CalcStatus("Scenario.Year.Period.Entity.Value"))
			'Call WriteToAllDebugLogs(sProcessUnitPOV & " -> Calc Status: " & HS.CalcStatus(""))
			'Call WriteToAllDebugLogs(sProcessUnitPOV & " -> Calc Status: " & HS.CalcStatus("S#Actual.Y#CUR.P#CUR.E#THA_TOT.V#<Entity Currency>"))
			'Call WriteToAllDebugLogs(sProcessUnitPOV & " -> Calc Status: " & HS.CalcStatus("S#Actual.Y#2020.P#P12.E#ASIA_TOT.THA_TOT.V#<Entity Currency>"))
			
			' sReportInHTMLformat = "<table style=""undefined;table-layout: fixed; width: 676px""><colgroup><col style=""width: 244px""><col style=""width: 85px""><col style=""width: 126px""><col style=""width: 78px""><col style=""width: 21px""><col style=""width: 122px""></colgroup><tr><th></th><th>GL Load</th><th>Local Adjustments</th><th>Local Total</th><th></th><th>Exceptional Items</th></tr><tr><td>Account Description 1</td><td>1,000,000</td><td>-15,000</td><td>9,985,000</td><td></td><td>80,000</td></tr><tr><td>Account Description 2</td><td>500,000</td><td></td><td>500,000</td><td></td><td>25,000</td></tr><tr><td>Account Description 3</td><td>20,500</td><td>-500</td><td>20,000</td><td></td><td> </td></tr><tr><td>TOTAL</td><td>1,520,500</td><td>-15,500</td><td>1,505,000</td><td></td><td>105,000</td></tr></table>"
		
		Select Case UCase(sPhase)
			Case "PHASE 1"
				sPhaseC4 = ".C4#C4_PHASE1"
				sDataSet = "Income Statement, Balance Sheet, Cash Flow and Key Performance Indicators & Analysis"
				sAccountsForPhase = "A_Phase1_Accounts"
				sDataUnitPOV = "A{" & sAccountsForPhase & "}.C5{C5_FDSIGN.[Base]}" & sValueECT
				
			Case "PHASE 2"
				sPhaseC4 = ".C4#C4_PHASE2"
				sDataSet = "Supplementary Notes"
				sAccountsForPhase = "A_Phase2_Accounts"
				sDataUnitPOV = "A{" & sAccountsForPhase & "}.C5{C5_FDSIGN.[Base]}" & sValueECT
		End Select
		
		'sCalcStatus = HS_CalcStatus("")
		'sCalcStatus = HS_CalcStatus("S#" & sPOVScenario & ".Y#" & sPOVYear & ".P#" & sPOVPeriod & ".E#" & sPOVEntity & sValueECT)
		sCalcStatus = HS.CalcStatus(sValueECT)		'sValueEC will be sufficient for a parent entity because allow adj is N for parents.   UPDATE NEEDED: if sValueECT is a problem then we need a check to see if it is base/parent entity
		
		sEntityDescription = HS.GetCellTextWithLabel("A#EntityDescription" & ALLNONES & ".Y#" & LASTAPPYEAR & ".P#" & LASTPERIOD & sValueNone, "System")
		
			'Call WriteToAllDebugLogs(sProcessUnitPOV & " -> Calc Status: " & HS.CalcStatus(""))
		
		If IsNotParameter(HS.Entity.UD2(sPOVEntity), "PIN") Then
			'This entity doesn't have to be reviewed by an FD - no PIN process. Notify the user. '[PIN_STATUS PIN Status]
			sPINstatus = "FD Sign Off by PIN is not activated for this entity - " & sPOVEntity & " - " & CStr(Now())
			HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
			
		ElseIf sCalcStatus = "NODATA" Then
			'There is no data in the entity. Notify the user.
			sPINstatus = "There is no data in this entity - " & sPOVEntity & " - " & CStr(Now()) & " - Calc Status:" & sCalcStatus
			HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
			
		ElseIf Left(sCalcStatus, 2) <> "OK" Then
			'Calculation / Consolidation need to be run first. Notify the user.
			sPINstatus = "Please calculate/consolidate this entity before requesting a review - " & sPOVEntity & " - " & CStr(Now()) & " - Calc Status:" & sCalcStatus
			HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
			
		Else			'UPDATE NEEDED: An ElseIf is needed to check if any hard validations are failing (those validations should be cleared first)
			
			'Prepare and send email including PIN
			
			'  Generate PIN
			' --------------
				Randomize
				iLowerBound = 1000 : iUpperBound = 9999
				iPIN = Int((iUpperBound - iLowerBound) * Rnd + iLowerBound)
				
			'  FROM, TO, CC, BCC, Reply To
			' -----------------------------
				'sSendFrom = "oc-141-144-21-44@em3.opc.oracleoutsourcing.com"
				'sSendFrom = "no-reply@em3.opc.oracleoutsourcing.com"
				sSendFrom  = """HFM PIN"" <no-reply@em3.opc.oracleoutsourcing.com>"
				sSendTO    = Trim(HS.GetCellTextWithLabel("A#PIN_SENT_TO" & sPhaseC4 & NONESxC4 & ".Y#" & LASTAPPYEAR & ".P#" & LASTPERIOD & sValueNone, "System"))
				sSendCC    = Trim(HS.GetCellTextWithLabel("A#PIN_SENT_CC" & sPhaseC4 & NONESxC4 & ".Y#" & LASTAPPYEAR & ".P#" & LASTPERIOD & sValueNone, "System"))
				'sSendBCC  = "bulentyildiz@gmail.com"
				sRequestor = Trim(HS.GetCellTextWithLabel("A#PIN_REQ_NAME"	& sPhaseC4 & NONESxC4 & sValueNone, "[Default]"))
				sReplyTo   = Trim(HS.GetCellTextWithLabel("A#PIN_REQ_EMAIL"	& sPhaseC4 & NONESxC4 & sValueNone, "[Default]"))
				
				'Checks
				If sSendTO = "" Then
					'No FD email address has been assigned to this entity. Notify the user.
					sPINstatus = "Please contact administrator - No FD email address has been assigned to [" & sPOVEntity & "  " & sEntityDescription & "] - " & CStr(Now())
					HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
					Exit Sub
					
				ElseIf sRequestor = "" Or sReplyTo = "" Then
					'No name or email address for the requestor. Remind the user that this is mandatory.
					sPINstatus = "Please enter your name, surname and business email address correctly. - " & CStr(Now())
					HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
					Exit Sub
				End If
				
			'  Subject & Message
			' -------------------
				'sSubject = "HFM Review and Sign Off for " & sPOVScenario & ", " & sPOVEntity & ", " & sPOVYear & ", " & sPOVPeriod
				sSubject = "HFM Review and Sign Off"
				
				sHTMLBody = "<H3><B>Dear Reviewer</B></H3>" & _
							sRequestor & " has made a request for you to review and sign off the data for the process unit below.<BR><BR>" & _
							"<B>Scenario: </B>" & sPOVScenario	& "<BR>" & _
							"<B>Entity: </B>"	& sPOVEntity 	& " - " & sEntityDescription & "<BR>" & _
							"<B>Year: </B>"		& sPOVYear		& "<BR>" & _
							"<B>Period: </B>"	& sPOVPeriod	& "<BR>" & _
							"<B>Phase: </B>"	& sPhase		& "<BR><BR>" & _
							"This phase of data submission covers " & sDataSet & ".<BR><BR>" & _
							"If you approve the data included in the HFM reports " & sRequestor & " shared with you, simply <B>REPLY</B> to this email with your approval. Your email will be sent to " & sRequestor & ".<BR>" & _
							"If you do not approve the data included in these reports, <B>DO NOT</B> reply or share the PIN included in this email, but please notify " & sRequestor & ". <BR><BR>" & _
							"<B>PIN: </B>" & iPIN & "<BR><BR><BR>" & _
							"<B>Requested By: </B>" & sRequestor & "<BR>" & _
							"<B>Requestor's Email: </B>" & sReplyTo & "<BR>" & _
							"<B>Date & Time: </B>" & CStr(Now()) & "<BR><BR>" & _
							"Application: " & sApplication & " in " & sEnvironment
							
							'"This phase of data submission covers " & sDataSet & ". Please review all relevant reports for this phase before proceeding with the options below." & "<BR><BR>" & _
							
							' "Bulent Yildiz has requested you to review and sign off the reports included in this email.<BR><BR>" & _
							' "If you approve the data included in these reports, simply REPLY to this email with your approval.<BR>" & _
							' "If you do not approve the data included in these reports, DO NOT reply or share the PIN included in this email, but please notify Bulent Yildiz.<BR>" & "<BR><BR>" & _
							' sReportInHTMLformat & "<BR><BR>" & _
							' "PIN: " & iPIN & "<BR><BR>" & _
							' CStr(Now())
				'sHTMLBody = "<H3><B>Dear Reviewer</B></H3>" & "Bulent Yildiz has requested you to review and sign off the reports.<BR>" & "<BR><BR>   <B>PIN:</B> " & iPIN
				
			'  Send PIN to FD
			' ----------------
				sEmailTO = sSendTO  :  sEmailCC = sSendCC	  'to use in status message because SendEmail() will clear these global variables
				sEmailStatus = SendEmail()
				
			'  Record PIN and Audit Data
			' ---------------------------
				If sEmailStatus = "sent" Then
					'[PIN_CALC PIN Generated by System]
					HS.SetCellTextWithLabel "A#PIN_CALC" & sPhaseC4 & NONESxC4 & sValueNone, "System", iPIN
					'HS.Exp "A#PIN_CALC" & sPhaseC4 & NONESxC4 & " = " & iPIN			'UPDATE NEEDED: REMOVE IF NOT REQUIRED (written also as cell text)  - giving error when POV is <ECT> in the webform.
					
					'[PIN_SENT_TO Reviewer - PIN email is sent to this address in TO field], [PIN_SENT_CC Reviewer - PIN email is sent to this address in CC field]
					If sEmailTO  <> "" Then	  HS.SetCellTextWithLabel "A#PIN_SENT_TO" & sPhaseC4 & NONESxC4 & sValueNone, "System", sEmailTO
					If sEmailCC  <> "" Then   HS.SetCellTextWithLabel "A#PIN_SENT_CC" & sPhaseC4 & NONESxC4 & sValueNone, "System", sEmailCC
					
					'[PIN_STATUS PIN Status] - PIN has been sent in an email to the FD. Notify the user.
					If sEmailCC  <> "" Then   sEmailCC = " (CC: " & sEmailCC & ")"
					sPINstatus = "Review request has been sent to " & sEmailTO & sEmailCC & " on " & CStr(Now())
					HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
				End If
				
			'  Other Data for Validation Checks
			' ----------------------------------
				If sEmailStatus = "sent" Then
					' - NUMBER OF RECORDS - 
					'Record the # of records as of now to compare it later to # of records when calculation runs again (so if there a change in this number, validation will fail)
					'[NumberOfRecords - Number of records when FD review was requested], [C5_FDSIGN FD Sign Off]
					Set oDataUnit = HS.OpenDataUnit(sDataUnitPOV)
					nNumItems = oDataUnit.GetNumItems
					HS.SetCellTextWithLabel "A#NumberOfRecords" & sPhaseC4 & NONESxC4 & sValueNone, "System", nNumItems
					HS.Exp					"A#NumberOfRecords" & sPhaseC4 & NONESxC4 & " = " & nNumItems
					
					' - DATA FOR COMPARISON - 
					'Copy all data FD is responsible to review to [None] value, to be used later by the validation for comparison (so if there a change in balances, validation will fail)
					For Each sC5ReviewPoint In HS.Custom("Custom5").List("", "C5_SignedOffBalances")
						For Each sAccount In HS.Account.List("", sAccountsForPhase)
							'Check if the Data Source Analysis is available for the account  (not using Hs.IsValidDest because it writes to System Messages)
							sCustom5TopMember = UCase(HS.Account.CustomTop(sAccount, "Custom5"))
							
							If sCustom5TopMember = "" Or sCustom5TopMember = "[NONE]" Then
								'Must be a validation account or similar. Data Source Analysis isn't available - skip
							Else
								If HS.Custom("Custom5").IsBase(sCustom5TopMember, sC5ReviewPoint) Then
									'Copy data into this Sign Off member which will be used for comparison
									sC5Source = Left(sC5ReviewPoint, Len(sC5ReviewPoint) - 5)
									HS.Exp "A#" & sAccount & ".C5#" & sC5ReviewPoint & " = " & "A#" & sAccount & ".C5#" & sC5Source & sValueECT			'e.g. HS.Exp "C5_EXCEPT_SIGN = C5_EXCEPT"
								End If
							End If
						Next  'account for this phase
					Next  'data review point in C5
				End If
				
				Set oDataUnit = Nothing
		End If
		
		'Exit Sub
		'ErrorOccurred:
		'Call WriteToAllDebugLogs(">>> Error occurred")
	End Sub   'Request_FD_Review
	
	Sub Invalidate_PIN(sPhase)
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "Invalidate_PIN"
		
		Dim sCalcStatus, sPINstatus, sPhaseC4
		'Call WriteToAllDebugLogs(sActiveCodeBlock & " is running... " & Now())
		
		Select Case UCase(sPhase)
			Case "PHASE 1" :  sPhaseC4 = ".C4#C4_PHASE1"
			Case "PHASE 2" :  sPhaseC4 = ".C4#C4_PHASE2"
		End Select
		
		If IsNotParameter(HS.Entity.UD2(sPOVEntity), "PIN") Then
			'This entity doesn't have to be reviewed by an FD - no PIN process. Notify the user. '[PIN_STATUS PIN Status]
			sPINstatus = "FD Sign Off by PIN is not activated for this entity - " & sPOVEntity & " - " & CStr(Now())
			HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
			
		' ElseIf Left(sCalcStatus, 2) <> "OK" Then
			' 'Calculation / Consolidation need to be run first. Notify the user.
			' sPINstatus = "Please run calculation/consolidation for this entity before requesting a review - " & sPOVEntity & " - " & CStr(Now()) & "   Calc Status:" & sCalcStatus
			' HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
			
		Else
			
			'  Clear PIN and Audit Data
			' --------------------------
				'[PIN_CALC PIN Generated by System], [PIN_INPUT Please Enter FD Sign Off PIN]
				HS.SetCellTextWithLabel "A#PIN_CALC"  & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
				'HS.SetCellTextWithLabel "A#PIN_INPUT" & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
				'HS.Clear "A#PIN_CALC" & sPhaseC4 & NONESxC4					'UPDATE NEEDED: REMOVE IF NOT REQUIRED (written also as cell text)  - giving error when POV is <ECT> in the webform.
				'HS.Clear "A#PIN_INPUT" & sPhaseC4 & NONESxC4					'Disabled this - no need to clear pin input by user, leave it there. it won't work any more anyway.     UPDATE NEEDED: REMOVE LATER
				
				'[PIN_SENT_TO Reviewer - PIN email is sent to this address in TO field], [PIN_SENT_CC Reviewer - PIN email is sent to this address in CC field]
				'HS.SetCellTextWithLabel "A#PIN_SENT_TO" & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
				'HS.SetCellTextWithLabel "A#PIN_SENT_CC" & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
				
				'[PIN_STATUS PIN Status]
				sPINstatus = "PIN for " & sPhase & " has been invalidated on " & CStr(Now())
				HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
				
				'[NumberOfRecords - Number of records when FD review was requested]
				HS.SetCellTextWithLabel "A#NumberOfRecords" & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
				HS.Clear				"A#NumberOfRecords" & sPhaseC4 & NONESxC4
		End If
	
		'Exit Sub
		'ErrorOccurred:
		'Call WriteToAllDebugLogs(">>> Error occurred")
	End Sub   'Invalidate_PIN
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
	Sub NoInputs_All()
		sActiveCodeBlock = "NoInputs_All"
		
		' VARIABLES & ARRAYS
		' ===========================================================================
			Dim sAccount, sEntity, sICP, sParent, sBusinessClass, sMovement, sDataAudit, sYear, iYear, sPeriod, sMember
			Dim sPOV, sMethod, iFromYear, bBlockInput, i
			Dim aTBaccounts, aList, aListToAppend, aDataAuditExGroupAdjs, aLedgerInputAccounts, aLedgerInputAccsAndValidations, aParams, aMembers
			Dim sUDA, sParamString, sParameterValue, sOverrideCurrency, sTargetPOV, sExpTargetPOV, aParamSections, sParamSection, iEqualSignPos, bExceptionalCase
			Dim bSkipSomeEntities, aEntitiesToSkip, sMemberList
			
			For iYear = CURRENTYEAR - 2 To CURRENTYEAR + 3
				If iYear >= FIRSTAPPYEAR And iYear <= LASTAPPYEAR Then
					Call AddToArray(aYearsToLoopInNoInput, iYear)
				End If
			Next
			Call AddToArray(aYearsToLoopInNoInput, 2025)
			
			
		' YEAR: Years outside the range specified
		' ===========================================================================
		' Block everything for the years that are outside the range of first year - last year specified for NoInput rules.
			For iYear = FIRSTAPPYEAR To LASTAPPYEAR
				If ExistsIn(aYearsToLoopInNoInput, iYear) Then
					'Inside the range, so leave it - will be blocked in the relevant year loops below
				Else
					'It is not in the range of years for no input loops - block everything for it
					'HS.NoInput "Y#" & iYear		'BY: Disabled for now, ENABLE LATER !!!
				End If
			Next
			
			
		' PERIOD: Applicable Months for Notes, CF, OFF TB & Validations
		' ===========================================================================
		' Block Note accounts for the periods that are not applicable to them but leave SOURCE_GL open for data loads, because some notes (e.g. B/S by currency are fed with data loaded monthly (at SBU level) but then enriched at LE level only half yearly
			
			
		' VALUE: Parent Currency and Consolidation Adjs
		' ===========================================================================
		' Block journal entries to Parent Currency and Consolidation Value Adjustments.
			HS.NoInput "V#<Parent Curr Adjs>"
			HS.NoInput "V#[Parent Adjs]"							'also blocked by metadata via AllowAdjsFromChildren:No
			HS.NoInput "V#[Contribution Adjs]"						'also blocked by metadata via AllowAdjsFromChildren:No
			
			
		' ENTITY: [None] entity
		' ===========================================================================
		' Block input to [None] entity for all accounts except [VL Validations], [FX FX Rates] and [SYS System Accounts]
			
		' ENTITY: Adjustment Entities - Input to TB Accounts
		' ===========================================================================
			
		' ENTITY: No Segment Entities (M000)
		' ===========================================================================
		' Block no segment SBU entities listed under [M000 No Segment] for P&L and Notes (sbu level notes)
			
			
		' ACCOUNT: Opening FX Rate
		' ===========================================================================
		' Leave [OPEFX Opening Rate for the year] open only for the first app year (2014), block for all the rest
			
		' ACCOUNT: Notes, CF, OFF TB and Comprehensive Income
		' ===========================================================================
		' Block ledger input accounts for the entities they are not going to be input in.
			
		' ACCOUNT: Plug Accounts
		' ===========================================================================
		' Block all plug accounts for everything other than group adjustments.
			
		' ACCOUNT: Suspense Accounts
		' ===========================================================================
		' Block suspense accounts for everything other than late adjustments.
			
		' ACCOUNT: Validation Accounts
		' ===========================================================================
		' Block validation accounts (for parameter input) for the entities they will not be calculated for.
			
		' ACCOUNT: Semi-Calculated Accounts
		' ===========================================================================
		' Accounts that have CALC: in their UDA - most of these accounts are marked IsCalculated:Y but some of them are calculated for only some of the custom members, so these should be blocked (e.g. AL11100 Net financial investments - CALC:(GLE2=FI11100+FI11800...))
			
		' ACCOUNT: System Accounts
		' ===========================================================================
		' Block unused system accounts to prevent usage by mistake
			For Each sAccount In HS.Account.List("", "[System]")
				Select Case UCase(sAccount)
				Case "[METHOD]", "[POWN]"
				Case Else
					HS.NoInput "A#" & sAccount
				End Select
			Next
			
			
		' ICP: [ICP None] for ICP Accounts
		' ===========================================================================
		' Block input/adj to [ICP None] for ICP accounts.
			
		' ICP: ICPs for P&L Reserves
		' ===========================================================================
		' [BB???? P&L Reserves] must be open to input/adj only at [ICP None] except for the [M73 Intercompany Dividends Paid] movement. Block ICPs for all other movements.
			
		' ICP: ICPs for Some Other ICP Accounts
		' ===========================================================================
		' The accounts marked as ICPNONE in UDA must be open to load/input only at [ICP None]. ICPs will be used in consol rules.
			
		' ICP: Parent Entities in ICP Dimension
		' ===========================================================================
		' Block parent entities that are marked IsIcp:Yes in ICP, hence are listed in the ICP dimension. Leave them open for system accounts (POWN etc.)
			For Each sICP In HS.ICP.List("[ICP Entities]", "[Base]")
				If HS.Entity.IsBase("", sICP) Then
					'It is a base entity, leave it open for input/adjs
				Else
					'Parent entity - block it, so it can't be selected as partner for input/adjs
					For Each sAccount In HS.Account.List("", "[Base]")
						If HS.Account.IsICP(sAccount) Then
							HS.NoInput "I#" & sICP & ".A#" & sAccount
						End If
					Next
				End If
			Next  'icp
			
			
		' C1: Currencies other than GBP
		' ===========================================================================
		' All FX rates must be input against GBP (C1:GBP, C2: other currencies) so block all other currencies in C1
			For Each sMember In HS.Custom("Custom1").List("", "[Currencies]")
				If IsNotEqual(sMember, "GBP") Then
					HS.NoInput "C1#" & sMember
				End If
			Next
			
			
		' C2: Net variation / Total Movement Input (M99)
		' ===========================================================================
		' Block [M99 Net variation] for input so that system enforces movement split.
			
		' C2: FX4 - Translation exchange differences - input
		' ===========================================================================
		' Block [FX4 Translation exchange differences - input] for everything other than cutover input in C4. it is used only to make CUTOVER_GBP_INPUT match CUTOVER_GBP_GL at <EC>.
			
		' C2: OB2 - Opening balance adjustment
		' ===========================================================================
		' Block [OB2 Opening balance adjustment] for data loads and input (<EC>).
		' Block [OB2 Opening balance adjustment] for all periods other than January. !!! If you change this then you need to change the validation applicability (UD3) as well. !!!
		' Block [OB2 Opening balance adjustment] for all entities other than SBUs.
		' Block [OB2 Opening balance adjustment] for all adjustment members other than LATE_ADJ.
			
			
		' C4: Input/Adjustment Values (EC/ECA)
		' ===========================================================================
		' Block adjustment only members for data input (EC: <entity currency>), because they should be used via journals only (ECA: <entity curr adjs>), and vice versa for input only members block ECA.
			
		' C4: Adjustments
		' ===========================================================================
		' [LATE_ADJ Late adjustments to GL (CODA) data] must be open only for the SBUs
		' [DIV_ADJ Divisional adjustments] must be open only for the base entities under [ZN0002 UK Divisional Adj] and [ZN0003 Europe Divisional Adj].
		' [GRP_ADJ Manual Group adjustments] must be open only for the base entities under [ZN0001 Group Adj]. 
			
		' C4: Historic Cost Input - Entity Check
		' ===========================================================================
		' Block historic cost input members (e.g. HIST_GBP) that are not needed. For each entity, the historic input currencies are listed in the UDA2 of the entity.
			
		' C4: Historic Cost Input - Account Check
		' ===========================================================================
		' Block historic cost input members (e.g. HIST_GBP) for the non-historic accounts.
			
		' Validation Parameters
		' ===========================================================================
		' Validation accounts are blocked based on their applicability (for periods, entities etc) in the Account sections above.
		' Block 'VALTOL - Tolerance (GBP)' for all entities other than [None] so that all tolerance parameters will have to be default, not entity specific
			For Each sEntity In HS.Entity.List("", "[Hierarchy]")
				If sEntity <> "[None]" Then
					'HS.NoInput "C4#C4_VALTOL???.E#" & sEntity
				End If
			Next  'sEntity
			
		' Block parameters at ECA
		' [VALTYP Type (999 for Soft, 888 for Inactive)], [VALTOL Tolerance (GBP)]
			'HS.NoInput "C4#C4_VALTYP" & sValueECA
			'HS.NoInput "C4#C4_VALTOL" & sValueECA
			
			
		' PARAMETRIC: Parametric No Input Rules
		' ===========================================================================
		' Members that have NOINPUT: in their UDA - the POV specified should be blocked for that member (e.g. A110000 Cash & Cash Equivalents ->  NOINPUT:M11). Currently available only for Scenario, Entity, Account and Custom dimensions.
			Dim sDimension, aDimensions, sDimensionRef, aListOfMembers, sMemberListDimension, sMemberListDimRef, sMemberInList
			aDimensions = Array("Account", "Custom1", "Custom2", "Custom3", "Custom4", "Custom5", "Entity", "Scenario")
			
			For Each sDimension In aDimensions
				Select Case UCase(sDimension)
					Case "ACCOUNT"  :	aMembers = HS.Account.List("", "[Base]")
					Case "ENTITY"   :	aMembers = HS.Entity.List("", "[Base]")
					Case "SCENARIO" :	aMembers = HS.Scenario.List("", "[Hierarchy]")
					Case Else	    :	aMembers = HS.Custom(sDimension).List("", "[Base]")
				End Select
				
				sDimensionRef = GetDimensionNameOrReference(sDimension)
				
				For Each sMember In aMembers
					'sUDA = HS.Account.UD1(sAccount)
					sUDA = GetUDA(sDimension, sMember, "ALL")
					If IsParameter(sUDA, "NOINPUT") Then
						'Prepare and split sections if there is more than one (delimited with comma)
						sParameterValue = GetParameterValue(sUDA, "NOINPUT")
						If sParameterValue = "" Then
							'NOINPUT parameter without a value - block this member for everything
							HS.NoInput sDimensionRef & "#" & sMember
							
						Else
							If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
								'Extra parentheses, remove them.
								sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
							End If
							
							aParamSections = Split(sParameterValue, ",")
							
							For Each sParamSection In aParamSections
								sParamSection = Trim(sParamSection)
								
								If BeginsWith(sParamSection, "{") And EndsWith(sParamSection, "}") Then
									'A member list in parameter value, get the list of members into an array
									aListOfMembers    = GetMemberList(sParamSection, sMemberListDimension)
									sMemberListDimRef = GetDimensionNameOrReference(sMemberListDimension)
									
									For Each sMemberInList In aListOfMembers
										sPOV = sDimensionRef & "#" & sMember & "." & sMemberListDimRef & "#" &  sMemberInList
										
										If InStr(sPOV, "Y#2036") Then			'UPDATE NEEDED: Remove this IF condition later.
											'Year 2036 doesn't exist in the old Dev apps, HFMDEVNEW and HFMDMDEV, don't block, otherwise rules are aborting in these apps.
										Else
											HS.NoInput sPOV
										End If
									Next  'member in the member list
									
								Else
									If Not BeginsWith(sParamSection, sMember) Then
										'The member itself is not included in the POV part. Let's add it to the beginning of it.
										sParamSection = sDimensionRef & "#" & sMember & "." & sParamSection
									End If
									
									sPOV = ConvertToPOV(sParamSection)
									
									If InStr(sPOV, "Y#2036") Then			'UPDATE NEEDED: Remove this IF condition later.
										'Year 2036 doesn't exist in the old Dev apps, HFMDEVNEW and HFMDMDEV, don't block, otherwise rules are aborting in these apps.
									Else
										HS.NoInput sPOV
									End If
								End If
							Next  'section in parameter value
						End If
					End If  'uda has noinput parameter
				Next  'member
			Next  'dimension
	End Sub   'NoInputs_All
	
	
	Sub Inputs_All()
		sActiveCodeBlock = "Inputs_All"
		
		' VARIABLES & ARRAYS
		' ===========================================================================
			Dim sAccount, sEntity, sBusinessClass, sMovement, sDataAudit, sPeriod, sMember, sUDA, sPOV
			Dim aLedgerInputAccounts, aTBAccounts, aListToAppend, sParamString, aParams, aParamSections, sParamSection, sParameterValue, sOverrideCurrency, aEnrichmentInputMembers, aMembers
			
		' ACCOUNT: Notes, CF, OFF TB and Comprehensive Income
		' ===========================================================================
			
			
		' C2: Enrichment for Movement Analysis
		' ===========================================================================
		' Unallocated movement totals loaded from GL need to be enriched (split to movements under [MVA Movement analysis]) at LE levels
			
			
		' C3: Validation Parameters
		' ===========================================================================
		' Enable input into validation parameters at the parent entity levels
			'HS.Input  "C4#C4_VALTYP"
			'HS.Input  "C4#C4_VALTOL"
			
			'[VALOFF Validations Off (888 to turn off)]
			'HS.Input  "A#VALOFF"
			
			
		' C4: Historic Cost Override Input
		' ===========================================================================
		' Enable historic cost input members (e.g. HIST_GBP) for the parent entities where the historic input currencies are listed in the UDA2.
			
		
		' PARAMETRIC: Parametric Input Rules
		' ===========================================================================
		' Members that have INPUT: in their UDA - the POV specified will be open for input for the specified parent entities (e.g. ABC001 ABC Limited ->  INPUT:C5_RECONDATA). Currently available only for Scenario, Entity, Account and Custom dimensions.
			Dim sDimension, aDimensions, sDimensionRef, aListOfMembers, sMemberListDimension, sMemberListDimRef, sMemberInList
			aDimensions = Array("Account", "Custom1", "Custom2", "Custom3", "Custom4", "Custom5", "Entity", "Scenario")
			
			For Each sDimension In aDimensions
				Select Case UCase(sDimension)
					Case "ACCOUNT"  :	aMembers = HS.Account.List("", "[Base]")
					Case "ENTITY"   :	aMembers = HS.Entity.List("", "E_ParentEntities")
					Case "SCENARIO" :	aMembers = HS.Scenario.List("", "[Hierarchy]")
					Case Else	    :	aMembers = HS.Custom(sDimension).List("", "[Base]")
				End Select
				
				sDimensionRef = GetDimensionNameOrReference(sDimension)
				
				For Each sMember In aMembers
					'sUDA = HS.Account.UD1(sAccount)
					sUDA = GetUDA(sDimension, sMember, "ALL")
					If IsParameter(sUDA, "INPUT") Then
						'Prepare and split sections if there is more than one (delimited with comma)
						sParameterValue = GetParameterValue(sUDA, "INPUT")
						If sParameterValue = "" Then
							'INPUT parameter without a value - open this member for input for all intersections (e.g. all entities etc. where applicable)
							HS.Input sDimensionRef & "#" & sMember
							
						Else
							If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
								'Extra parentheses, remove them.
								sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
							End If
							
							aParamSections = Split(sParameterValue, ",")
							
							For Each sParamSection In aParamSections
								sParamSection = Trim(sParamSection)
								
								If BeginsWith(sParamSection, "{") And EndsWith(sParamSection, "}") Then
									'A memberlist in parameter value, get the list of members into an array
									aListOfMembers    = GetMemberList(sParamSection, sMemberListDimension)
									sMemberListDimRef = GetDimensionNameOrReference(sMemberListDimension)
									
									For Each sMemberInList In aListOfMembers
										sPOV = sDimensionRef & "#" & sMember & "." & sMemberListDimRef & "#" &  sMemberInList
										
										HS.Input sPOV
									Next  'member in the member list
									
								Else
									If Not BeginsWith(sParamSection, sMember) Then
										'The member itself is not included in the POV part. Let's add it to the beginning of it.
										sParamSection = sDimensionRef & "#" & sMember & "." & sParamSection
									End If
									
									sPOV = ConvertToPOV(sParamSection)
									HS.Input sPOV
								End If
							Next  'section in parameter value
						End If
					End If  'uda has input parameter
				Next  'member
			Next  'dimension
	End Sub   'Inputs_All
	
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
	
	Sub ConsDefault(sSpecialCase)
		sActiveCodeBlock = "ConsDefault(" & sSpecialCase & ")"
		
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sPlugAcc, sTargetAcc, sTargetPOV, sTreatment, sElimC5, sSourceAccount, bContinuingOperation, bDiscontinuedOperation, sTargetC2
		
		bDiscontinuedOperation = IsEqual(sSpecialCase, "DISCONTINUED")
		bContinuingOperation   = Not bDiscontinuedOperation
		
		Set oDataUnit = HS.OpenDataUnit("")		'YTD by default
		nNumItems = oDataUnit.GetNumItems
		
		For i = 0 To nNumItems - 1
			'Get the next item from the data unit
			sAccount = oDataUnit.Item(i).Account
			sICP	 = oDataUnit.Item(i).ICP
			sC1		 = oDataUnit.Item(i).Custom("Custom1")
			sC2		 = oDataUnit.Item(i).Custom("Custom2")
			sC3		 = oDataUnit.Item(i).Custom("Custom3")
			sC4		 = oDataUnit.Item(i).Custom("Custom4")
			sC5		 = oDataUnit.Item(i).Custom("Custom5")
			dData	 = oDataUnit.Item(i).Data
				
				'Call WriteToDebugLog ("oDataUnit.Item(i).POV -> " & oDataUnit.Item(i).POV)
				
			sTreatment = ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
			
			If sTreatment = "processed" Then
				'This data has been processed/consolidated already or skipped (because of its pov or it's zero) - no need for further action
			Else
				
				Select Case UCase(sAccount)
					
				'----------------------------------
				'|  Investment Elimination / EER  |
				'----------------------------------
				Case "BB1641", "BB1647"
					'[BB1641 Investment in Subsidiaries], [BB1647 Impairment of Investment in Subsidiaries], [C1_9995 Equity Elimination Movement]
					
					'Proportionalize this account
					HS.Con "", dConsolidationPercentage, ""
					
					'UPDATE NEEDED: If it has minority? see statconsol rules
					
					'Eliminate all - at the first parent in entity hierarchy
					If bIsParentEntity Then
						'This can't be the first parent, must be the parent/ancestor of the parent of the base entity where this data originated. Don't eliminate, it must have been eliminated already (in C5_CONSCALC)
					Else
						'Find out which C5 member to post the elimination entries to
						sElimC5 = GetTargetElimC5(sAccount, sC5)
						
						If sElimC5 = "NOELIM" Then
							'Data in this C5 member shouldn't get eliminated - skip
						Else
							sPlugAcc = HS.Account.PlugAcct(sAccount)		'EER:[BB9991 Equity Elimination]
							
							'Reverse the entry at 100% - because no minority, at [C5_CONSCALC Calculated Consolidation Adjustments]
							HS.Con "V#[Elimination]" & sElimC5, dConsolidationPercentage * (-1), ""
							
							'Create the matching entry in the Plug account (i.e. create a balanced Debit / Credit entry)
							HS.Con "V#[Elimination]" & sElimC5 & ".A#" & sPlugAcc & ".C1#C1_9995" & ".C2#C2_" & sAccount, dConsolidationPercentage, ""
							
						End If
					End If
					
				'------------------------------------------
				'|  Equity Elimination (EER) and NCI (1)  |
				'------------------------------------------
				Case "BB9101", "BB9151", "BB9521"
					'[BB9101 Share Capital], [BB9151 Share Premium], [BB9521 Pre Acquisition Reserve], [C1_9995 Equity Elimination Movement]
					'??? -> [E330500 Pre-acquisition Retained Earnings], [E330262 Other Reserves - Capital Contribution]
					
					'Proportionalize this account @ ownership %
					HS.Con "", dOwnershipPercentage, ""
					
					'Proportionalize NCI account @ minority %
					If bHasMinority Then
						'[BB9801 Minority Interest], [C1_5022 Increase/Decrease in Minority Interest]
						HS.Con "A#BB9801.C1#C1_5022.C2#C2_" & sAccount, dMinorityPercentage, ""
					End If
					
					'Eliminate all - at the first parent in entity hierarchy
					If bIsParentEntity Then
						'This can't be the first parent, must be the parent/ancestor of the parent of the base entity where this data originated. Don't eliminate, it must have been eliminated already (in C5_CONSCALC)
					Else
						'Find out which C5 member to post the elimination entries to
						sElimC5 = GetTargetElimC5(sAccount, sC5)
						
						'Eliminate the owned amount at [C5_CONSCALC Calculated Consolidation Adjustments]
						If sElimC5 <> "NOELIM" Then
							sPlugAcc = HS.Account.PlugAcct(sAccount)		'EER:[BB9991 Equity Elimination]
							
							HS.Con "V#[Elimination]" & sElimC5, dOwnershipPercentage * (-1), ""
							
							'Create the matching entry in the Plug account (i.e. create a balanced Debit / Credit entry)
							HS.Con "V#[Elimination]" & sElimC5 & ".A#" & sPlugAcc & ".C1#C1_9995" & ".C2#C2_" & sAccount, dOwnershipPercentage, ""
						End If
					End If
					
				'----------------------------------------------
				'|  Profit/(Loss) for the Period and NCI (2)  |
				'----------------------------------------------
				Case "BB9511"
					'[BB9511 Profit and Loss Reserve]
					
					'Proportionalize this account @ ownership %
					HS.Con "", dOwnershipPercentage, ""					'UPDATE NEEDED: Change to 100% consol and eliminate the  minority share using [C1_5005 Minority Interest Elimination]
					
					'Proportionalize NCI accounts @ minority %
					If bHasMinority Then
						'B/S - [BB9801 Minority Interest], [C1_5023 Minority Interest Movements for the Period]
						HS.Con "A#BB9801.C1#C1_5023.C2#C2_" & sAccount, dMinorityPercentage, ""
						
						'P&L - [PB9300 Profit/(Loss) Attributable to MI], [C1_5020 Profit/(Loss) for the Period]
						If IsEqual(sC1, "C1_5020") Then
							'Multiply by -1 to change signage (because revenues positive, equity negative)
							HS.Con "A#PB9300" & NONESxC4C5, dMinorityPercentage * (-1), ""
						End If
					End If
					
				'---------------------
				'|  CTR and NCI (3)  |
				'---------------------
				Case CTR, "BB9362"
					'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [BB9362 - Foreign Currency Translation Reserves - Manual Adjustment], [BB9805 CTR on Minority Interest], FXTOT:[C1_M200 Foreign currency translation]
					
					'Proportionalize this account @ ownership %
					HS.Con "", dOwnershipPercentage, ""					'UPDATE NEEDED: Change to 100% consol and eliminate the  minority share using [C1_5005 Minority Interest Elimination]
					
					'Proportionalize CTR on NCI account @ minority %
					If bHasMinority Then
						'B/S - [BB9801 Minority Interest], [C1_5023 Minority Interest Movements for the Period]
						
						'If HS.Custom("Custom2").IsBase("C2_S1000", sC2) Then		'UPDATE NEEDED: commented out but this may be needed to restrict MI share to accounts under BS9000
						'	sSourceAccount = Mid(sC2, 4)
							
						'	If HS.Account.IsBase("BS9000", sSourceAccount) Then
						'		'FX from an Equity account that should contribute to CTR on NCI @ minority %
						
						If IsEqual(sAccount, CTR) Then
							sTargetC2 = ""   'same C2 member where the CTR data sits (source account for the calculated CTR)
						Else
							'CTR manual input (BB9362) doesn't use a source account analysis, so data is in C2#[None], BB9805 however has a C2 split. Write data to C2_BB9362
							sTargetC2 = ".C2#C2_" & sAccount
						End If
						
						If HS.Custom("Custom1").IsBase(FXTOT, sC1) Then
							'An FX movement - proportionalize the same movement @ minority %
							HS.Con "A#BB9805" & sTargetC2, dMinorityPercentage, ""
							
						Else
							'All other movements - proportionalize [C1_5015 Foreign Currency Translation] @ minority %		'UPDATE NEEDED: we may need to use a different movement (Ask Arun)
							HS.Con "A#BB9805.C1#C1_5015" & sTargetC2, dMinorityPercentage, ""
						End If
					End If
					
				Case Else
					
					'----------------------------------
					'|  Any Other Equity and NCI (4)  |
					'----------------------------------
					If HS.Account.IsBase("BS9000", sAccount) Then
						'Any other equity account under [BS9000 Equity Attributable to Owners of the Parent]
						
						'Proportionalize this account @ ownership %
						HS.Con "", dOwnershipPercentage, ""					'UPDATE NEEDED: Change to 100% consol and eliminate the  minority share using [C1_5005 Minority Interest Elimination]
						
						'Proportionalize NCI account @ minority %
						If bHasMinority Then
							'[BB9801 Minority Interest], [C1_5022 Increase/Decrease in Minority Interest]
							HS.Con "A#BB9801.C1#C1_5022.C2#C2_" & sAccount, dMinorityPercentage, ""
						End If
						
					ElseIf bContinuingOperation Then
						'------------------------------------------
						'|  Standard Consolidation & Elimination  |
						'------------------------------------------
							'Proportionalize this account
							HS.Con "", dConsolidationPercentage, ""
							
							'Eliminate this account at the first common parent entity
							Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
							
	'___________________________________________________________________________________________________________________________________________________________________________________________________
		
		'   ===============================
		'  |    DISCONTINUED OPERATIONS    |
		'   ===============================
						
					ElseIf bDiscontinuedOperation Then
						
						'Check if it is an account to be eliminated (not to be collapsed)
						If HS.Account.IsICP(sAccount) Then
							'Account is an ICP account
							sPlugAcc = HS.Account.PlugAcct(sAccount)
							If sPlugAcc <> "" Then
								'The ICP account has a plug account - will be eliminated at the right parent
								
								'------------------------------------------
								'|  Standard Consolidation & Elimination  |
								'------------------------------------------
								'Proportionalize this account
								HS.Con "", dConsolidationPercentage, ""
								
								'Eliminate this account at the first common parent entity
								Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
								sTreatment = "processed"
								
							ElseIf EndsWith(sAccount, "_Plug") Then
								'It is a plug account itself - consolidate it up here to avoid collapsing
								
								'Proportionalize this account
								HS.Con "", dConsolidationPercentage, ""
								sTreatment = "processed"
							End If
						End If
						
						If sTreatment = "processed" Then
							'This data has been consolidated or eliminated already - no need for further action
							
						Else
							'-------------------
							'|  Profit & Loss  |
							'-------------------
							'[PS9999 Retained Profit]
							If HS.Account.IsBase("PS9999", sAccount) Then
								'Collapse all P&L into [PB9100 Profit/(loss) for the year from discontinued Operations]
								HS.Con "A#PB9100" & NONESxC4C5, dConsolidationPercentage, ""
								
							'------------------
							'|  B/S - Assets  |
							'------------------
							'[BS1999 Non Current Assets], [BS2999 Current Assets]
							ElseIf HS.Account.IsBase("BS1999", sAccount) Or HS.Account.IsBase("BS2999", sAccount) Then
								'Collapse all assets into [BB2995 Assets of Disposal Group]
								HS.Con "A#BB2995" & NONESxC1C2C3C4C5, dConsolidationPercentage, ""
								
							'-----------------------
							'|  B/S - Liabilities  |
							'-----------------------
							'[BS3989 Current Labilities], [BS4999 Non Current Liabilities]
							ElseIf HS.Account.IsBase("BS3989", sAccount) Or HS.Account.IsBase("BS4999", sAccount) Then
								'Collapse all liabilities into [BB3398 Liabilities of Disposal GroUp Classified as Held for Sale]
								HS.Con "A#BB3398" & NONESxC1C2C3C4C5, dConsolidationPercentage, ""
								
							'------------------
							'|  B/S - Equity  |
							'------------------
							'Covered as part of the Default consolidation - see section above for 'Any Other Equity and NCI (4)'
								
							Else
							'--------------------
							'|  Other Accounts  |
							'--------------------
								'KP and SF accounts, validations etc - consolidate normally
								HS.Con "", dConsolidationPercentage, ""
							End If
						End If
					Else
						'There shouldn't be an Else Case (an entity is either continuing or discontinued)
						Call AbortRules("ELSE-CONSDEF", "I am in ELSE within the If/ElseIf/Else block in ConsDefault() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
					End If
				End Select  'account check
			End If  'standard treatment result check
		Next  'data
		
		Set oDataUnit = Nothing
	End Sub   'ConsDefault
	
	Sub ConsNCI()
		sActiveCodeBlock = "ConsNCI"
		
		'BY: Code to be written, or REMOVE IF NOT REQUIRED !!!
		' [C1_5023 Minority Interest Movements for the Period]	-> this movement for P&L movement
		' [C1_5022 Increase/Decrease in Minority Interest]		-> this movement for equity movements (Share Capital etc.), talk to Group Finance for a case of stepped acquisition
		
	End Sub   'ConsNCI
	
	Sub ConsHolding()
		sActiveCodeBlock = "ConsHolding"
		
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sPlugAcc, sTargetAcc, sTargetPOV, sTreatment, sElimC5
		
		Set oDataUnit = HS.OpenDataUnit("")		'YTD by default
		nNumItems = oDataUnit.GetNumItems
		
		For i = 0 To nNumItems - 1
			'Get the next item from the data unit
			sAccount = oDataUnit.Item(i).Account
			sICP	 = oDataUnit.Item(i).ICP
			sC1		 = oDataUnit.Item(i).Custom("Custom1")
			sC2		 = oDataUnit.Item(i).Custom("Custom2")
			sC3		 = oDataUnit.Item(i).Custom("Custom3")
			sC4		 = oDataUnit.Item(i).Custom("Custom4")
			sC5		 = oDataUnit.Item(i).Custom("Custom5")
			dData	 = oDataUnit.Item(i).Data
				
				'Call WriteToDebugLog ("oDataUnit.Item(i).POV -> " & oDataUnit.Item(i).POV)
				
			sTreatment = ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
			
			If sTreatment = "processed" Then
				'This data has been processed/consolidated already or skipped (because of its pov or it's zero) - no need for further action
			Else
				
				Select Case UCase(sAccount)
					
				'----------------------------------
				'|  Investment Elimination / EER  |
				'----------------------------------
				Case "BB1641", "BB1647"
					'[BB1641 Investment in Subsidiaries], [BB1647 Impairment of Investment in Subsidiaries], [C1_9995 Equity Elimination Movement]
					
					'Find out which C5 member to post the elimination entries to
					sElimC5 = GetTargetElimC5(sAccount, sC5)
					
					'Proportionalize this account
					HS.Con "", dConsolidationPercentage, ""
					
					'UPDATE NEEDED: If it has minority? see statconsol rules
					
					'Eliminate all - at the first parent in entity hierarchy
					If sElimC5 <> "NOELIM" Then
						sPlugAcc = HS.Account.PlugAcct(sAccount)		'EER:[BB9991 Equity Elimination]
						
						'Reverse the entry at 100% - because no minority, at [C5_CONSCALC Calculated Consolidation Adjustments]
						HS.Con "V#[Elimination]" & sElimC5, dConsolidationPercentage * (-1), ""
						
						'Create the matching entry in the Plug account (i.e. create a balanced Debit / Credit entry)
						HS.Con "V#[Elimination]" & sElimC5 & ".A#" & sPlugAcc & ".C1#C1_9995" & ".C2#C2_" & sAccount, dConsolidationPercentage, ""
					End If
					
				Case "BB9101", "BB9151", "BB9521"
					'[BB9101 Share Capital], [BB9151 Share Premium], [BB9521 Pre Acquisition Reserve]
					'??? -> [E330500 Pre-acquisition Retained Earnings], [E330262 Other Reserves - Capital Contribution]
					
					'Proportionalize this account
					HS.Con "", dConsolidationPercentage, ""
					
					'Don't eliminate. Holding company share capital, share premium etc. shouldn't get eliminated.
					
				Case Else
					
				'------------------------------------------
				'|  Standard Consolidation & Elimination  |
				'------------------------------------------
					'Proportionalize this account
					HS.Con "", dConsolidationPercentage, ""
					
					'Eliminate this account at the first common parent entity
					Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
					
				End Select  'account check
			End If  'standard treatment result check
		Next  'data
		
		Set oDataUnit = Nothing
	End Sub   'ConsHolding
	
	Sub ConsJVorAssociate()
		sActiveCodeBlock = "ConsJVorAssociate"
		
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sPlugAcc, sTargetAcc, sTargetPOV, sTreatment, sDataUnitPOV
		
		Set oDataUnit = HS.OpenDataUnit(sDataUnitPOV)		'YTD by default
		nNumItems = oDataUnit.GetNumItems
		
		For i = 0 To nNumItems - 1
			'Get the next item from the data unit
			sAccount = oDataUnit.Item(i).Account
			sICP	 = oDataUnit.Item(i).ICP
			sC1		 = oDataUnit.Item(i).Custom("Custom1")
			sC2		 = oDataUnit.Item(i).Custom("Custom2")
			sC3		 = oDataUnit.Item(i).Custom("Custom3")
			sC4		 = oDataUnit.Item(i).Custom("Custom4")
			sC5		 = oDataUnit.Item(i).Custom("Custom5")
			dData	 = oDataUnit.Item(i).Data
			
			sTreatment = ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
			
			If sTreatment = "processed" Then
				'This data has been processed/consolidated already or skipped (because of its pov or it's zero) - no need for further action
			Else
				Select Case UCase(sAccount)
					
				'-----------------------------------------
				'|  Share of Other Comprehensive Income  |
				'-----------------------------------------
				Case "BB9311"
					'[BB9311 Hedging Reserve - Gross], [C1_5006 Share of Joint Venture and Associates  - Hedge Reserves]
					'Consolidate all movements to C1_5006
					HS.Con "C1#C1_5006", dOwnershipPercentage, ""
					
					'Consolidate the same movement to the JV/Assoc asset account (double entry)
					'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
					If bIsMethodJV Then
						HS.Con "A#BB1678.C1#C1_5002", dOwnershipPercentage * (-1), ""
					ElseIf bIsMethodASSOCIATE Then
						HS.Con "A#BB1698.C1#C1_5002", dOwnershipPercentage * (-1), ""
					End If
					
				Case "BB9331"
					'[BB9331 Translation Reserves - NIH - Gross], [C1_5011 Share of Joint Venture and Associates  - Translation Reserves]
					'Consolidate all movements to C1_5011
					HS.Con "C1#C1_5011", dOwnershipPercentage, ""
					
					'Consolidate the same movement to the JV/Assoc asset account (double entry)
					'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
					If bIsMethodJV Then
						HS.Con "A#BB1678.C1#C1_5002", dOwnershipPercentage * (-1), ""
					ElseIf bIsMethodASSOCIATE Then
						HS.Con "A#BB1698.C1#C1_5002", dOwnershipPercentage * (-1), ""
					End If
					
				Case CTR, "BB9362"
					'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [BB9362 - Foreign Currency Translation Reserves - Manual Adjustment], [C1_5011 Share of Joint Venture and Associates  - Translation Reserves]
					Select Case UCase(sC2)
						Case "C2_BB9311", "C2_BB9361", "C2_BB9362", "C2_BB9511", "[NONE]"
							'[C2_BB9311 Source - Hedging Reserve - Gross], [C2_BB9361 Source - Foreign Currency Translation Reserves], [C2_BB9362 - Source - Foreign Currency Translation Reserves - Manual Adjustment], [C2_BB9511 Source - Profit and Loss Reserve]
							
							If IsEqual(sC2, "C2_BB9511") And IsEqual(sC1, "C1_5509") Then
								'[C1_5509 FX Historic to Closing - Data Migration Only] is used for [C1_9990 Data Migration] - skip, don't consolidate it up. This movement is used for data migration only and Arun requested it to be not consolidated for P&L reserves to be able to reconcile to Legacy HFM (GCS).
								
							Else
								'Consolidate all movements to C1_5011
								HS.Con "C1#C1_5011", dOwnershipPercentage, ""
								
								'Consolidate the same movement to the JV/Assoc asset account (double entry)
								'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
								If bIsMethodJV Then
									HS.Con "A#BB1678.C1#C1_5002.C2#[None]", dOwnershipPercentage * (-1), ""
								ElseIf bIsMethodASSOCIATE Then
									HS.Con "A#BB1698.C1#C1_5002.C2#[None]", dOwnershipPercentage * (-1), ""
								End If
							End If
						Case Else
							'FX in CTR from other source accounts (e.g. Share Capital) will not be consolidated.
					End Select
					
				'-------------------------------------------
				'|  Share of Profit/(Loss) for the Period  |
				'-------------------------------------------
				Case "BB9511"
					'[BB9511 Profit and Loss Reserve], [C1_5020 Profit/(Loss) for the Period], [C1_5007 Share of Joint Venture and Associates - Profit and Loss Reserves]
					If IsEqual(sC1, "C1_5027") Then
						'[C1_5027 Dividends] - skip, don't consolidate it up. This movement is made of Intercompany Dividends + Dividends to Shareholders
						
					ElseIf IsEqual(sC1, "C1_9990") Then
						'[C1_9990 Data Migration] - skip, don't consolidate it up. This movement is used for data migration only and Arun requested it to be not consolidated for P&L reserves.
						
					Else
						'Other movements of P&L Reserve - Consolidate to C1_5007
						HS.Con "C1#C1_5007", dOwnershipPercentage, ""
						
						'Consolidate the same movement to the JV asset account (double entry)
						'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5001 Share of Profit/(Loss) for the Period]
						If bIsMethodJV Then
							HS.Con "A#BB1678.C1#C1_5001", dOwnershipPercentage * (-1), ""
						ElseIf bIsMethodASSOCIATE Then
							HS.Con "A#BB1698.C1#C1_5001", dOwnershipPercentage * (-1), ""
						End If
					End If
					
				Case Else
					
				'-------------------
				'|  Profit & Loss  |
				'-------------------
					If HS.Account.IsBase("PS9900", sAccount) Then
						'An account under [PS9900 External Dividends] - skip, don't consolidate it up.		UPDATE NEEDED: This is a temporary solution for Data Migration, check if it should be a different rule after cutover
						
					ElseIf HS.Account.IsBase("PS9999", sAccount) Then
						'Any other P&L account (all others under [PS9999 Retained Profit])
						
						If bIsMethodJV Then
							'Proportionalize [PB7201 Share of Post Tax Profits/ (Losses) - Joint Ventures] at the ownership percentage
							HS.Con "A#PB7201" & NONESxC4C5, dOwnershipPercentage, ""
							
						ElseIf bIsMethodASSOCIATE Then
							'Proportionalize [PB7202 Share of Post Tax Profits/ (Losses) - Associates] at the ownership percentage
							HS.Con "A#PB7202" & NONESxC4C5, dOwnershipPercentage, ""
						End If
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(n100Percent)
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
					Else
						'Other accounts (Assets, Liabilities and Equity accounts, and also the memo accounts won't be consolidated.		'UPDATE NEEDED: Validations and validation lock accounts need to consolidate up.
						'Retained Earnings, Investment in Associates/Joint Ventures accounts will be calculated in Sub Calculate()
					End If
				End Select  'account check
				
				' '------------------------------------------
				' '|  Standard Consolidation & Elimination  |
				' '------------------------------------------
				' 'Proportionalize this account
				' HS.Con "", dConsolidationPercentage, ""
				
				' 'Eliminate this account at the first common parent entity
				' Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
				
			End If  'standard treatment result check
		Next  'data
		
		Set oDataUnit = Nothing
	End Sub   'ConsJVorAssociate
	
	Function ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
		'Standard treatment (checks etc.) for all methods are put into this func. so that this code doesn't need to be repeated in each method and whenever a new condition is added (a member to skip etc.) it will be added here, so will apply to all methods.
		Dim sTreatment, sUDA, sParamValue
		
		sTreatment = ""  'by default
		sDataWithPOV = "POV = A:" & sAccount & " I:" & sICP & " C1:" & sC1 & " C2:" & sC2 & " C3:" & sC3 & " C4:" & sC4 & " C5:" & sC5 & vbTab & vbTab & "DATA = " & dData
		
		' CHECK DATA & POV
		' ================
			If dData = 0 Then
				'zero values - not consolidated										'BY: If a validation result, Skip or not? UPDATE NEEDED !!!
				sTreatment = "skip"
				
			ElseIf Not HS.Account.IsConsolidated(sAccount) Then
				'Not a consolidated account - skip
				sTreatment = "skip"
				
			ElseIf IsEqual(sC1, OBLOAD) Then
				'OBLOAD:[C1_9997 Opening Balance Load] is loaded from GL for validation purposes and does not need to be consolidated - skip
				sTreatment = "skip"
				
			ElseIf IsEqual(sC1, CBLOAD) Then
				'CBLOAD:[C1_9999 Closing Balance Load] is loaded from GL for validation purposes and does not need to be consolidated - skip
				sTreatment = "skip"
				
			ElseIf IsEqual(sC1, OBCALC) Then
				'OBCALC:[C1_1000 Opening balance] doesn't need to be consolidated because it will be calculated again at [proportion] and [elimination] values - skip
				sTreatment = "skip"
				
				' If bIsActual And bIsFirstYearWithOpenings Then
					' 'First year with opening balances, opening balances consolidating up, let them consolidate up (20190302)
					' 'UPDATE NEEDED: should this be only for Actual scenario?
					' sTreatment = ""
				' End If
				
			ElseIf IsEqual(Right(sC5, 5), "_DIFF") Then
				'Member under [C5_FDSIGN_DIFF - FD Sign Off - Variances since FD Signed Off] - needed for a validation only, shouldn't be consolidated - skip
				sTreatment = "skip"
				
			End If
			
			' If sTreatment <> "skip" Then
				' 'UPDATE NEEDED: commented out some code below to check performance (20181212_BY)
					' sUDA = HS.Custom("Custom5").UD1(sC5)
					' 'sUDA = oCustom5_UDA_NOT_USED(sC5)
					' sParamValue = GetParameterValue(sUDA, "ISCONS")								'UPDATE NEEDED: COMMENTED OUT AS IT IS NOT USED. REMOVE LATER IF NOT NEEDED
					' ' sParamValue = GetParamValueFromArray_NOT_USED(sC5, sUDA, "ISCONS")
					
					' Select Case sParamValue
						' Case "", "Y"				: sTreatment = ""   'default treatment
						' Case "N"					: sTreatment = "skip"
						' Case "BASEENTITIES"			: sTreatment = bIsBaseEntity
						' Case "AGGREGATE", "100%"	: sTreatment = "consolidate %100"
						' Case Else
							' 'UPDATE NEEDED: This isn't making the rule abort - find a different way to throw an error (maybe hs.exp?)
							' Call AbortRules("UNKNOWN-ISCONS", "Unknown ISCONS parameter value (" & sParamValue & ") found for " & sC5)
					' End Select
					
				' 'UPDATE NEEDED: temporary solution below, to replace parametric solution commented out above
					' ' Select Case UCase(sC5)
						' ' Case "C5_GCS", "C5_GCS_ACT_RATE", "C5_GCS_BUD_RATE", "C5_GCS_GBP", "C5_GCS_PROP", "C5_GCS_ELIM"
							' ' sTreatment = "skip"
					' ' End Select
					
			' End If
			
		' PROCESS / RETURN RESULT
		' =======================
			Select Case sTreatment
				Case "skip"
					'This data and its pov is skipped - no need to consolidate
					ConsStandardTreatment = "processed"
					
				Case "consolidate %100"
					'Consolidate data at %100 - no elimination
					HS.Con "", n100Percent, ""
					ConsStandardTreatment = "processed"
					
				Case Else
					'Further checks will be done in the consolidation rules and the data will be treated there.
					ConsStandardTreatment = ""
			End Select
			
	End Function   'ConsStandardTreatment
	
	Sub Eliminate_ICP(sAccount, sICP, sC5, dEliminationPercentage, sElimPOV, sPlugElimPOV)
		sActiveCodeBlock = "Eliminate_ICP"
		
		'sElimPOV and sPlugElimPOV to be used only if the elimination needs to be posted to a different custom member etc. (e.g. ".C5#ELIM")
		Dim bCanEliminate, sPlugAcc, sAccountUDA, sUDA, sElimC5
		
		bCanEliminate = False   'by default
		sAccountUDA   = HS.Account.UD2(sAccount)
		
		'Check conditions for which the eliminations should run
		If IsParameter(sAccountUDA, "CUSTOMELIM") Then
			'Custom Elimination Rules will eliminate the data in this account - skip it
			
		ElseIf IsEqual(sICP, "[ICP None]") Then
			'Don't eliminate unless the account is tagged with 'ELIMICPNONE' parameter
			If IsParameter(sAccountUDA, "ELIMICPNONE") Then
				'Eliminate data in [ICP None] at the correct parent entity
				If IsParameter(sAccountUDA, "ELIMAT") Then
					If IsParameterValue(sAccountUDA, "ELIMAT", sPOVParent) Then
						bCanEliminate = True
						sPlugAcc = HS.Account.PlugAcct(sAccount)
					End If
				Else
					'No ELIMAT, so we don't know where in the hierarchy to eliminate - so eliminate at this level	-	UPDATE NEEDED: this may result in double counting, the rule may eliminate again and again at every parent
					bCanEliminate = True
				End If
			End If
			
		Else
			If HS.Account.IsICP(sAccount) Then
				'Account is an ICP account
				sPlugAcc = HS.Account.PlugAcct(sAccount)
				If sPlugAcc <> "" Then
					'The ICP account has a plug account
					If IsParameter(sAccountUDA, "ELIMAT") Then
						If IsParameterValue(sAccountUDA, "ELIMAT", sPOVParent) Then
							bCanEliminate = True
						End If
					Else
						If IsEqual(sICP, sPOVEntity) Then
							'ICP with itself (e.g. Share Capital) - eliminate
							bCanEliminate = True
						Else
							'Check if it is the first common parent
							If HS.Entity.IsDescendant(sPOVParent, sICP) Then
								'The ICP is a descendant of the current parent entity (i.e. we may have reached the first common parent)
								
								'Check if this is a parent further up in the hierarchy that is an ancestor of the 1st common parent (e.g. 2nd common parent, 3rd common parent etc.)
								If bIsBaseEntity Then
									'Current child entity is a base entity and its parent is also an ancestor of the ICP, so this is the first common parent - eliminate
									bCanEliminate = True
									
								ElseIf HS.Entity.IsDescendant(sPOVEntity, sICP) Then
									'The ICP is also a descendant of the current child entity, so this can't be the 1st common parent. It must have been eliminated already before reaching this point - do not eliminate
								Else
									'This is the first common parent - eliminate
									bCanEliminate = True
								End If
							End If
						End If
					End If
				End If
			End If
		End If
		
		If bCanEliminate Then
			If sPlugAcc = "" Then
				'No plug account - this is a defect. Make the HFM Rules abort with a message to the HFM Admin.
				Call AbortRules("MISSING-PLUG", "Missing Metadata Attribute - Plug Account is missing for " & sAccount)
			End If
			
			sElimC5 = GetTargetElimC5(sAccount, sC5)
			
			If sElimC5 = "NOELIM" Then
				'Data in this C5 member shouldn't get eliminated - skip
			Else
				'Reverse the entry in the source account but in the [Elimination] value member
				HS.Con "V#[Elimination]" & sElimPOV & sElimC5, dEliminationPercentage * (-1), ""
				
				'Create the matching entry in the Plug account in the [Elimination] value member (i.e. create a balanced Debit / Credit entry)
				HS.Con "V#[Elimination].A#" & sPlugAcc & sPlugElimPOV & sElimC5, dEliminationPercentage, ""
			End If
		End If
		
		bEliminated = bCanEliminate
	End Sub   'Eliminate_ICP
	
	Sub ConsParametricCalc_WIP()
		sActiveCodeBlock = "ConsParametricCalc"
		
		'Parametric Translation Rules using Parameters in Metadata (continued in CALCULATE sub-routine). This sub-routine must run last in the Translation Rules.
		
		Dim sDimension, aDimensions, sDimensionRef, aMembers, aListOfMembers, sMemberListDimension, sMemberListDimRef, sMemberInList, sMember, sUDA
		Dim sTargetValue, sFormula
		'aDimensions = Array("Account", "Custom1", "Custom2", "Custom3", "Custom4", "Custom5", "Entity", "Scenario")
		'aDimensions = Array("Account", "Custom1", "Custom5")
		aDimensions = Array("Custom5")
		
		For Each sDimension In aDimensions
			Select Case UCase(sDimension)
				Case "ACCOUNT" :	aMembers = HS.Account.List("", "[Base]")
				Case "ENTITY"  :	aMembers = HS.Entity.List("", "E_ParentEntities")
				Case "SCENARIO":	aMembers = HS.Scenario.List("", "[Hierarchy]")
				Case Else	   :	aMembers = HS.Custom(sDimension).List("", "[Base]")
			End Select
			
			sDimensionRef = GetDimensionNameOrReference(sDimension)
			
			For Each sMember In aMembers
				'sUDA = HS.Account.UD1(sAccount)
				sUDA = GetUDA(sDimension, sMember, "ALL")
				
				If IsParameterValue(sUDA, "ISCONS", "N") Then
					'No consolidation - clear what HFM consolidated (if any) -> UPDATE NEEDED: is this check needed? ConsStandardTreatment() is doing this check already
					HS.Clear sDimensionRef & "#" & sMember
				End If
				
				If IsParameter(sUDA, "CONSCALC") Then
					sFormula = GetParameterValue(sUDA, "CONSCALC")
					
					sTargetValue = Left(sFormula, 6)	'[Prop] or [Elim]
					
					'UPDATE NEEDED! - temporary solution below, hardcoded rules - need to make parametric
					'TEMP: C5_GCS_PROP, C5_GCS_BUD_RATE, C5_GCS_GBP	-> their UDA: CONSCALC: [Prop]=<EC>
					If IsEqual(sPOVValue, sTargetValue) Then
						HS.Exp sDimensionRef & "#" & sMember & " = " & sDimensionRef & "#" & sMember & sValueEC
					End If
					
					' 'Prepare and split sections if there is more than one (delimited with comma)
					' sParameterValue = GetParameterValue(sUDA, "INPUT")
					' If sParameterValue = "" Then
						' 'INPUT parameter without a value - open this member for input for all intersections (e.g. all entities etc. where applicable)
						' HS.Input sDimensionRef & "#" & sMember
						
					' Else
						' If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
							' 'Extra parentheses, remove them.
							' sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
						' End If
						
						' aParamSections = Split(sParameterValue, ",")
						
						' For Each sParamSection In aParamSections
							' sParamSection = Trim(sParamSection)
							
							' If BeginsWith(sParamSection, "{") And EndsWith(sParamSection, "}") Then
								' 'A member list in parameter value, get the list of members into an array
								' aListOfMembers    = GetMemberList(sParamSection, sMemberListDimension)
								' sMemberListDimRef = GetDimensionNameOrReference(sMemberListDimension)
								
								' For Each sMemberInList In aListOfMembers
									' sPOV = sDimensionRef & "#" & sMember & "." & sMemberListDimRef & "#" &  sMemberInList
									
									' HS.Input sPOV
								' Next  'member in the member list
								
							' ElseIf Not BeginsWith(sParamSection, sMember) Then			'UPDATE NEEDED: defect, currently no issues but if the member itself is included in the POV, this will not work.
								' 'The member itself is not included in the POV part. Let's add it to the beginning of it.
								' sParamSection = sDimensionRef & "#" & sMember & "." & sParamSection
								' sPOV = ConvertToPOV(sParamSection)
								
								' HS.Input sPOV
							' End If
						' Next  'section in parameter value
					' End If
				End If  'uda has input parameter
			Next  'member
		Next  'dimension
		
	End Sub   'ConsParametricCalc_WIP()
	
	
	Function GetTargetElimC5(sAccount, sC5)
		'This function returns which elimination member in C5 must be user for the Account x C5 combination the data is stored in. ELIM parameter on C5 member overrides the ELIM parameter on Account.
		
		Dim sUDA, sElimC5
		
		sUDA = HS.Custom("Custom5").UD1(sC5)
		sElimC5 = GetParameterValue(sUDA, "ELIM")
		
		Select Case sElimC5
			Case ""
				' 'Every base Custom 5 member must have an ELIM parameter. Make the HFM Rules abort with a message to the HFM Admin.
				' Call AbortRules("MISSING-ELIM", "Every base Custom 5 member must have an ELIM parameter. No parameter found for " & sC5)
				'UPDATE NEEDED: remove code commented out above  - we may need a control as a metadata validation
				
				'No ELIM parameter assigned to the C5 member. Use the ELIM parameter assigned to the account
				sUDA = HS.Account.UD1(sAccount)
				sElimC5 = GetParameterValue(sUDA, "ELIM")
				
				If sElimC5 = "" Then
					'No ELIM parameter on C5 member or Account. We don't know where to post the elimination. Make the HFM Rules abort with a message to the HFM Admin.
					Call AbortRules("MISSING-ELIM", "Elimination rules cannot find where to post the elimination values. ELIM parameter is missing on both account (" & sAccount & ") and custom 5 member (" & sC5 & ")")
				Else
					'Use the ELIM parameter assigned to the account
					sElimC5 = ".C5#" & sElimC5
				End If
				
			Case "SELF"
				'Eliminate at the C5 member itself
				sElimC5 = ".C5#" & sC5
				
			Case "NOELIM"
				'Don't eliminate data in this C5 member
				sElimC5 = "NOELIM"
				
			Case Else
				'Make it a POV string to concatenate with the elimination POV
				sElimC5 = ".C5#" & sElimC5
				
		End Select
		
		GetTargetElimC5 = sElimC5
	End Function   'GetTargetElimC5
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secC1 '   Section C1 - CALCULATE - Main subs and functions
		  ' ==========================================================================================================
	Sub ImpactCalcStatus()							'UPDATE NEEDED: Check for performance impact and improve if possible (perhaps a check if the status begins with 'OK')
		sActiveCodeBlock = "ImpactCalcStatus"
		
		If sApplication = "HFMDMDEV" Or sApplication = "HFMDMPPE" Then				'UPDATE NEEDED: remove this later.
			'Data Migration App - run a lighter version of Impact Rules to help with the performance of consolidations.
			Call ImpactCalcStatus_Temp_ForDM
			Exit Sub
		End If
		
		Dim i
		
		' [NONE] ENTITY
		' -------------
		If bIsNoneEntity And bValueIsNone Then
			If bIsActual Then
				' 'Impact Flash scenario for the same period of current year				'UPDATE NEEDED: REMOVE LATER if not required (Flash scenario translation)
				' HS.ImpactStatus "S#Flash"
				
				If bIsLastPeriod Then
					'Impact [Budget_Pre Budget Pre Actualisation] scenario for 2 years later so this years P12 rates will be used as the profit plan rate (P12 YTD average and P12 closing rates of 2 years ago)
					HS.ImpactStatus "S#Budget_Pre.Y#CUR+2.P#FIRST"
				End If
				
				' If IsEqual(sPOVEntity, "XXXX") Then				'UPDATE NEEDED: NOT NEEDED, REMOVE LATER (Alex from Group Finance confirmed)
					' 'Impact XXXX entity for 2 months later which uses the rates of 2 months ago in translation.			'UPDATE NEEDED: Replace XXXX with the correct entity
					' HS.ImpactStatus "E#XXXX.P#CUR+2"				'UPDATE NEEDED: Check if this is working when the period extends past the current year
				' End If
			End If
		End If
		
		' ALL ENTITIES (including [None])
		' -------------------------------
		If bValueIsECorECA Or bIsNoneEntity Then
			If bIsActual Then
				'Impact Actual Next Year
				If bIsLastPeriod Then
					'P12 - Impact Actual next year
					HS.ImpactStatus "Y#NEXT.P#FIRST"
					
					'Impact [Budget Budget Post Actualisation] next year
					HS.ImpactStatus "Y#NEXT.P#FIRST.S#Budget"
					
					If bValueIsECA Then
						'Impact <EC> next year as well, so the updated <ECT> closing balance can be pulled into <EC> opening balance next year.
						HS.ImpactStatus "Y#NEXT.P#FIRST" & sValueEC
						HS.ImpactStatus "Y#NEXT.P#FIRST.S#Budget" & sValueEC
					End If
				Else
					'P1 to P11 - Impact current forecast
					'Impact Forecast - only the forecast scenario for the current period, following forecast scenarios of this year will be impacted when calculation runs for the current forecast scenario.
					HS.ImpactStatus "S#Forecast_P" & iPOVPeriodNum
					
						'COMMENTED OUT, REMOVE LATER
							' 'Impact the Forecast scenarios for the Actual part & the same period of current year
							' For i = iPOVPeriodNum To 11
								' HS.ImpactStatus "S#Forecast_P" & i
							' Next  'period
						'COMMENTED OUT, REMOVE LATER
				End If
				
			ElseIf bIsForecastActualPeriod Then
				'Actual period of a forecast scenario (e.g. P1,P2 or P3 for Forecast_P3), impact the next forecast only (if there is a next forecast, i.e. doesn't apply to Forecast_P11)
				If sNextForecast <> "" Then
					HS.ImpactStatus "S#" & sNextForecast
				End If
				
			ElseIf bIsForecast7plus5 Then			'UPDATE NEEDED: this should be made parametric so that they can pull closing balances from a different Forecast scenario into Budget Opening B. if they need to
				'Impact [Budget_Pre Budget Pre Actualisation] scenario next year (Budget opening balances are pulled from Forecast_P7 scenario by default).
				If bIsLastPeriod Then
					HS.ImpactStatus "S#Budget_Pre.Y#NEXT.P#FIRST"
					
					If bValueIsECA Then
						'Impact <EC> next year as well, so the updated <ECT> closing balance can be pulled into <EC> opening balance next year.
						HS.ImpactStatus "S#Budget_Pre.Y#NEXT.P#FIRST" & sValueEC
					End If
				End If
			End If
			
		ElseIf bValueIsTrans Then
			If bIsActual And bIsLastPeriod Then
				'Impact <EC> next year because historic opening rates may have changed and need to be carried forward into <EC> next year (part of CalcFXRates() routine).
				HS.ImpactStatus "Y#NEXT.P#FIRST" & sValueEC
			End If
			
		ElseIf bValueIsProportion Then
			If bIsActual And bIsLastPeriod Then		HS.ImpactStatus "Y#NEXT.P#FIRST"		'UPDATE NEEDED: do we need these impact rules? if an alternate entity hierarchy is added, we may need. If kept, they should be updated in line with above.
			
		ElseIf bValueIsElimination Then
			If bIsActual And bIsLastPeriod Then		HS.ImpactStatus "Y#NEXT.P#FIRST"		'UPDATE NEEDED: do we need these impact rules? if an alternate entity hierarchy is added, we may need. If kept, they should be updated in line with above.
			
		End If
	End Sub   'ImpactCalcStatus
	
	Sub CopyDataFromAnotherSubCube()
		sActiveCodeBlock = "CopyDataFromAnotherSubCube"
		
		If bIsForecastActualPeriod Then
			'Copy data from Actual, it is applicable to current forecast scenario and period
			HS.Clear "A#ALL"
			HS.Exp "A#ALL = A#ALL.S#Actual" & sValueECT
		End If
	End Sub   'CopyDataFromAnotherSubCube
	
	Sub CopyDataForReTranslation()
		sActiveCodeBlock = "CopyDataForReTranslation"
		
		Select Case sApplication_Environment											'UPDATE NEEDED: REMOVE LATER
		Case "HFMDMDEV_DEV", "HFMDMPPE_PPE"			', "GROUPHFM_SIT", "GROUPHFM_PPE"
			'Skip it for now in these applications, alternate rate translations are taking extra time.
			Exit Sub	'UPDATE NEEDED: enable again once performance improvement is in place.
		End Select
		
		Dim sUDA, sReTransGroup, sReTransMember, aReTransMembers, sApplicability, sExceptions, sSourceC5, sSourceScenario, aAccountGroups, sAccountGroup, sAccountParent, sAccount
		sSourceScenario = ""   'must be in ".S#SCENARIO" format
		
		'[C5_TRANS Translations at Reporting Rates]
		For Each sReTransGroup In HS.Custom("Custom5").List("C5_TRANS", "[Children]")
			sUDA = HS.Custom("Custom5").UD3(sReTransGroup)
			sApplicability = GetParameterValue(sUDA, "AppliesTo")
			sExceptions    = GetParameterValue(sUDA, "NotAppliesTo")
			
			If IsApplicableToPOV(sApplicability, sExceptions, "Scenario") Then
				sUDA = HS.Custom("Custom5").UD1(sReTransGroup)
				aAccountGroups = Split(GetParameterValue(sUDA, "ACCS"), ",")
				
				If HS.Custom("Custom5").IsBase("", sReTransGroup) Then
					'Not a hierarhcy but a single member
					aReTransMembers = Array(sReTransGroup)
				Else
					aReTransMembers = HS.Custom("Custom5").List(sReTransGroup, "[Base]")
				End If
				
				For Each sReTransMember In aReTransMembers
					sUDA = HS.Custom("Custom5").UD1(sReTransMember)
					sSourceC5 = GetParameterValue(sUDA, "DATA")
																				'Call SetDebuggingTemporarilyON		'remove later
					If sSourceC5 = "" Then
						'No source C5 member speficied, it will be populated with data later (e.g. eliminations) - skip
					Else
						For Each sAccountGroup In aAccountGroups
							Select Case sAccountGroup
								Case "PL"	  :  sAccountParent = "PM9999"	'[PM9999 Retained Profit]
								Case "BS"	  :  sAccountParent = "TSTBS"	'[TSTBS Balance Sheet]
								Case "CF"	  :  sAccountParent = "CS9999"	'[CS9999 Cash and Cash Equivalents at End of Period]
								'Case "FLASH"  :  sAccountParent = "FLASH"	'[FLASH Flash Reporting]			'UPDATE NEEDED: REMOVE LATER if not required (Flash scenario translation)
							End Select
							
							For Each sAccount In HS.Account.List(sAccountParent, "[Base]")
								HS.Clear "A#" & sAccount & ".C5#" & sReTransMember		'BY: shouldn't be needed because calculated member, REMOVE? !!!
								HS.Exp   "A#" & sAccount & ".C5#" & sReTransMember & " = A#" & sAccount & ".C5#" & sSourceC5 & sSourceScenario & sValueECT
								'If sAccount = "BB2851" Then HS_Exp   "A#" & sAccount & ".C5#" & sReTransMember & " = A#" & sAccount & ".C5#" & sSourceC5 & sSourceScenario & sValueECT
							Next  'base account
						Next  'account group
					End If
				Next  're-translation member (base)
			Else
				'Clear the data that may have been pulled from another sub-cube (e.g. opening balances)
				'HS.Clear "C5#" & sReTransMember		'UPDATE NEEDED: remove if not needed - if enabled, should be fixed because currently clearing GL_LOAD
			End If
		Next  're-translation group
		
		' 'ADDED for DEBUGGING - commented out - REMOVE LATER !!!
			' Dim dTemp
			' dTemp = HS_GetCell("A#BB1001.C1#C1_1000.C5#C5_TOTAL" & TOPSxC1C5 & sValueECT)
			' HS_Exp "A#BB1001.C1#C1_1000.C5#C5_TOTAL_BUD_RATE = A#BB1001.C1#C1_1000.C5#C5_TOTAL" & sValueECT
		
	End Sub   'CopyDataForReTranslation
	
	Sub ClearPreviousCalculationResults()
		sActiveCodeBlock = "ClearPreviousCalculationResults"
		
		'The cells at the intersection of accounts and custom members that are marked as isCalculated: Y are automatically cleared by HFM. However we have seen some cases (e.g. VALREF numbers) where the previously calculated numbers were not cleared and left in the cells. so this sub is clearing those as well.
		
		'BY: Code to be written, or REMOVE IF NOT REQUIRED !!!
	End Sub   'ClearPreviousCalculationResults
	
	Sub ClearCellText(sCellTextLabel)
		sActiveCodeBlock = "ClearCellText"
		
		'BY: Code to be written, or REMOVE IF NOT REQUIRED !!!
		
	End Sub   'ClearCellText
	
	Sub CalcOpeningBalances(sWhichAccounts)
		sActiveCodeBlock = "CalcOpeningBalances"
		
		Dim sSourceScenario, sSourcePeriod, sSourceValue, sSourceBalance, sSourceBalanceNonFinancial, sDataSource, sAccount
			''Call WriteToDebugLog("CalcOpeningBalances for" & sPUPOVshort)
		
		' SOURCE SCENARIO
		' ===============
		If bIsForecastActualPeriod Then
			'Actual part of a forecast scenario - CopyDataFromAnotherSubCube() is already copying the whole data including the opening balances from Actual - no need to recalculate the opening balances for this period/scenario.
			Exit Sub
			
		ElseIf bIsForecastForecastPeriod Then
			'Forecast part of a forecast scenario - copy opening balances from P1
			sSourceScenario = ""
			
		ElseIf IsEqual(sPOVScenario, "Budget_Pre") And bIsFirstPeriod Then
			'Pull the closing balances from [Forecast_P7 Forecast 7+5] into [Budget_Pre Budget Pre Actualisation] openings.
			sSourceScenario = ".S#Forecast_P7"			'UPDATE NEEDED: pull from parameter instead (CellText or if no text then Default in UDA)
			
		ElseIf IsEqual(sPOVScenario, "Budget") And bIsFirstPeriod Then
			'Pull the closing balances from Actual into [Budget Budget Post Actualisation] openings.
			sSourceScenario = ".S#Actual"
		Else
			sSourceScenario = ""
		End If
		
		' SOURCE VALUE, PERIOD and MOVEMENT
		' =================================
		'CBTOT:[C1_T000 Closing Balance], OBCALC:[C1_1000 Opening balance]
		If bIsFirstYear Then
			'No prior year to pull the rates from - skip
			Exit Sub
			
		' ElseIf bIsActual And bIsFirstYearWithOpenings And (bValueIsElimination Or bValueIsProportion) Then				'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
			' 'First year with opening balances, opening balances consolidating up, let them consolidate up - do not overwrite (20190302)
			' 'UPDATE NEEDED: should this be only for Actual scenario?
			' Exit Sub
			
		ElseIf bIsFirstPeriod Then
			sSourcePeriod  = ".Y#PRIOR.P#LAST"
			sSourceBalance = CBTOT
			sSourceBalanceNonFinancial = "C1_P100"		'[C1_P100 - Store - Closing Balance]		'Potential UPDATE NEEDED: it may be better to use C1_TOP to make it generic for all non financial movement analysis
			
			If bValueIsEC Then
				sSourceValue = sValueECT
			Else
				sSourceValue = ""
			End If
		Else
			sSourcePeriod  = ".P#FIRST"
			sSourceBalance = OBCALC
			sSourceBalanceNonFinancial = "C1_6059"		'[C1_6059 - Store - Opening Balance]		'Potential UPDATE NEEDED: it may be good to make this future proof (by using a generic opening balance member)
			sSourceValue   = ""
		End If
		
		' COPY BALANCES
		' =============
		Select Case UCase(sWhichAccounts)
			Case "ALL", ""
				'BY: UPDATE NEEDED for Custom 5 !!!  we may need to put a for loop to exclude trans members (For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]"))
				HS.Clear "C1#" & OBCALC					'[C1_6059 - Store - Opening Balance]
				HS.Exp   "C1#" & OBCALC & " = C1#" & sSourceBalance & sSourceScenario & sSourcePeriod & sSourceValue
				
				'Calculate Non-Financial Opening Balance
				HS.Clear "C1#C1_6059"
				HS.Exp   "C1#C1_6059 = C1#" & sSourceBalanceNonFinancial & sSourceScenario & sSourcePeriod & sSourceValue
				
			Case "CTR"
				'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [BB9805 CTR on Minority Interest]
				'BY: UPDATE NEEDED for Custom 5 !!!
				For Each sDataSource In HS.Custom("Custom5").List("C5_TOTAL", "[Base]")
					For Each sAccount In Array(CTR, "BB9805")
						HS.Clear "A#" & sAccount & ".C1#" & OBCALC & ".C5#" & sDataSource
						HS.Exp   "A#" & sAccount & ".C1#" & OBCALC & ".C5#" & sDataSource & " = A#" & sAccount & ".C1#" & sSourceBalance & ".C5#" & sDataSource & sSourceScenario & sSourcePeriod
					Next  'calculated CTR account
				Next  'C5 member
		End Select
	End Sub   'CalcOpeningBalances
	
	Sub CalcMovements()
		sActiveCodeBlock = "CalcMovements"
		Dim sSourceBalance
		
		'Balance sheet calculated movement
		'MVCALC:[C1_9998 Movement Calculated]
		'CBLOAD:[C1_9999 Closing Balance Load]
		'OBTOT: [C1_M000 Opening balance Total]
		'MVATOT:[C1_M110 Movement Analysis]
		'FXTOT: [C1_M200 Foreign currency translation]
		'[C5_GLLOAD GL Load]
		
		'UPDATE NEEDED: what about [C1_M150 Movement Analysis for Notes]? it shouldn't be used for B/S but what if used?
		'UPDATE NEEDED: MVCALC will be zero for most B/S accounts, so a lot of zeros at <EC> and <PC> level. it may be good to clear these zeros.
		HS.Clear "C1#" & MVCALC & ".C5#C5_GLLOAD"
		HS.Exp "C1#" & MVCALC & ".C5#C5_GLLOAD = C1#" & CBLOAD & ".C5#C5_GLLOAD - C1#" & OBTOT & ".C5#C5_GLLOAD - C1#" & MVATOT & ".C5#C5_GLLOAD - C1#" & FXTOT & ".C5#C5_GLLOAD"			
		
		If bBeforeCutover Then   Call CalcDataMigrationRelated("Calculate MVCALC for Adjustments")
		
	End Sub   'CalcMovements
	
	Sub CalcRetainedEarningsAndNCI()
		sActiveCodeBlock = "CalcRetainedEarningsAndNCI"
		
		' Profit and Loss Reserve
		'--------------------------
		'[BB9511 Profit and Loss Reserve], [C1_5020 Profit/(Loss) for the Period], [PS9500 Profit/Loss) Attributable to Shareholders], [C1_5027 Dividends], [PS9810 Intercompany Dividends], [PB9911 Dividends to Shareholders]
		'Reverse the signage when pulling from P&L because as per FDD Revenue will be positive and Equity will be negative.
			'FORMULA for BB9511: C1_5020 = - PS9500, C1_5027= - (PS9810 + PB9911)
			HS.Exp "A#BB9511.C1#C1_5020" & NONESxC1C4C5 & " = - A#PS9500" & TOPSxC4C5	
			HS.Exp "A#BB9511.C1#C1_5027" & NONESxC1C4C5 & " = - (A#PS9810" & TOPSxC4C5 & " + A#PB9911" & TOPSxC4C5 & ")"
			
		' Minority Interest
		'-------------------
		'[BB9801 Minority Interest], [C1_5028 Dividends - MI], [PB9915 Dividends to MI], [C2_PB9915 Source - Dividends to MI]
		'Reverse the signage when pulling from P&L because as per FDD Revenue will be positive and Equity will be negative.
			'FORMULA for BB9801: C1_5028.C2_PB9915 = - PB9915
			HS.Exp "A#BB9801.C1#C1_5028.C2#C2_PB9915" & NONESxC1C2C4C5 & " = - A#PB9915" & TOPSxC4C5
		
	End Sub   'CalcRetainedEarningsAndNCI
	
	Sub CalcCashFlow(sSourceValue)
		sActiveCodeBlock = "CalcCashFlow"
		
		Select Case sApplication_Environment
		Case "HFMDMDEV_DEV", "HFMDMPPE_PPE", "ERPDRMDEV_DEV"		', "GROUPHFM_PPE"				'UPDATE NEEDED: REMOVE LATER
			'Skip it for now in these applications, parametric calculations are taking too long to process
			Exit Sub	'UPDATE NEEDED: enable again once performance improvement is in place.
		End Select
		
		Dim sParameterValue, sExpSourcePOV, sExpTargetPOV, sAccount, sC4, sApplicability
		
		' Parametric Calculations
		' -----------------------
		' The formula is provided in the UDA1 as a parameter using the CALC keyword (e.g. CALC:BB9511.C1_M100). [CF1000T CASH FLOW]
			'sApplicability = HS.Account.UD3("CF1100T")
		
		
		' The formula is for calculating Cash flow at [Proportion] level	
			'.C5#C5_MANINP is temp and needs to be re-worked using Parametric calc
		
		HS.Clear "A#CB9900.C5#C5_MANINP" ' Iscalc = NO
		HS.Clear "A#CB4120.C5#C5_MANINP" ' this needs to be cleared for Tesco_Bank
		
		
		
		'PS8400 Profit/(Loss) Before Tax
			HS.Exp "A#CB1010_01.C5#C5_MANINP" & NONESxC4C5 & " = A#PS8400" & TOPSxC4
		'PS7000 - Share of Post Tax Profits/(Losses) of Joint Venture and Associates
			HS.EXP "A#CB1030_01.C5#C5_MANINP" & NONESxC4C5 & " = - A#PS7000" & TOPSxC4
		'BS2850 - Share of Post Tax Profits/(Losses) of Joint Venture and Associates
			HS.EXP "A#CB9910_01.C5#C5_MANINP" & NONESxC4C5 & " = A#BS2850.C1#C1_M200" & TOPSxC1C4
		'BS2850 - Share of Post Tax Profits/(Losses) of Joint Venture and Associates - Opening Balance
			HS.EXP "A#CB9900.C5#C5_MANINP" & NONESxC4C5 & " = A#BS2850.C1#C1_1000" & TOPSxC1C4
		
	End Sub   'CalcCashFlow
	
	Sub CalcParametric(sSourceValue)
		sActiveCodeBlock = "CalcParametric"
		
		Dim sParameterValue, sSourcePOV, sExpSourcePOV, sTargetPOV, sExpTargetPOV, sExpTargetPOVforDifference, sAccount, dBalance, dInputData, aParamSections, sParamSection
		Dim iEqualSignPos, sYear, aParametricCalcAccs, sApplicability, sExceptions, sUDA, sUDA3, bApplicableToPOV
		
		Select Case sApplication_Environment
		Case "HFMDMDEV_DEV", "HFMDMPPE_PPE", "ERPDRMDEV_DEV"		', "GROUPHFM_PPE"				'UPDATE NEEDED: REMOVE LATER
			'Skip it for now in these applications, parametric calculations are taking too long to process
			Exit Sub	'UPDATE NEEDED: enable again once performance improvement is in place.
		End Select
		
		' ---------------------------
		' | Parametric Calculations |
		' ---------------------------
		' The formula is provided in the UDA1 as a parameter using the CALC keyword (e.g. CALC:PS9999))
		aParametricCalcAccs = HS.Account.List("", "A_ParametricCalcAccs")
		
		If IsArray(aParametricCalcAccs) Then
			For Each sAccount In aParametricCalcAccs
				sUDA			= HS.Account.UD1(sAccount)
				' sApplicability	= HS.Account.UD3(sAccount)													'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed
				
				' If IsParameter(sUDA, "RECALCOFF") Then														'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed
					' 'Calculate at the applicable entity and at <EC> only										'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed
					' bApplicableToPOV = bValueIsEC And IsApplicableToPOV(sApplicability, "period, entity")		'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed, sExceptions need to be added if renabled
				' Else																							'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed
					' bApplicableToPOV = IsApplicableToPOV(sApplicability, "period, entity & hierarchy")		'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed, sExceptions need to be added if renabled
				' End If																						'COMMENTED OUT and REPLACED with code below. UPDATE NEEDED: remove if not needed
				
				sUDA3 = HS.Account.UD3(sAccount)
				sApplicability = GetParameterValue(sUDA3, "AppliesTo")
				sExceptions    = GetParameterValue(sUDA3, "NotAppliesTo")
				bApplicableToPOV = IsApplicableToPOV(sApplicability, sExceptions, "ALL")
				
				If bApplicableToPOV Then
					sParameterValue = GetParameterValue(sUDA, "CALC")
					If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
						'Extra parentheses, remove them.
						sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
					End If
					
					aParamSections = Split(sParameterValue, ",")
					
					For Each sParamSection In aParamSections
						iEqualSignPos = InStr(sParamSection, "=")
						If iEqualSignPos > 0 Then
							'There is custom member(s) specified as the target POV on the left side of the =
							sTargetPOV = Left(sParamSection, iEqualSignPos - 1)
							sSourcePOV = Mid(sParamSection, iEqualSignPos + 1)
							
							If Not BeginsWith(sTargetPOV, sAccount) Then
								'The account itself is not included in the target POV part. Let's add it to the beginning of it.
								sTargetPOV = sAccount & "." & sTargetPOV
								'sTargetPOV = "A#" & sAccount & "." & sTargetPOV		'BY: TRY THIS !!! it may help with performance a little bit
							End If
						Else
							'Whole parameter section is for source pov - target is the account itself (for all its valid custom members)
							sTargetPOV = sAccount
							'sTargetPOV = "A#" & sAccount		'BY: TRY THIS !!! it may help with performance a little bit
							sSourcePOV = sParamSection
						End If
						
						'Target POV Expression
						'Syntax: ConvertToExpression(sFormula, sTargetAcc, sDefaultMembers, sDefaultMemberExceptions, sWhichDimensions, sPOVPartToAdd)
						'sExpTargetPOV = ConvertToExpression(sTargetPOV, sAccount, "NONES FOR UNUSED DIMENSIONS", "C5#C5_GLLOAD", "ALL", "")	'BY: UPDATE NEEDED !!! - do we write to GLLOAD or MANINP?
						sExpTargetPOV = ConvertToExpression(sTargetPOV, sAccount, "NONES FOR UNUSED DIMENSIONS", "C5#C5_MANINP", "ALL", "")
						
						'Source POV Expression
						sExpSourcePOV = ConvertToExpression(sSourcePOV, sAccount, "TOPS EXCLUDING SAME ANALYSIS", "C5#C5_TOP", "ALL", sSourceValue)
						
						'Clear previous calculation result first because HFM doesn't clear unless you consolidate all with data
						HS.Clear sExpTargetPOV
						HS.Exp sExpTargetPOV & " = " & sExpSourcePOV
					Next  'section in parameter value
				End If  'account is applicable to the pov
			Next  'account
		End If
	End Sub   'CalcParametric
	
	Sub CalcOther()
		sActiveCodeBlock = "CalcOther"
		
		'Any other calculations can be placed into this sub-routine. Ideally they should be converted to parametric calculations and covered in CalcParametric().
		
		'[C5_EXCEPT Exceptional Items], [C5_EXCDED Exceptional Items (-) / Exceptional Items Deducted]
		HS.Exp "C5#C5_EXCDED = - C5#C5_EXCEPT"			'UPDATE NEEDED: convert this to parametric calc
		
	End Sub   'CalcOther
	
	Sub CalcRecurringBalances()
		sActiveCodeBlock = "CalcRecurringBalances"
		
		' Default Type and Tolerance
		' --------------------------
			If bIsNoneEntity And bIsFirstPeriod Then
				If Not bIsFirstYear Then
					'Carry the data in balance recurring account into the first period
					'UPDATE NEEDED: we may need to do a check first if there is any data input/loaded before pulling data from prior year-end into Jan.
					'HS.Exp "A#DEFTYP = A#DEFTYP.Y#PRIOR.P#LAST"			'UPDATE NEEDED: REMOVE IF NOT NEEDED
					HS.Exp "A#DEFTOL = A#DEFTOL.Y#PRIOR.P#LAST"
				End If
			End If
		
	End Sub   'CalcRecurringBalances
	
	
dim secC2 '   Section C2 - CALCULATE - Validations
		  ' ==========================================================================================================
	Sub CalcValidations()
		sActiveCodeBlock = "CalcValidations"
		
		Dim nDefaultTolerance  'Default tolerances for validations
		Dim sValAcc, sApplicability, sExceptions, sPOVPartToAdd, sUDA
		
		' Check if the validations are OFF
		'-----------------------------------------------
		'VALOFF: Validations Off (888 to turn off)
		If GetValidationParameter("VALOFF", "VALTYP") = 888 Then
			'all validations are off, do not proceed
			HS.Clear "A#" & sValAcc & ".C4#C4_VALRAC"			
			HS.Clear "A#" & sValAcc & ".C4#C4_VALREF1"
			HS.Clear "A#" & sValAcc & ".C4#C4_VALREF2"
			Exit Sub
		End If
		
		' Get the currency rate
		'-----------------------------------------------
		'We will translate the tolerances (entered in GBP) to the POV currency. Let's get the rate.
		nGBPClosingRate = HS.GetRate("V#GBP.A#" & CLOSINGRATE)
		If Not nGBPClosingRate > 0 Then
			'Must be GBP or no rate defined - use rate of 1
			nGBPClosingRate = 1
		End If
		
		' Get the default tolerance (from None entity)
		'-----------------------------------------------
		nDefaultTolerance = HS.GetCell("E#[None].V#[None].A#DEFTOL.C4#C4_VALTOL" & NONESxC4) / nGBPClosingRate
		
		' Loop through the validations
		'-----------------------------------------------
		For Each sValAcc In HS.Account.List("VALIDATIONS", "[Base]")
			sPOVPartToAdd  = ""
			
			' Check if the validation is applicable to the POV
			' ------------------------------------------------
			sUDA = HS.Account.UD3(sValAcc)
			sApplicability = GetParameterValue(sUDA, "AppliesTo")
			sExceptions    = GetParameterValue(sUDA, "NotAppliesTo")
				'If IsEqual(sValAcc, "VA120511") Then Call WriteToDebugLog (sPUPOVshort & " - call for " & sValAcc & vbTab & "Acc UD3:" & sApplicability)
			
			If IsApplicableToPOV(sApplicability, sExceptions, "ALL") Then													'20150421_1_BY
				'Validation is applicable to the pov - execute it
				If bValueIsEC Then
					'If IsParameter(sApplicability, "ECT") Then sPOVPartToAdd = sValueECT	'UPDATE NEEDED: ENABLE LATER?
					sPOVPartToAdd = sValueECT
				End If
				
				Call CalcValidationAccount(sValAcc, nDefaultTolerance, sPOVPartToAdd)
			End If  'account is applicable to the pov
		Next
		
	End Sub   'CalcValidations
	
	Sub CalcValidationAccount(sValAcc, nDefaultTolerance, sPOVPartToAdd)
		sActiveCodeBlock = "CalcValidationAccount"
		
		'	Call WriteToDebugLog("sValAcc: " & sValAcc)
		Dim sExpressionSide1, sExpressionSide2, sFormulaSide1, sFormulaSide2, sFormula, sValType, sOperator, iZeroTolerance, sNoAnalysis, sDefaultMethod
		Dim oDataUnit, sDataUnitPOV, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sC5ReviewPoint, sC5Difference, sAccIC1C2C3, sC4ForData, sC4ToCheck, dCheckData, sC4Override, aOverrideMembers, sUDA, sEntity, sList
		Dim sHistAccount, sHistMovement, dRate, sRateAccount, sPINinput, sPINcalc, iPINinput, sPINstatus, dPINstatus, sNumberOfRecordsReviewed, iNumberOfRecordsReviewed, bFail, sPhaseC4, sAccountsForPhase
		iZeroTolerance = 0 : sNoAnalysis = "" : sDefaultMethod = ""
		bFail = False   'by default
		'--------------------------------------------------------------------------------------------------------------------------------
		' FORMAT
		'   Case Vxxxxxxx	'@VAL  Description
		'   	Formula: xxxx = xxxx
		' 		sExpressionSide1 = "A#xxxxxx" & TOPSxC1
		' 		sExpressionSide2 = "A#xxxxxx" & TOPSxC1 & " + A#xxxxxx" & TOPSxC1
		' 		Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "-", sExpressionSide2, >>Default Tolerance<<, sCustomAnalysis, "method")
		' INFO
		'   C4_VALRAC : Actual result,  C4_VALREF : Effective result,  C4_VALTOL : Validation tolerance (custom tolerance)
		'	CalcValidationResults parameters : 
		'		1: validation account, 2: validation type (as text) 3: expression left side, 4: operator (- or +, default is '-'), 5: expression right side,
		'		6: default tolerance (number), 7: validation analysis member (C2) - leave blank "" for default, 8: method - leave blank "" for default
		'		if expression right side is left blank, the rule discards the operator and calculates the expression left side and puts the result(s) 
		'		into the validation account.
		'   
		'	* * * DON'T USE ANY ADDITIONAL CONDITIONS (such as if entity is a US entity, period is Dec etc.) * * *
		'--------------------------------------------------------------------------------------------------------------------------------
		sValAcc = UCase(sValAcc)
		HS.Clear "A#" & sValAcc & ".C4#C4_VALRAC"			'UPDATE NEEDED: remove these and enable ClearPreviousCalculationResults. why not clear all results e.g. HS.Clear "C4#C4_VALRAC"	
		HS.Clear "A#" & sValAcc & ".C4#C4_VALREF1"			
		HS.Clear "A#" & sValAcc & ".C4#C4_VALREF2"
		
		sValType = GetValidationType(sValAcc)
		
		If sValType = "inactive" Then
			'N/A, validation is not applicable (inactive), skip it.
			Exit Sub
		End If
		
		Select Case sValAcc
			
		' ===================================================
		'   Special Case Validations
		' ===================================================
		
		Case "VL1101" 'Movements Calculated Nets to Nil
			'Pull the data for B/S accounts that have balances in MVCALC:[C1_9998 Movement Calculated] - ** UPDATE NEEDED FOR VALID BS ACCOUNTS **
			Set oDataUnit = HS.OpenDataUnit("A{A_MovementCalculatedNotAllowed}.C1#" & MVCALC & TOPSxC1 & sPOVPartToAdd)
			nNumItems = oDataUnit.GetNumItems
			
			If nNumItems = 0 Then
				'No balance on movement calculated movement - Validation Passed
			Else
				
				For i = 0 To nNumItems - 1
					'Get the next item from the data unit
					dData = oDataUnit.Item(i).Data
					
					If dData <> 0 Then
						'There is data in MVCALC(C1_9998), which means the user didn't move all balance to the valid movements.
						'sExpressionSide1 = "A#" & sAccount & ".C2#M99" & ".C4#" & sC4ToCheck & TOPSxC2C4 & sPOVPartToAdd		'REMOVE LATER
						sExpressionSide1 = Abs(dData)
						sExpressionSide2 = ""
						Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, nDefaultTolerance, sNoAnalysis, "accumulate")
					End If
				Next
				
				' 'Fail if Data is available in C1_9998						'UPDATE NEEDED: REMOVE IF NOT NEEDED
				' HS.Exp "A#VL1101.C4#C4_VALRAC" & NONESxC4 & " = 1"
				' HS.Exp "A#VL1101.C4#C4_VALREF1" & NONESxC4 & " = 1"
			End If
			
		Case "VL8101" 'Fixed rate must be input if there is a periodic historic movement data
		   'For every combination of Historic Account & Movement there should be a spot rate entered. C2 analysis for the validation under [C2_T1000 - Fixed Rate Account Analysis for Validation].
			
			For Each sRateAccount In HS.Account.List("FIXED_RATES", "[Base]")	 		
				sUDA = HS.Account.UD1(sRateAccount)
				sHistAccount  = GetParameterValue(sUDA, "ACC")
				sHistMovement = GetParameterValue(sUDA, "MVT")
				dData = HS.GetCell("A#" & sHistAccount & ".C1#" & sHistMovement & TOPSxC1 & ".W#Periodic" & sValueECT)
				
				If dData = 0 Then
					'No periodic movement in this spot rate movement, so no need for a fixed rate to be input by the user - skip
				Else
					dRate = HS.GetCell("A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2)
					
					If dRate = 0 Then
						'There is a periodic movement but no fixed rate input by the user to translate it at a fixed/spot rate. Make the validation fail.
						
						sExpressionSide1 = Abs(dData)
						sExpressionSide2 = ""
						Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, iZeroTolerance, "C2_" & sRateAccount, "accumulate")
					End If
				End If
			Next  'fixed rate account
			
		Case "VL8401" 'Spot Rates for Acquisitions, Disposals
			'If there is any balance on [C1_5016 Acquisitions]/[C1_5017 Disposals] then an acquisition/disposal rate must be present (input by user into this period or prior periods (rate is rolling forward)
			
			For Each sRateAccount In HS.Account.List("ACQ_RATES", "[Base]")
				sUDA = Trim(HS.Account.UD1(sRateAccount))
				sHistMovement = GetParameterValue(sUDA, "MVT")
				
				'Pull the data for B/S accounts that have a acquisition balance at the total levels.
				Set oDataUnit = HS.OpenDataUnit("A{TSTBS.[Base]}.C1#" & sHistMovement & TOPSxC1 & sPOVPartToAdd)
					nNumItems = oDataUnit.GetNumItems
					
				    If nNumItems = 0 Then
					  'No balance on Acquisition/Disposal movement - skip
				    Else
						dRate = HS.GetCell("A#" & sRateAccount & ".C1#GBP.C2#" & sPOVEntityDefCurrency & NONESxC1C2)
						
						If dRate = 0 Then
							For i = 0 To nNumItems - 1
								'Get the next item from the data unit
								dData = oDataUnit.Item(i).Data
								
								If dData <> 0 Then
									sExpressionSide1 = Abs(dData)
									sExpressionSide2 = ""
									Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, iZeroTolerance, sNoAnalysis, "accumulate")
								End If
							Next
						End If
					End If
				
			Next  'acquisition/disposal rate
			
		Case "VL9001", "VL9006"   'FD Sign Off PIN must be correctly entered
			'Formula: [PIN_INPUT Please Enter FD Sign Off PIN] must match [PIN_CALC PIN Generated by System]
			
			If IsNotParameter(HS.Entity.UD2(sPOVEntity), "PIN") Then
				'This entity doesn't have to be reviewed by an FD - no PIN process - skip
			Else
				
				Select Case sValAcc
					Case "VL9001" :  sPhaseC4 = ".C4#C4_PHASE1"
					Case "VL9006" :  sPhaseC4 = ".C4#C4_PHASE2"
				End Select
				
				'sPINinput = Trim(HS.GetCellTextWithLabel("A#PIN_INPUT" & sPhaseC4 & NONESxC4 & sValueNone, "[Default]"))
				iPINinput = HS.GetCell("A#PIN_INPUT" & sPhaseC4 & NONESxC4)
				
				'If sPINinput = "" Then
				If iPINinput = 0 Then
					'No PIN input by the user - PIN is needed for approval. Make the validation fail.
					bFail = True
				Else
					sPINcalc = HS.GetCellTextWithLabel("A#PIN_CALC" & sPhaseC4 & NONESxC4 & sValueNone, "System")
					
					If sPINcalc = "" Then
						'There is no PIN generated yet or it must have been invalidated and cleared. User must request FD review. Make the validation fail.
						bFail = True
						
					ElseIf iPINinput <> CInt(sPINcalc) Then
						'Wrong PIN. Make the validation fail.
						bFail = True
						
					Else
						'Correct PIN. Validation passed.							'UPDATE NEEDED: disabled this extra detail on status. Remove if not required.
						' dPINstatus = HS.GetCell("A#PIN_STATUS" & sPhaseC4 & NONESxC4)
						' If dPINstatus = -1 Then
							' 'PIN has been invalidated. The user must request another review and a new PIN. Make the validation fail.
							' bFail = True
						' Else
							' 'PIN is valid. Validation passed.
						' End If
					End If
				End If
				
				If bFail Then
					sExpressionSide1 = "1"   '1 as the actual result for 'fail'
					Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, iZeroTolerance, sNoAnalysis, sDefaultMethod)
				End If
			End If
			
		Case "VL9002", "VL9007"   'Data must not change after FD Sign Off
			'Formula: [NumberOfRecords - Number of records when FD review was requested] must match number of records now
			
			If IsNotParameter(HS.Entity.UD2(sPOVEntity), "PIN") Then
				'This entity doesn't have to be reviewed by an FD - no PIN process, no need for a validation check - skip
			Else
				
				Select Case sValAcc
					Case "VL9002" :  sPhaseC4 = ".C4#C4_PHASE1"  :  sAccountsForPhase = "A_Phase1_Accounts"
					Case "VL9007" :  sPhaseC4 = ".C4#C4_PHASE2"  :  sAccountsForPhase = "A_Phase2_Accounts"
				End Select
				
				'Check if FD Review has already been requested (there must be a calculated PIN)
				sPINcalc = HS.GetCellTextWithLabel("A#PIN_CALC" & sPhaseC4 & NONESxC4 & sValueNone, "System")
				
				If sPINcalc = "" Then
					'No PIN generated yet or it must have been invalidated and cleared before. [VL9001 - FD Sign Off PIN must be correctly entered] will fail, so no need to make this validation also fail - skip
				Else
					'  COMPARE NUMBER OF RECORDS
					' ---------------------------
					'[NumberOfRecords - Number of records when FD review was requested], [C5_FDSIGN - FD Sign Off]
					sNumberOfRecordsReviewed = HS.GetCellTextWithLabel("A#NumberOfRecords" & sPhaseC4 & NONESxC4 & sValueNone, "System")
					If sNumberOfRecordsReviewed = "" Then   iNumberOfRecordsReviewed = 0   Else   iNumberOfRecordsReviewed = CInt(sNumberOfRecordsReviewed)
					
					sDataUnitPOV  = "A{" & sAccountsForPhase & "}.C5{C5_FDSIGN.[Base]}" & sPOVPartToAdd
					Set oDataUnit = HS.OpenDataUnit(sDataUnitPOV)
					nNumItems = oDataUnit.GetNumItems
					
					'Record the number of records, to display on the validation form
					HS.Exp "A#NumberOfRecords" & sPhaseC4 & NONESxC4 & " = " & nNumItems
					
					If nNumItems = iNumberOfRecordsReviewed Then
						'Same number of records before and after - validation passed.		'UPDATE NEEDED: balances may have changed (e.g. balance in a journal adj), this won't catch it.
					Else
						'Data must have changed. Make the validation fail with the difference in number of records as the actual result of the validation.
						sExpressionSide1 = Abs(nNumItems - iNumberOfRecordsReviewed)
						Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, iZeroTolerance, sNoAnalysis, sDefaultMethod)
						
						'Invalidate the PIN so that the user will have to request another review and a new PIN. [PIN_STATUS PIN Status]
						' HS.Exp "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & " = -1"   ' -1 for invalidated PIN
						
						'Invalidate the PIN by clearing it so that the user will have to request another review and a new PIN. [PIN_STATUS PIN Status]
						HS.SetCellTextWithLabel "A#PIN_CALC"  & sPhaseC4 & NONESxC4 & sValueNone, "System", ""
						'HS.SetCellTextWithLabel "A#PIN_INPUT" & sPhaseC4 & NONESxC4 & sValueNone, "System", ""																			  UPDATE NEEDED: REMOVE LATER
						'HS.Clear "A#PIN_INPUT" & sPhaseC4 & NONESxC4				'Disabled this - no need to clear pin input by user, leave it there. it won't work any more anyway.   UPDATE NEEDED: REMOVE LATER
						
						'Notify the user.
						sPINstatus = "PIN generated before has been invalidated due to change(s) in data. Please request another review. " & CStr(Now())
						HS.SetCellTextWithLabel "A#PIN_STATUS" & sPhaseC4 & NONESxC4 & sValueNone, "System", sPINstatus
					End If
					
					Set oDataUnit = Nothing
					
					'  COPY BALANCES
					' ---------------
					'First copy data from [None] value which is the snapshot of data at the time FD request was requested.
					For Each sC5ReviewPoint In HS.Custom("Custom5").List("", "C5_SignedOffBalances")
						HS.Exp "C5#" & sC5ReviewPoint & " = C5#" & sC5ReviewPoint & sValueNone		'for all accounts
					Next  'data review point in C5
					
					'  COMPARE BALANCES
					' ------------------
					'Compare balances before and after FD review only if number of records is same as before.
					If Abs(nNumItems - iNumberOfRecordsReviewed) <> 0 Then
						'Number of records changed. No need to compare balances, because the validation has already failed due to this change. Balances copied (above) will provide additional analysis to the user.
					Else
						'Number of records is same as when FD signed off the data. Check if balances changed, C5_XXXX_DIFF members calculate the differences (e.g. C5_EXCEPT_DIFF for changes in Exceptionals since FD sign off)
						'sDataUnitPOV  = "A{" & sAccountsForPhase & "}.C5{C5_DifferencesSinceSignOff}" & sPOVPartToAdd		'BY: this didn't work, replaced this with the for loop on C5 members below - REMOVE LATER
						For Each sC5Difference In HS.Custom("Custom5").List("", "C5_DifferencesSinceSignOff")
							sDataUnitPOV  = "A{" & sAccountsForPhase & "}.C5#" & sC5Difference & sPOVPartToAdd
							Set oDataUnit = HS.OpenDataUnit(sDataUnitPOV)
							nNumItems = oDataUnit.GetNumItems
								'Call WriteToCellTextLog("sDataUnitPOV:" & sDataUnitPOV & "  nNumItems:" & nNumItems)
								
							If nNumItems = 0 Then
								'no balances - validation passed
							Else
								
								For i = 0 To nNumItems - 1
									'Get the next item from the data unit
									dData = Abs(oDataUnit.Item(i).Data)
									
									If dData < 0.01 Then		'there may be very small differences on calculated numbers (e.g. C1_9998) although nothing has changed in data
										'no difference for this combination of account x icp x custom1234, check next data item
									Else
										'A difference found, don't look any further (to save time), make the validation fail with this difference shown as the actual result
										sExpressionSide1 = dData
										sExpressionSide2 = ""
										Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "", sExpressionSide2, iZeroTolerance, sNoAnalysis, sDefaultMethod)
										bFail = True
										Exit For
									End If
								Next
							End If
							
							If bFail Then  Exit For
						Next  'difference member calculated in C5
					End If
				End If
			End If
			
		Case Else
			
		' ===================================================
		'   Parametric Validations (Formula in the UDA)
		' ===================================================
			
			sFormulaSide1 = Trim(HS.Account.UD1(sValAcc))
			sFormulaSide2 = Trim(HS.Account.UD2(sValAcc))
			'	Call WriteToDebugLog (sPUPOVshort & " - sFormulaSide1: " & sFormulaSide1)
			
			If sFormulaSide1 = "" Then
				'There is no formula for this account. Make the rule abort with a message to the HFM Admin.
				Call AbortRules("BLANK-UDA-VL", "Missing Metadata Attribute - UDA parameters not defined for " & sValAcc)
				
			ElseIf HasAnyOfTheseCharacters(sFormulaSide1 & sFormulaSide2, "<>") Then
				'-----------------------------------------------
				'|  Type A: Less Than, Greater Than, Equal To  |
				'-----------------------------------------------
				Dim iEqualSignPos, iLessOrGreaterSignPos
				
				sFormula = sFormulaSide1 & sFormulaSide2
				sFormula = ClearExtraSpacesAndDelimiters(sFormula, ".=<>")
				sFormula = Replace(sFormula, "=<", "<=")
				sFormula = Replace(sFormula, "=>", ">=")
				
				sFormula = ConvertToExpression(sFormula, "", "TOPS", "", "ALL", sPOVPartToAdd)
				
				iEqualSignPos = InStr(sFormula, "=")
				
				If iEqualSignPos > 0 Then
					sExpressionSide1 = Left(sFormula, iEqualSignPos - 2)
					sExpressionSide2 = Mid (sFormula, iEqualSignPos + 1)
					sOperator		 = Mid (sFormula, iEqualSignPos - 1, 2)
				Else
					iLessOrGreaterSignPos = InStr(sFormula, "<")
					If Not iLessOrGreaterSignPos > 0 Then iLessOrGreaterSignPos = InStr(sFormula, ">")
					
					sExpressionSide1 = Left(sFormula, iLessOrGreaterSignPos - 1)
					sExpressionSide2 = Mid (sFormula, iLessOrGreaterSignPos + 1)
					sOperator		 = Mid (sFormula, iLessOrGreaterSignPos, 1)
				End If
				
				'	Call WriteToDebugLog ("sFormula: " & sFormula)
				'	Call WriteToDebugLog ("sExpressionSide1: " & sExpressionSide1)
				'	Call WriteToDebugLog ("sOperator: " & sOperator)
				'	Call WriteToDebugLog ("sExpressionSide2: " & sExpressionSide2)
				
				Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, sOperator, sExpressionSide2, iZeroTolerance, sNoAnalysis, sDefaultMethod)
				
			Else
				'--------------------------------------
				'|  Type B: Side 1 must equal Side 2  |
				'--------------------------------------
				'Check if both sides of the formula are in the same UDA
				iEqualSignPos = InStr(sFormulaSide1, "=")
				If iEqualSignPos > 0 Then
					If iEqualSignPos = Len(sFormulaSide1) Then
						'Equals sign is at the end, let's remove it.
						sFormulaSide1 = Left(sFormulaSide1, iEqualSignPos - 1)
					ElseIf sFormulaSide2 <> "" Then
						'Side 1 has two sides but there is also something in Side 2. This is a defect - Make the HFM Rules abort so this can be noticed.
						Call AbortRules("VAL-FORMULA", "Validation formula has more than two sides! (" & sValAcc & ")")
					Else
						'Side 1 has both sides of the formula (in UDA1), let's split it to two sides
						sFormulaSide1 = Left(sFormulaSide1, iEqualSignPos - 1)
						sFormulaSide2 = Mid (sFormulaSide1, iEqualSignPos + 1)
					End If
				End If
				
				'Clean spaces around the delimiter (.), and any double delimiters (..) if there is any (possibly due to a typo error)
				sFormulaSide1 = ClearExtraSpacesAndDelimiters(sFormulaSide1, ".")
				sFormulaSide2 = ClearExtraSpacesAndDelimiters(sFormulaSide2, ".")
				
				sExpressionSide1 = ConvertToExpression(sFormulaSide1, "", "TOPS", "", "ALL", sPOVPartToAdd)
				
				If IsNumeric(sFormulaSide2) Then
					sExpressionSide2 = sFormulaSide2
				Else
					sExpressionSide2 = ConvertToExpression(sFormulaSide2, "", "TOPS", "", "ALL", sPOVPartToAdd)
				End If
				
					'Call WriteToDebugLog ("sValAcc: " & sValAcc & vbTab & "Side1: " & sFormulaSide1 & vbTab & "ExpSide1: " & sExpressionSide1)
					'Call WriteToDebugLog ("sValAcc: " & sValAcc & vbTab & "Side2: " & sFormulaSide2 & vbTab & "ExpSide2: " & sExpressionSide2)
				Call CalcValidationResults(sValAcc, sValType, sExpressionSide1, "-", sExpressionSide2, nDefaultTolerance, sNoAnalysis, sDefaultMethod)
				
			End If
		End Select
		
		Set oDataUnit = Nothing
	End Sub   'CalcValidationAccount
	
	Sub CalcValidationResults(sValAcc, sValType, sExpressionSide1, sOperator, sExpressionSide2, nDefaultTolerance, sCustomAnalysis, sMethod)
		sActiveCodeBlock = "CalcValidationResults"
		
		'Dim sBusinessClass, sTypeOfCalc, nValTolerance, dActualResult
		Dim sBusinessClass, nValTolerance, dActualResult, bRunAtEachBussClass, bZeroTolerance, sPassFailStatus
		Dim sValAccActualResultPOV, sValAccEffectiveResultPOV, sFormulaExpression, sTargetC2
		bZeroTolerance = False
		
		If sCustomAnalysis = "" Then  sTargetC2 = ".C2#[None]"   Else  sTargetC2 = ".C2#" & sCustomAnalysis
		
		'----------------------------------------------------------------
		' Check the expressions
		'----------------------------------------------------------------
		'	Call WriteToDebugLog(sValAcc & vbTab & sExpressionSide1 & "   " & sOperator  & "   " & sExpressionSide2)
		Select Case sOperator
			Case "<", ">", "<=", ">="
				'Greater/Less Than type of validation, tolerance doesn't apply (i.e. zero tolerance)
				bZeroTolerance = True
				If IsNumeric(sExpressionSide2) Then
					'number e.g. 0 (zero)
					sFormulaExpression = "(" & sExpressionSide1 & ") - " & sExpressionSide2
				Else
					sFormulaExpression = "(" & sExpressionSide1 & ") - (" & sExpressionSide2 & ")"
				End If
				
			Case Else
				If sExpressionSide2 = "" Then
					'One sided formula: used when the POV in ExpressionSide1 itself should be zero, 
					'so whatever number(s) exist in the POV will be copied into the validation account
					sFormulaExpression = sExpressionSide1
				Else
					If sOperator = "" Then sOperator = "-"	'the default operator is minus
					
					If IsNumeric(sExpressionSide2) Then
						'number e.g. 100 for hundred percent
						sFormulaExpression = "(" & sExpressionSide1 & ") " & sOperator & " " & sExpressionSide2
					Else
						sFormulaExpression = "(" & sExpressionSide1 & ") " & sOperator & " (" & sExpressionSide2 & ")"
					End If
				End If
		End Select
		
		'----------------------------------------------------------------
		' Calculate actual result
		'----------------------------------------------------------------
		sValAccActualResultPOV = "A#" & sValAcc & ".C4#C4_VALRAC" & sTargetC2 & NONESxC2C4
		
		If sMethod = "accumulate" Then
			'Accumulate method: same validation account is used to check multiple POVs (e.g. multiple accounts), the actual result will be calculated for each POV and will be added to the total actual result
			'HS.Exp sValAccActualResultPOV & " = " & sValAccActualResultPOV & " + " & sFormulaExpression		'UPDATE NEEDED: remove if not required (switched to ABSExp)
			HS.ABSExp sValAccActualResultPOV & " = " & sValAccActualResultPOV & " + " & sFormulaExpression
			
			'Calculate the actual result for this call only, to be used in hard validation calculations
			HS.Clear "A#TEMPDATA.C4#C4_VALRAC" & NONESxC4
			'HS.Exp "A#TEMPDATA.C4#C4_VALRAC" & NONESxC4 & " = " & sFormulaExpression							'UPDATE NEEDED: remove if not required (switched to ABSExp)
			HS.ABSExp "A#TEMPDATA.C4#C4_VALRAC" & NONESxC4 & " = " & sFormulaExpression
			dActualResult = HS.GetCell("A#TEMPDATA.C4#C4_VALRAC" & NONESxC4)
		Else
			'Default
			HS.Exp sValAccActualResultPOV & " = " & sFormulaExpression
			dActualResult = HS.GetCell(sValAccActualResultPOV)
		End If
			'Call WriteToDebugLog("dActualResult: " & dActualResult)
			
		'----------------------------------------------------------------
		' Clear actual result if it is a pass (for >/< validations)
		'----------------------------------------------------------------
		If sOperator = "<"  And dActualResult <  0  Or _
		   sOperator = "<=" And dActualResult <= 0  Or _
		   sOperator = ">"  And dActualResult >  0  Or _
		   sOperator = ">=" And dActualResult >= 0  Then
				HS.Clear sValAccActualResultPOV
				sPassFailStatus = "pass"
		Else
				sPassFailStatus = "fail"
		End If
		
		'----------------------------------------------------------------
		' Calculate effective result
		'----------------------------------------------------------------
		' Only if the validation is hard
		If sValType = "hard" Then
			
			If sPassFailStatus = "pass" Then
				'it is a pass, no effective result
				
			ElseIf sPassFailStatus = "fail" And bZeroTolerance Then
				'it is a fail, and is a hard validation which has zero tolerance. [C4_VALREF1 - Number of Fails - Phase 1], [C4_VALREF2 - Number of Fails - Phase 2]
				sValAccEffectiveResultPOV = "A#" & sValAcc & ".C4#C4_VALREF" & HS.Account.SubmissionGroup(sValAcc) & sTargetC2 & NONESxC2C4
				HS.Exp sValAccEffectiveResultPOV & " = 1"
			Else
				If bZeroTolerance Then
					nValTolerance = 0
				Else
					'Get the validation tolerance to use (GetValidationTolerance decides)
					nValTolerance = GetValidationTolerance(sValAcc, nDefaultTolerance)
				End If
				'Call WriteToDebugLog("nValTolerance: " & nValTolerance)
				
				If Abs(dActualResult) > nValTolerance Then
					'this is a hard validation and tolerance is exceeded, put 1 into effective result
					sValAccEffectiveResultPOV = "A#" & sValAcc & ".C4#C4_VALREF" & HS.Account.SubmissionGroup(sValAcc) & sTargetC2 & NONESxC2C4
						'Call WriteToDebugLog("EFFECTIVE: " & sValAccEffectiveResultPOV)
					
					If sMethod = "accumulate" Then
						'Accumulate method: same validation account is used to check multiple POVs (e.g. multiple accounts), the effective result will be the total number of fails (i.e. the number of actual results (for those POVs) that are above the tolerance
						HS.Exp sValAccEffectiveResultPOV & " = " & sValAccEffectiveResultPOV & " + 1"
					Else
						HS.Exp sValAccEffectiveResultPOV & " = 1"
					End If
				End If
			End If
		End If
	End Sub   'CalcValidationResults
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
	Function IsValidationActive(sValAcc)
		Select Case GetValidationParameter(sValAcc, "VALTYP")
			Case 888, 888000
				IsValidationActive = False
			Case Else
				IsValidationActive = True
		End Select
	End Function   'IsValidationActive
	
	Function IsValidationSoft(sValAcc)
		Select Case GetValidationParameter(sValAcc, "VALTYP")
			Case 999, 999000
				IsValidationSoft = True
			Case Else
				IsValidationSoft = False
		End Select
	End Function   'IsValidationSoft
	
	Function GetValidationType(sValAcc)
		Select Case GetValidationParameter(sValAcc, "VALTYP")
			Case 888, 888000
				'N/A: validation is not applicable (inactive)
				GetValidationType = "inactive"
			Case 999, 999000
				GetValidationType = "soft"
			Case Else
				'for any other number or no parameter, use the default (hard)
				GetValidationType = "hard"
		End Select
	End Function   'GetValidationType
	
	Function GetValidationTolerance(sValAcc, nDefaultTolerance)
		Dim dToleranceParameter
		dToleranceParameter = GetValidationParameter(sValAcc, "VALTOL")
		
		If dToleranceParameter <> 0 Then
			'there is a custom tolerance entered into the POV entity or None entity.
			'translate the tolerance (entered in GBP) to the local currency
			GetValidationTolerance = dToleranceParameter / nGBPClosingRate
		Else
			'no custom tolerance entered, use the default (which was already translated to local currency)
			GetValidationTolerance = nDefaultTolerance
		End If
	End Function   'GetValidationTolerance
	
	Function GetValidationParameter(sValAcc, sParamMember)
		Dim sValParameterPOV, dValParameterForPOVEntity, dValParameterForNoneEntity
		sValParameterPOV = "A#" & sValAcc & ".C4#C4_" & sParamMember & NONESxC4
		
		dValParameterForPOVEntity = HS.GetCell(sValParameterPOV & sValueEC)
		If dValParameterForPOVEntity <> 0 Then
			'There is a parameter entered to the POV entity, use that one as it overrides the parameter entered to the [None] entity.
			GetValidationParameter = dValParameterForPOVEntity
		Else
			dValParameterForNoneEntity = HS.GetCell(sValParameterPOV & ".E#[None].V#[None]")
			GetValidationParameter = dValParameterForNoneEntity
		End If
	End Function   'GetValidationParameter
	
	Sub CalcValidationLockAccounts()
		sActiveCodeBlock = "CalcValidationLockAccounts"
		
		Dim sReviewStatus, iReviewLevel, iMinLockLevel
		iMinLockLevel = 1
		
		If sApplication = "HFMDMDEV" Or sApplication = "HFMDMPPE" Then				'UPDATE NEEDED: remove this later.
			'Data Migration App - skip it (populating the lock account will make the FDMEE load fail)
			HS.Clear "A#VALLOCK1"
			
		ElseIf bIsActual Then
			' 'Temporary code below for the data integration team to test data loads.
			' HS.Clear "A#VALLOCK1"
			' HS.Exp "A#VALLOCK1" & ALLNONES & " = A#VL1001.C4#C4_VALREF" & TOPSxC4		'[VL1001 Balance Sheet Balances]		'UPDATE NEEDED: REMOVE IF NOT REQUIRED
			
			' Clear Lock Accounts
			'---------------------
				'Clear is needed because otherwise when the total effective result for a phase (e.g. VL100) is cleared by the user, it becomes no data and HS.Exp doesn't pull no data into the lock account and the previously calculated number stays.
				HS.Clear "A#VALLOCK1"
				HS.Clear "A#VALLOCK2"
				'HS.Clear "A#VALLOCK3"
			
			' Lock Phase 1
			'--------------
				sReviewStatus = HS.ReviewStatusUsingPhaseID("", 1)
				If BeginsWith(sReviewStatus, "Review Level") Then
					iReviewLevel = CInt(Trim(Right(sReviewStatus, 2)))
					If iReviewLevel >= iMinLockLevel Then
						'[C4_VALREF1 - Number of Fails - Phase 1]
						HS.Exp "A#VALLOCK1" & ALLNONES & " = A#VALIDATIONS.C4#C4_VALREF1" & TOPSxC4		'UPDATE NEEDED: Replace VALIDATIONS with VT0001 after creating phase total accounts (VT0001, VT0002, VT0003)
					End If
				End If
			
			' Lock Phase 2
			'--------------
				sReviewStatus = HS.ReviewStatusUsingPhaseID("", 2)
				If BeginsWith(sReviewStatus, "Review Level") Then
					iReviewLevel = CInt(Trim(Right(sReviewStatus, 2)))
					If iReviewLevel >= iMinLockLevel Then
						'[C4_VALREF2 - Number of Fails - Phase 2]
						HS.Exp "A#VALLOCK2" & ALLNONES & " = A#VALIDATIONS.C4#C4_VALREF2" & TOPSxC4 & " + A#VALLOCK1" & ALLTOPS
					End If
				End If
			
			' Lock Phase 3
			'--------------
				' sReviewStatus = HS.ReviewStatusUsingPhaseID("", 3)					'UPDATE NEEDED: ENABLE LATER when we have phase 3 validation account(s)
				' If BeginsWith(sReviewStatus, "Review Level") Then
					' iReviewLevel = CInt(Trim(Right(sReviewStatus, 2)))
					' If iReviewLevel >= iMinLockLevel Then
						'
						' HS.Exp "A#VALLOCK3" & ALLNONES & " = A#VT0003.C4#C4_VALREF" & TOPSxC4 & " + A#VALLOCK2" & ALLTOPS
					' End If
				' End If
			
		End If  'actual scenario
	End Sub   'CalcValidationLockAccounts
	
	Sub CalcFlash()
		sActiveCodeBlock = "CalcFlash"
		Dim sUDA
		
		'Flash Reporting Opening Balance at Period View
			'FL00010 - Revenue, FL00020 = Operating Profit
			'C1_9901 - Opening Balance FLASH
			'PM1000 - Revenue ex VAT, PM6500 - Management operating Profit
			If bIsFirstPeriod Then
				'No opening balance for P1 in Flash
			Else
				'For P2-P12	- Run this calc only at Parent Entity (<EC>)
				sUDA = HS.Entity.UD1(sPOVEntity)
				If IsParameter(sUDA, "FLASHINPUT") Then
					HS.Exp "A#FL00010.C1#C1_9901" & NONESxC1C5 & " = S#Actual.A#PM1000.P#PRIOR" & TOPSxC5 & sValueECT
					HS.Exp "A#FL00020.C1#C1_9901" & NONESxC1C5 & " = S#Actual.A#PM6500.P#PRIOR" & TOPSxC5 & sValueECT
				End If
			End If
	End Sub   'CalcFlash
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
dim secC3 '   Section C3 - OTHER - Useful subs and functions
		  ' ==========================================================================================================
	Function IsApplicableToPOV(sApplicability, sExceptions, sCheckFor)
		'sApplicability : The UDA string which will be checked against the POV for applicability
		'sExceptions	: The UDA string which lists the exceptions to the applicability (e.g. Run for all UK entities except ENT001 and ENT002)
		'sPOV			: A process unit POV in the standard format (e.g. V#<Entity Currency>.P#P12.E#GROUP). If left blank, it uses the current POV.		'BY: UPDATE FOR THIS PARAMETER !!!
		'sCheckFor		: this can be a combination of scenario, year, period, entity and value dimensions (e.g. "PERIOD ENTITY"). If left blank it will check for all applicable dimensions.
		
		If Trim(sApplicability) = "" And Trim(sExceptions) = "" Then
			'No restrictions defined, return True as default.
			IsApplicableToPOV = True
			Exit Function
		End If
		
		' INITIALIZE VARIABLES
		' ====================
			Dim aResults(5,3), sResult, i, aParams, sParamValue, sValuesDelimiter, bApplicableToPOV, sDimension
			sCheckFor = UCase(sCheckFor) : bApplicableToPOV = True   'by default
			If sCheckFor = "ALL" Or sCheckFor = "" Then sCheckFor = "SCENARIO, VALUE, YEAR, PERIOD, ENTITY"
			
			'Column Headers of the Results Table:
			aResults(0,0) = "Dimension"
			aResults(0,1) = "Needs Checking?"
			aResults(0,2) = "Applicability parameter found?"
			aResults(0,3) = "Result"
			
			'Row Headers of the Results Table:				'UPDATE NEEDED: Add a sample view of this table here
			aResults(1,0) = "SCENARIO"
			aResults(2,0) = "VALUE"
			aResults(3,0) = "YEAR"
			aResults(4,0) = "PERIOD"
			aResults(5,0) = "ENTITY"
			
			For i = 1 To 5
				sDimension = aResults(i,0)
				If InStr(sCheckFor, sDimension) Then
					Call SetArrayValue(aResults, sDimension, "Needs Checking?", "YES")
				Else
					Call SetArrayValue(aResults, sDimension, "Needs Checking?", "NO")
				End If
			Next  'dimension in array
			
		' CHECK FOR APPLICABILITY
		' =======================
		' Loop through the members/values in parameter string (sApplicability)
			sValuesDelimiter = ","		'delimiter separating the values of a parameter (e.g. AppliesTo:Actual,Forecast,P6,P12)
			aParams = Split(Trim(sApplicability), sValuesDelimiter)
			
			For Each sParamValue In aParams
				'UPDATE NEEDED: improvement needed - to be able to use member lists in AppliesTo parameter.
				sDimension = GetDimensionNameOrReference(WhichDimension(sParamValue))
				
				If GetArrayValue(aResults, sDimension, "Needs Checking?") = "YES" Then
					sResult = GetArrayValue(aResults, sDimension, "Result")
					
					If sResult = "PASS" Then
						'Checks have passed for this dimension before already - skip
					Else
						'Check the parameter value against the Process Unit POV
						Call SetArrayValue(aResults, sDimension, "Applicability parameter found?", "YES")
						
						Select Case sDimension
							Case "SCENARIO" :  If IsEqual(sParamValue, sPOVScenario) Then   sResult = "PASS"
							Case "VALUE"	:  If IsEqual(sParamValue, sPOVValue) 	 Then   sResult = "PASS"
							Case "YEAR"		:  If IsEqual(sParamValue, sPOVYear) 	 Then   sResult = "PASS"
							Case "PERIOD"	:  If IsEqual(sParamValue, sPOVPeriod)	 Then   sResult = "PASS"
							Case "ENTITY"	:  If IsEqual(sParamValue, sPOVEntity)	 Then   sResult = "PASS"
						End Select
						
						Select Case sResult
							Case "" 	 :  Call SetArrayValue(aResults, sDimension, "Result", "FAIL")
							Case "PASS"  :  Call SetArrayValue(aResults, sDimension, "Result", "PASS")
							Case "FAIL"  :  'it was a fail and is still a fail, no need to write to the results array
						End Select
					End If
				Else
					'The dimension this member (in parameter value) is in doesn't need to be checked - skip
				End If
			Next  'parameter value
			
		' CHECK FOR EXCEPTIONS
		' ====================
		' Loop through the members/values in parameter string (sExceptions)
			aParams = Split(Trim(sExceptions), sValuesDelimiter)
			
			For Each sParamValue In aParams
				'UPDATE NEEDED: improvement needed - to be able to use member lists in NotAppliesTo parameter.
				sDimension = GetDimensionNameOrReference(WhichDimension(sParamValue))
				
				If GetArrayValue(aResults, sDimension, "Needs Checking?") = "YES" Then
					sResult = GetArrayValue(aResults, sDimension, "Result")
					
					If sResult = "FAIL" Then
						'Checks have failed for this dimension before already - skip
					Else
						'Check the parameter value against the Process Unit POV
						Call SetArrayValue(aResults, sDimension, "Applicability parameter found?", "YES")
						
						Select Case sDimension
							Case "SCENARIO" :  If IsEqual(sParamValue, sPOVScenario) Then	sResult = "FAIL"
							Case "VALUE"	:  If IsEqual(sParamValue, sPOVValue) 	 Then	sResult = "FAIL"
							Case "YEAR"		:  If IsEqual(sParamValue, sPOVYear) 	 Then	sResult = "FAIL"
							Case "PERIOD"	:  If IsEqual(sParamValue, sPOVPeriod)	 Then	sResult = "FAIL"
							Case "ENTITY"	:  If IsEqual(sParamValue, sPOVEntity)	 Then	sResult = "FAIL"
						End Select
						
						Select Case sResult
							Case "" 	 :  Call SetArrayValue(aResults, sDimension, "Result", "PASS")
							Case "FAIL"  :  Call SetArrayValue(aResults, sDimension, "Result", "FAIL")
							Case "PASS"  :  'it was a pass and is still a pass, no need to write to the results array
						End Select
						
						Call SetArrayValue(aResults, sDimension, "Result", sResult)
					End If
				Else
					'The dimension this member (in parameter value) is in doesn't need to be checked - skip
				End If
			Next  'parameter value
			
		' CHECK RESULTS
		' =============
			For i = 1 To 5
				sDimension = aResults(i,0)
				
				If GetArrayValue(aResults, sDimension, "Needs Checking?") = "YES" Then
					If GetArrayValue(aResults, sDimension, "Applicability parameter found?") = "YES" Then		'UPDATE NEEDED: may not need to check this any more. if a parameter is found the result is populated as a PASS or FAIL
						sResult = GetArrayValue(aResults, sDimension, "Result")
						
						If sResult = "PASS" Then
							'POV checks have passed for this dimension
							bApplicableToPOV = True
							
						ElseIf sResult = "" Then
							'POV checks have not failed for this dimension
							bApplicableToPOV = True
							
						ElseIf sResult = "FAIL" Then
							'POV checks have failed for this dimension, no need to check further, make it a fail
							bApplicableToPOV = False
							Exit For
						
						Else
							'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
							Call AbortRules("ELSE-ISAPPL", "I am in ELSE within the If/ElseIf/Else block in IsApplicableToPOV() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
						End If
					Else
						'No parameter value found for this dimension, which means no restrictions apply for it - skip
					End If
				Else
					'This dimension doesn't need to be checked - skip
				End If
			Next  'dimension in array
			
		' THE END RESULT
		' ==============
		IsApplicableToPOV = bApplicableToPOV
		
	End Function   'IsApplicableToPOV
	
	Function IsNotApplicableToPOV(sApplicability, sExceptions, sCheckFor)
		IsNotApplicableToPOV = Not IsApplicableToPOV(sApplicability, sExceptions, sCheckFor)
	End Function   'IsNotApplicableToPOV
	
	Function GetMemberList(sListName, ByRef sDimension)
		Dim sMemberList, sMember, sList, nDotPosition, aReturnList, sDimensionRef
		sMemberList = sListName
		
		If BeginsWith(sMemberList, "{") And EndsWith(sMemberList, "}") Then   sMemberList =  Mid(sMemberList, 2, Len(sMemberList) - 2)
		
		nDotPosition = InStr(sMemberList, ".")
		If nDotPosition Then
			'A system member list (e.g. {[ICP Entities].[Base]}, {PM9999.[Base]})
			sMember = Left(sMemberList, nDotPosition - 1)
			sList   = Mid (sMemberList, nDotPosition + 1)
			sDimensionRef = WhichDimension(sMember)
			sDimension = GetDimensionNameOrReference(sDimensionRef)
		Else
			'A custom member list (e.g. {A_AccountsForCTR})
			sMember = ""
			sList   = sMemberList
			sDimensionRef = Left(sMemberList, 1)
			sDimension = GetDimensionNameOrReference(sDimensionRef)
		End If
		
		Select Case sDimensionRef
			Case "S" :	aReturnList = HS.Scenario.List(sMember, sList)
			Case "E" :	aReturnList = HS.Entity.List  (sMember, sList)
			Case "A" :	aReturnList = HS.Account.List (sMember, sList)
			Case "I" :	aReturnList = HS.ICP.List	  (sMember, sList)
			Case "C1" :	aReturnList = HS.Custom("Custom1").List(sMember, sList)
			Case "C2" :	aReturnList = HS.Custom("Custom2").List(sMember, sList)
			Case "C3" :	aReturnList = HS.Custom("Custom3").List(sMember, sList)
			Case "C4" :	aReturnList = HS.Custom("Custom4").List(sMember, sList)
			Case "C5" :	aReturnList = HS.Custom("Custom5").List(sMember, sList)
			Case Else
				'Couldn't find the member. Make the HFM Rules abort with a message to the HFM Admin.
				Call AbortRules("LIST-ERROR", "Function GetMemberList() - List provided {" & sMemberList & "} could not be found! - [Dimension Ref: " & sDimensionRef & "], [Dimension: " & sDimension & "]")
		End Select
		
		GetMemberList = aReturnList
	End Function   'GetMemberList
	
	Function GetParentEntity(sRootEntity, sChildEntity)
		'BY: Code to be written, or REMOVE IF NOT REQUIRED !!!
	End Function   'GetParentEntity
	
	Function GetUDA(sDimension, sMember, sUDField)
		Dim sUDA
		
		Select Case UCase(sDimension)
		Case "ACCOUNT"
			Select Case UCase(sUDField)
				Case "UD1" :	sUDA = HS.Account.UD1(sMember)
				Case "UD2" :	sUDA = HS.Account.UD2(sMember)
				Case "UD3" :	sUDA = HS.Account.UD3(sMember)
				Case "ALL" :	sUDA = HS.Account.UD1(sMember) & " " & HS.Account.UD2(sMember) & " " & HS.Account.UD3(sMember)
			End Select
			
		Case "ENTITY"
			Select Case UCase(sUDField)
				Case "UD1" :	sUDA = HS.Entity.UD1(sMember)
				Case "UD2" :	sUDA = HS.Entity.UD2(sMember)
				Case "UD3" :	sUDA = HS.Entity.UD3(sMember)
				Case "ALL" :	sUDA = HS.Entity.UD1(sMember) & " " & HS.Entity.UD2(sMember) & " " & HS.Entity.UD3(sMember)
			End Select
			
		Case "SCENARIO"
			Select Case UCase(sUDField)
				Case "UD1" :	sUDA = HS.Scenario.UD1(sMember)
				Case "UD2" :	sUDA = HS.Scenario.UD2(sMember)
				Case "UD3" :	sUDA = HS.Scenario.UD3(sMember)
				Case "ALL" :	sUDA = HS.Scenario.UD1(sMember) & " " & HS.Scenario.UD2(sMember) & " " & HS.Scenario.UD3(sMember)
			End Select
			
		Case Else
			Select Case UCase(sUDField)
				Case "UD1" :	sUDA = HS.Custom(sDimension).UD1(sMember)
				Case "UD2" :	sUDA = HS.Custom(sDimension).UD2(sMember)
				Case "UD3" :	sUDA = HS.Custom(sDimension).UD3(sMember)
				Case "ALL" :	sUDA = HS.Custom(sDimension).UD1(sMember) & " " & HS.Custom(sDimension).UD2(sMember) & " " & HS.Custom(sDimension).UD3(sMember)
			End Select
		End Select
		
		GetUDA = sUDA
	End Function
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
	Function IsParameter(sString, sParameter)
		'This function tries to find the parameter (sParameter: the name of the parameter) in the UDA string (sString), returns true if it finds it.
		Dim aParams, sParamString, nSeparatorPosition, sParamDelimiter, sParamValueSeparator, sValuesDelimiter, sPOVDelimiter, sArithmeticOperators, sDelimitersConcatenated
		
		If Trim(sString) = "" Then
			'No parameter string, return false by default
			
		ElseIf InStr(sString, sParameter) Then
			
			'Parameter Delimiters & Operators - must be same as the delimiters used in GetParameterValue
			sParamDelimiter 	 = " "		'delimiter separating parameters (e.g. ENRICHOFF FXCTR)
			sParamValueSeparator = ":"		'delimiter separating parameter from its values (e.g. NOINPUT:ACTUAL)
			sValuesDelimiter 	 = ","		'delimiter separating the values of a parameter (e.g. NOINPUT:P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11)
			sPOVDelimiter 	 	 = "."		'delimiter separating the dimension members of a POV used in a parameter value (e.g. CALC:BS8999.C1_M000)
			sArithmeticOperators = "()+-*/="
			
			sDelimitersConcatenated = sParamValueSeparator & sValuesDelimiter & sPOVDelimiter & sArithmeticOperators
			sParameter = UCase(Trim(sParameter))
			
			sString = ClearExtraSpacesAndDelimiters(UCase(sString), sDelimitersConcatenated)
			
			If InStr(sString, sParameter & ":SEE RULES") Then
				'No value, the code/logic is in the rules (e.g. NOINPUT:SEE RULES). Return False because there isn't a parametric rule for this member.
			Else
				aParams = Split(sString, sParamDelimiter)
				For Each sParamString In aParams
					sParamString = Trim(sParamString)
					nSeparatorPosition = Instr(sParamString, sParamValueSeparator)
					If nSeparatorPosition > 0 Then
						'there is a colon, so the parameter name is the text before colon
						sParamString = Trim(Left(sParamString, nSeparatorPosition - 1))
					End If
					
					If IsEqual(sParamString, sParameter) Then
						'parameter was found in the string
						IsParameter = True
						Exit Function
					End If
				Next
			End If
		End If
		
		IsParameter = False  'by default
	End Function   'IsParameter
	
	Function IsNotParameter(sString, sParameter)
		IsNotParameter = Not IsParameter(sString, sParameter)
	End Function   'IsNotParameter
	
	Function IsParameterValue(sString, sParameter, sValueToLookFor)
		'This function tries to find the parameter value (sValueToLookFor) in the parameter values listed for the parameter (sParameter) in the UDA string (sString)
		Dim aParams, sParamValueString, sParamValue, sValuesDelimiter
		
		sValuesDelimiter = ","		'delimiter separating the values of a parameter (e.g. NOINPUT:Budget,Forecast)
		sValueToLookFor = UCase(sValueToLookFor)
		
		sParamValueString = GetParameterValue(sString, sParameter)
		
		If sParamValueString <> "" Then
			If InStr(sParamValueString, sValueToLookFor) Then
				aParams = Split(sParamValueString, sValuesDelimiter)
				
				For Each sParamValue In aParams
					If sParamValue = sValueToLookFor Then
						IsParameterValue = True
						Exit Function
					End If
				Next
			End If
		End If
		
		IsParameterValue = False  'by default
	End Function   'IsParameterValue
	
	Function IsNotParameterValue(sString, sParameter, sValueToLookFor)
		IsNotParameterValue = Not IsParameterValue(sString, sParameter, sValueToLookFor)
	End Function   'IsNotParameterValue
	
	Function GetParameterValue(sString, sParameter)
		'This function tries to find the parameter (sParameter: the name of the parameter) in the UDA string (sString), and returns the parameter value after ':' if it finds.
		Dim aParams, i, sParamString, sParamValue, bPartialValueFound, sRemainingPart, nSeparatorPosition
		Dim sParamDelimiter, sValuesDelimiter, sParamValueSeparator, sPOVDelimiter, sArithmeticOperators, sDelimitersConcatenated
		
		sParamValue = ""   'return blank by default
		
		If Trim(sString) = "" Then
			'No parameter string, return blank by default
			'UPDATE NEEDED: it would be good to have a conditional check here (an additional parameter for the function to enable the check for some accounts)` and abort the rule if required (e.g. if the historic rate account parameter values are blank)
			
		ElseIf InStr(sString, sParameter) Then
			
			'Parameter Delimiters & Operators - must be same as the delimiters used in IsParameter
			sParamDelimiter 	 = " "		'delimiter separating parameters (e.g. ENRICHOFF FXCTR)
			sParamValueSeparator = ":"		'delimiter separating parameter from its values (e.g. NOINPUT:ACTUAL)
			sValuesDelimiter 	 = ","		'delimiter separating the values of a parameter (e.g. NOINPUT:P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11)
			sPOVDelimiter 	 	 = "."		'delimiter separating the dimension members of a POV used in a parameter value (e.g. CALC:BS8999.C1_M000)
			sArithmeticOperators = "()+-*/="
			
			sDelimitersConcatenated = sParamValueSeparator & sValuesDelimiter & sPOVDelimiter & sArithmeticOperators
			bPartialValueFound   = False
			sParameter 			 = UCase(Trim(sParameter))
			
			sString = ClearExtraSpacesAndDelimiters(UCase(sString), sDelimitersConcatenated)
			
			If InStr(sString, sParameter & ":SEE RULES") Then
				'No value, the code/logic is in the rules (e.g. CALC:SEE RULES)
			Else
				aParams = Split(sString, sParamDelimiter)
				For Each sParamString In aParams
					If bPartialValueFound Then
						sRemainingPart = sRemainingPart & " " & sParamString
						'Check if there is any other member with a space (e.g. <Entity Curr Adjs>)
						If EndsWith(sParamString, "[ICP")    Or _
						   EndsWith(sParamString, "<Entity") Or _
						   EndsWith(sParamString, "<Parent") Or _
						   EndsWith(sParamString, "[Parent") Or _
						   EndsWith(sParamString, "[Contribution") Or _
						   IsEqual (sParamString, "Curr") Then
							'The end of the parameter value isn't reached yet, keep looking for the remaining parts of the value
						Else
							'The end of the parameter value is reached. Return the concatenated value
							sParamValue = sParamValue & sRemainingPart
							Exit For
						End If
					Else
						nSeparatorPosition = Instr(sParamString, sParamValueSeparator)
						If nSeparatorPosition > 0 Then
							'there is a colon (separator), so the parameter value is the text after colon and parameter name is the text before colon
							If sParameter = Trim(Left(sParamString, nSeparatorPosition - 1)) Then
								'this is the parameter we were searching for, return the parameter value if it is not a partial value
								sParamValue = Trim(Mid(sParamString, nSeparatorPosition + 1, Len(sParamString) - nSeparatorPosition))
								
								'Check if the parameter value is a member with a space (e.g. [ICP None]). Space is also used as the parameter delimiter which causes the remaining value to fall into the other member(s) of aParams.
								If EndsWith(sParamString, "[ICP")    Or _
								   EndsWith(sParamString, "<Entity") Or _
								   EndsWith(sParamString, "<Parent") Or _
								   EndsWith(sParamString, "[Parent") Or _
								   EndsWith(sParamString, "[Contribution") Then
									'Space in the parameter value string (e.g. [ICP None], <Entity Curr Adjs>), keep looking for the remaining parts of the value
									bPartialValueFound = True
								Else
									'Return the parameter value
									Exit For
								End If
							End If
						End If
					End If
				Next  'parameter string
			End If
		End If
		
		GetParameterValue = sParamValue
	End Function   'GetParameterValue
	
	Function ConvertToExpression(sFormula, sTargetAcc, sDefaultMembers, sDefaultMemberExceptions, sWhichDimensions, sPOVPartToAdd)
		'This function converts the formula side (in UDA of the validation account) to a expression side (e.g. E33302T.M58 to A#E33302T.C1#C1_TOP.C2#M58.C3#C3_TOP.C4#C4_TOP.I#[ICP Top]).
		Dim i, j, iLastChar, sAccount, sMember, sC1, sC2, sC3, sC4, sC5, sICP, sCTop
		Dim aPOVSections(50), sPOVSection, iSectionCounter, iPOVstart, iPOVend, aPOVMembers, sExpressionForSection, sFullExpression, sDimsFoundInSection, sDimension, iHashPosition, aExceptions
		iPOVstart = 0: iPOVend = 0: iSectionCounter = 0
		sDefaultMembers = UCase(sDefaultMembers): sWhichDimensions = UCase(sWhichDimensions)
		
		If sDefaultMemberExceptions <> "" Then
			aExceptions = Split(sDefaultMemberExceptions, ".")
		End If
		
		
		If sFormula = "" Then
			sFullExpression = ""
		Else
			sFullExpression = sFormula	'Put the formula in it, will be replaced with expressions
			
			'First find if there are multiple POV sections in the formula (e.g. ACC1000 - ACC2000.C1_M99)
			iLastChar = Len(sFormula)
			For i = 1 To iLastChar
				Select Case Mid(sFormula, i, 1)
					Case "(", ")", "-", "+", "*", "/", "<", ">", "=", " "			'UPDATE NEEDED: if <EC>,<ECA> or <ECT> is used in the formula what will happen?, those should be checked and skipped.
						'Arithmetic operation characters or space
						If iPOVstart > 0 Then	iPOVend = i - 1
						
					Case Else
						'Any other character is assumed to be part of a member label (i.e. part of the POV)
						If iPOVstart = 0 Then
							'This is first character of a new section
							iPOVstart = i
						ElseIf i = iLastChar Then
							'We have come to the last character in formula, a section started but didn't end, let's capture it.
							iPOVend = i
						End If
				End Select
				
				If iPOVend > 0 Then
					aPOVSections(iSectionCounter) = Mid(sFormula, iPOVstart, iPOVend - iPOVstart + 1)
					iSectionCounter = iSectionCounter + 1
					iPOVstart = 0: iPOVend = 0
				End If
			Next  'character in formula
			
			For Each sPOVSection In aPOVSections
				If sPOVSection <> "" Then
						'Call WriteToDebugLog("sPOVSection: " & sPOVSection)
					sDimsFoundInSection = "": sC1 = "": sC2 = "": sC3 = "": sC4 = "": sC5 = "": sICP = ""
					aPOVMembers = Split(sPOVSection, ".")
					
					'Check if an account is provided
					If ExistsIn(HS.Account.List("", "[Hierarchy]"), aPOVMembers(0)) Then			'UPDATE NEEDED: ExistsIn may be taking a lot of time, improve performance if possible
						sAccount = aPOVMembers(0) :		iPOVstart = 1
					Else
						'No account or typo error in the account code in the POV (formula), Make the HFM Rules abort with a message to the HFM Admin.
						Call AbortRules("WRONG-ACCOUNT", "Missing account or wrong account code used (" & aPOVMembers(0) & ") in the formula of Target Account: (" & sTargetAcc & ")  Formula:" & sFormula)
						
						'For calculation between the custom members of the target account (e.g. SCC = NOS * SHC) the formula need to include the account code after equal sign (e.g. SCC = ACC1234.NOS * ACC1234.SHC)
					End If
					
					' Set the default members
					'--------------------------
					Select Case sDefaultMembers
						Case "TOPS"
							sC1 = ".C1#C1_TOP": sC2 = ".C2#C2_TOP": sC3 = ".C3#C3_TOP": sC4 = ".C4#C4_TOP": sC5 = ".C5#C5_TOP": sICP = ".I#[ICP Top]"
							
						Case "NONES"
							sC1 = ".C1#[None]": sC2 = ".C2#[None]": sC3 = ".C3#[None]": sC4 = ".C4#[None]": sC5 = ".C5#[None]": sICP = ".I#[ICP None]"
							
						Case "CUSTOM TOP MEMBERS"
							'If there is a custom analysis group assigned to the account, the TB balance should be written to it, so it appears on the total line (on this top member) on the webform.
							sC1 = ".C1#" & HS.Account.CustomTop(sAccount, "Custom1"): 	If sC1 = ".C1#" Then sC1 = ".C1#[None]"
							sC2 = ".C2#" & HS.Account.CustomTop(sAccount, "Custom2"): 	If sC2 = ".C2#" Then sC2 = ".C2#[None]"
							sC3 = ".C3#" & HS.Account.CustomTop(sAccount, "Custom3"): 	If sC3 = ".C3#" Then sC3 = ".C3#[None]"
							sC4 = ".C4#" & HS.Account.CustomTop(sAccount, "Custom4"): 	If sC4 = ".C4#" Then sC4 = ".C4#[None]"
							sC5 = ".C5#" & HS.Account.CustomTop(sAccount, "Custom5"): 	If sC5 = ".C5#" Then sC5 = ".C5#[None]"
							
							If HS.Account.IsICP(sAccount) Then
								sICP = ".I#[ICP Top]"
							Else
								sICP = ".I#[ICP None]"
							End If
							
						Case "NONES FOR UNUSED DIMENSIONS"
							'If there is no custom analysis group assigned, use [None] for that custom. Use [ICP None] if not icp account.
							sCTop = UCase(HS.Account.CustomTop(sAccount, "Custom1")): 	If sCTop = "" Or sCTop = "[NONE]" Then sC1 = ".C1#[None]"
							sCTop = UCase(HS.Account.CustomTop(sAccount, "Custom2")): 	If sCTop = "" Or sCTop = "[NONE]" Then sC2 = ".C2#[None]"
							sCTop = UCase(HS.Account.CustomTop(sAccount, "Custom3")): 	If sCTop = "" Or sCTop = "[NONE]" Then sC3 = ".C3#[None]"
							sCTop = UCase(HS.Account.CustomTop(sAccount, "Custom4")): 	If sCTop = "" Or sCTop = "[NONE]" Then sC4 = ".C4#[None]"
							sCTop = UCase(HS.Account.CustomTop(sAccount, "Custom5")): 	If sCTop = "" Or sCTop = "[NONE]" Then sC5 = ".C5#[None]"
							
							If Not HS.Account.IsICP(sAccount) Then   sICP = ".I#[ICP None]"
							
							If sWhichDimensions = "" Then   sWhichDimensions = "POPULATED"
							
						Case "TOPS EXCLUDING SAME ANALYSIS"
							'Tops but exclude the dimensions where the same analysis is used by the source and target/destination account
							sCTop = UCase(HS.Account.CustomTop(sTargetAcc, "Custom1"))
							If sCTop = "" Or sCTop = "[NONE]" Or sCTop <> HS.Account.CustomTop(sAccount, "Custom1") Then sC1 = ".C1#C1_TOP"
							sCTop = UCase(HS.Account.CustomTop(sTargetAcc, "Custom2"))
							If sCTop = "" Or sCTop = "[NONE]" Or sCTop <> HS.Account.CustomTop(sAccount, "Custom2") Then sC2 = ".C2#C2_TOP"
							sCTop = UCase(HS.Account.CustomTop(sTargetAcc, "Custom3"))
							If sCTop = "" Or sCTop = "[NONE]" Or sCTop <> HS.Account.CustomTop(sAccount, "Custom3") Then sC3 = ".C3#C3_TOP"
							sCTop = UCase(HS.Account.CustomTop(sTargetAcc, "Custom4"))
							If sCTop = "" Or sCTop = "[NONE]" Or sCTop <> HS.Account.CustomTop(sAccount, "Custom4") Then sC4 = ".C4#C4_TOP"
							sCTop = UCase(HS.Account.CustomTop(sTargetAcc, "Custom5"))
							If sCTop = "" Or sCTop = "[NONE]" Or sCTop <> HS.Account.CustomTop(sAccount, "Custom5") Then sC5 = ".C5#C5_TOP"
							
							If Not HS.Account.IsICP(sTargetAcc) Then   sICP = ".I#[ICP Top]"
							
							If sWhichDimensions = "" Then   sWhichDimensions = "POPULATED"
					End Select
					
					'Check if any exceptional default member is provided
					If sDefaultMemberExceptions <> "" Then
						For Each sMember In aExceptions
							Select Case Left(sMember, 2)
								Case "C1": sC1  = "." & sMember
								Case "C2": sC2  = "." & sMember
								Case "C3": sC3  = "." & sMember
								Case "C4": sC4  = "." & sMember
								Case "C5": sC5  = "." & sMember
								Case "I#": sICP = "." & sMember
							End Select
						Next
					End If
					
					'Loop through the members in POV
					For j = iPOVstart To UBound(aPOVMembers)
						sMember = aPOVMembers(j)
						
						iHashPosition = InStr(sMember, "#")
						If iHashPosition > 0 Then
							'Dimension reference is provided with the member name (this is the unlikely case)
							sDimension = Left(sMember, iHashPosition - 1)
							sMember = Mid(sMember, iHashPosition + 1)
						Else
							'Search it in the dimensions
							sDimension = WhichDimension(sMember)
						End If
						
						Select Case sDimension
							Case "C1": sC1  = ".C1#" & sMember
							Case "C2": sC2  = ".C2#" & sMember
							Case "C3": sC3  = ".C3#" & sMember
							Case "C4": sC4  = ".C4#" & sMember
							Case "C5": sC5  = ".C5#" & sMember
							Case "I" : sICP = ".I#"  & sMember
						End Select
						
						sDimsFoundInSection = sDimsFoundInSection & sDimension
					Next  'member in pov section
					
					If sWhichDimensions = "ALL" Then
						sExpressionForSection = "A#" & sAccount & sC1 & sC2 & sC3 & sC4 & sC5 & sICP & sPOVPartToAdd
						
					ElseIf sWhichDimensions = "POPULATED" Then
						'The dimensions assigned with a member will be included in the expression
						sExpressionForSection = "A#" & sAccount & sC1 & sC2 & sC3 & sC4 & sC5 & sICP & sPOVPartToAdd
						
					Else
						If sWhichDimensions = "" Then sWhichDimensions = sDimsFoundInSection
						
						sExpressionForSection = "A#" & sAccount
						If InStr(sWhichDimensions, "C1") Then	sExpressionForSection = sExpressionForSection & sC1
						If InStr(sWhichDimensions, "C2") Then	sExpressionForSection = sExpressionForSection & sC2
						If InStr(sWhichDimensions, "C3") Then	sExpressionForSection = sExpressionForSection & sC3
						If InStr(sWhichDimensions, "C4") Then	sExpressionForSection = sExpressionForSection & sC4
						If InStr(sWhichDimensions, "C5") Then	sExpressionForSection = sExpressionForSection & sC5
						If InStr(sWhichDimensions, "I")  Then	sExpressionForSection = sExpressionForSection & sICP
						
						sExpressionForSection = sExpressionForSection & sPOVPartToAdd
					End If
					
					'Replace the section with its expression form, but only the first occurrence (because it creates problem in formulas repeating the account (e.g. E330000 - E330000.OBL)
					sFullExpression = Replace(sFullExpression, sPOVSection, sExpressionForSection, 1, 1)	'replace only the first occurrence
				End If
			Next  'pov section
		End If
		
		ConvertToExpression = sFullExpression
	End Function   'ConvertToExpression
	
	Function ConvertToPOV(sFormula)
		'This function converts the formula (in UDA of a parameter) to an expression (e.g. BS8999.C5_GLLOAD to A#BS8999.C5#C5_GLLOAD).
		Dim aPOVMembers, sMember, sFullExpression, sDimension, iHashPosition
		
		If sFormula = "" Then
			sFullExpression = ""
		Else
			aPOVMembers = Split(sFormula, ".")
			
			For Each sMember In aPOVMembers
				iHashPosition = InStr(sMember, "#")
				If iHashPosition > 0 Then
					'Dimension reference is provided with the member name (this is the unlikely case)
					sDimension = Left(sMember, iHashPosition - 1)
					sMember = Mid(sMember, iHashPosition + 1)
				Else
					'Search it in the dimensions
					sDimension = WhichDimension(sMember)
				End If
				
				If sFullExpression = "" Then
					sFullExpression = sDimension & "#" & sMember
				Else
					sFullExpression = sFullExpression & "." & sDimension & "#" & sMember
				End If
			Next  'member in pov section
		End If
		
		ConvertToPOV = sFullExpression
	End Function   'ConvertToPOV
	
	Function WhichDimension(ByRef sMember)
		'This function searches the member in most of the dimensions and returns the short name of the dimension the member is found in (e.g. "C1"). Member names must be unique, not used in more than one custom dimension. There is a system validation checking this.
		Dim aCustomDimsInSearchOrder, nCustomDim
		aCustomDimsInSearchOrder = Array(1, 5, 2, 3, 4)
		sMember = Trim(UCase(sMember))
		
		Select Case sMember
			Case "", "[NONE]"
				'We can't know which dimension it is, [None] is a member in many dimensions. Return a string that will cause error so this can be noticed.
				WhichDimension = ">>>Which [None] ? <<<"
				
			Case "[ICP NONE]", "[ICP TOP]", "[ICP ENTITIES]"
				WhichDimension = "I"	'ICP
				
			Case "<EC>", "<ECA>", "<ECT>", "GBP", "GBP TOTAL", "<ENTITY CURRENCY>", "<ENTITY CURR ADJS>", "<ENTITY CURR TOTAL>", "[ELIMINATION]", "[PROPORTION]", "[CONTRIBUTION]"
				Select Case sMember
					Case "<EC>"	 : sMember = "<Entity Currency>"
					Case "<ECA>" : sMember = "<Entity Curr Adjs>"
					Case "<ECT>" : sMember = "<Entity Curr Total>"
				End Select
				
				WhichDimension = "V"	'Value
				
			Case "YTD", "PERIODIC", "QTD", "HYTD"
				WhichDimension = "W"	'View
				
			Case "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "P9", "P10", "P11", "P12"
				WhichDimension = "P"	'Period
				
			Case "PRIORYEAR", "LASTYEAR"
				sMember = "PRIOR"
				WhichDimension = "Y"	'Year
				
			Case "PRIORPERIOD", "LASTPERIOD"
				sMember = "PRIOR"
				WhichDimension = "P"	'Period
				
			Case Else
				Select Case Left(sMember, 3)
					Case "C1_" :	WhichDimension = "C1"
					Case "C2_" :	WhichDimension = "C2"
					Case "C3_" :	WhichDimension = "C3"
					Case "C4_" :	WhichDimension = "C4"
					Case "C5_" :	WhichDimension = "C5"
					
					Case Else
						For Each nCustomDim In aCustomDimsInSearchOrder
							If ExistsIn(HS.Custom("Custom" & nCustomDim).List("", "[Hierarchy]"), sMember) Then
								WhichDimension = "C" & nCustomDim	'Custom
								Exit Function
							End If
						Next  'custom dimension
						
						If ExistsIn(HS.Account.List("", "[Hierarchy]"), sMember) Then			'UPDATE NEEDED: ExistsIn may be taking a lot of time, improve performance if possible
							WhichDimension = "A"	'Account
							
						ElseIf ExistsIn(HS.Entity.List("", "[Hierarchy]"), sMember) Then		'UPDATE NEEDED: ExistsIn may be taking a lot of time, improve performance if possible
							WhichDimension = "E"	'Entity
							
						ElseIf ExistsIn(HS.Scenario.List("", "[Hierarchy]"), sMember) Then
							WhichDimension = "S"	'Scenario
							
						ElseIf ExistsIn(aYears, sMember) Then
							WhichDimension = "Y"	'Year
							
						Else
							WhichDimension = ""
						End If
				End Select
		End Select
	End Function   'WhichDimension
	
	Function GetDimensionNameOrReference(sDimNameOrRef)
		'If the dimension name is passed as the parameter, then return the dimension reference (e.g. A for Account), if dimension ref is passed then return the dimension name (e.g. Account for A)
		Dim sResult
		
		Select Case UCase(sDimNameOrRef)
			Case "SCENARIO"	: sResult = "S"
			Case "ENTITY"	: sResult = "E"
			Case "YEAR"		: sResult = "Y"
			Case "PERIOD"	: sResult = "P"
			Case "VALUE"	: sResult = "V"
			Case "VIEW"		: sResult = "W"
			Case "ACCOUNT"	: sResult = "A"
			Case "ICP"		: sResult = "I"
			Case "CUSTOM1"	: sResult = "C1"
			Case "CUSTOM2"	: sResult = "C2"
			Case "CUSTOM3"	: sResult = "C3"
			Case "CUSTOM4"	: sResult = "C4"
			Case "CUSTOM5"	: sResult = "C5"
			
			Case "S"	: sResult = "SCENARIO"
			Case "E"	: sResult = "ENTITY"
			Case "Y"	: sResult = "YEAR"
			Case "P"	: sResult = "PERIOD"
			Case "V"	: sResult = "VALUE"
			Case "W"	: sResult = "VIEW"
			Case "A"	: sResult = "ACCOUNT"
			Case "I"	: sResult = "ICP"
			Case "C1"	: sResult = "CUSTOM1"
			Case "C2"	: sResult = "CUSTOM2"
			Case "C3"	: sResult = "CUSTOM3"
			Case "C4"	: sResult = "CUSTOM4"
			Case "C5"	: sResult = "CUSTOM5"
			
			Case Else	: sResult = ""
		End Select
		
		GetDimensionNameOrReference = sResult
	End Function   'GetDimensionNameOrReference
	
	Function ClearExtraSpacesAndDelimiters(sString, sDelimitersConcatenated)
		Dim sDelimiter, i, j
		sString = Trim(sString)
		
		If sString = "" Then
			'Empty string, return it without a change
		Else
			' 1. Clear the extra spaces (double spaces)
			'--------------------------------------------
			Do While InStr(sString, "  ")
				sString = Replace(sString, "  ", " ")
			Loop
			
			If sDelimitersConcatenated = "" Then
				'No delimiter specified, return the string
			Else
				'Loop through each delimiter character listed in the parameter
				For i = 1 To Len(sDelimitersConcatenated)
					sDelimiter = Mid(sDelimitersConcatenated, i, 1)
					
					If InStr(sString, sDelimiter) Then
						
						' 2. Clear the double delimiters
						'--------------------------------------------
						' (i.e. there is nothing between two consecutive delimiters)
						If InStr("()", sDelimiter) Then
							'Don't clear double parentheses because there may be nested parentheses (e.g. ((A+B)/2) )
						Else
							Do While InStr(sString, sDelimiter & sDelimiter)
								sString = Replace(sString, sDelimiter & sDelimiter, sDelimiter)		'e.g. this will replace ",," with ","
							Loop
						End If
						
						' 3. Clear the spaces around the delimiters
						'--------------------------------------------
						Do While InStr(sString, sDelimiter & " ")
							sString = Replace(sString, sDelimiter & " ", sDelimiter)		'e.g. this will replace ", " with ","
						Loop
						
						Do While InStr(sString, " " & sDelimiter)
							sString = Replace(sString, " " & sDelimiter, sDelimiter)		'e.g. this will replace " ," with ","
						Loop
						
						If sDelimiter = ")" Then
							'Put the space back after the last parentheses if there is another parameter after it
							j = 1
							Do
								If Mid(sString, j, 1) = ")" Then
									If InStr(LETTERS & NUMBERS, Mid(sString, j + 1, 1)) Then
										'A letter or number after ), must be the next parameter - put the space back to separate the parameters
										sString = Left(sString, j) & " " & Mid(sString, j + 1)
									End If
								End If
								j = j + 1
							Loop Until j >= Len(sString)
						End If
					End If
				Next  'delimiter character
			End If
		End If
		
		ClearExtraSpacesAndDelimiters = sString
	End Function   'ClearExtraSpacesAndDelimiters
	
	Function HasAnyOfTheseCharacters(sString, sCharactersConcatenated)
		Dim sSearchChar, i

		If sString = "" Then
			'Empty string, return false (not found)
			
		ElseIf sCharactersConcatenated = "" Then
			'No characters specified, return false (not found)
			
		Else
			'Loop through each character listed in the parameter
			For i = 1 To Len(sCharactersConcatenated)
				sSearchChar = Mid(sCharactersConcatenated, i, 1)
				
				If InStr(sString, sSearchChar) Then
					'We found one of them
					HasAnyOfTheseCharacters = True
					Exit Function
				End If
			Next  'character to search
		End If
		
		HasAnyOfTheseCharacters = False
	End Function   'HasAnyOfTheseCharacters
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
	Function ExistsIn(aHaystack, sNeedle)
		'Returns TRUE if sNeedle is found in aHaystack, an array of strings
		sNeedle = UCase(Trim(sNeedle))
		Dim i, l, u
		
		If (Not IsArray(aHaystack)) Or sNeedle = "" Then
			ExistsIn = False
		Else
			l = LBound(aHaystack)
			u = UBound(aHaystack)
			
			For i = l To u
				If UCase(Trim(aHaystack(i))) = sNeedle Then
					ExistsIn = True
					Exit Function
				End If
			Next
		End If
		
		ExistsIn = False
	End Function   'ExistsIn
	
	Function DoesNotExistIn(aHaystack, sNeedle)
		DoesNotExistIn = Not ExistsIn(aHaystack, sNeedle)
	End Function   'DoesNotExistIn
	
	Function GetArrayValue(aArray, sRowHeader, sColumnHeader)
		'This function, searches the row header and column header in a two dimensional array and returns the value in the cell at the intersection of these headers.
		Dim i, iRow, iCol, bRowHeaderFound, bColumnHeaderFound, iLBoundDim1, iLBoundDim2
		bRowHeaderFound = False : bColumnHeaderFound = False
		
		If Not IsArray(aArray) Then
			GetArrayValue = "ERROR"
		Else
			iLBoundDim1 = LBound(aArray, 1) : iLBoundDim2 = LBound(aArray, 2)
				'Call WriteToDebugLog("iLBoundDim1:" & iLBoundDim1 & " iLBoundDim2:" & iLBoundDim2)
			
			'Find the row header
			For i = iLBoundDim1 To UBound(aArray, 1)
				If IsEqual(aArray(i, iLBoundDim2), sRowHeader) Then
					bRowHeaderFound = True
					iRow = i
					Exit For
				End If
			Next  'row
			
			'Find the column header
			For i = iLBoundDim2 To UBound(aArray, 2)
				If IsEqual(aArray(iLBoundDim1, i), sColumnHeader) Then
					bColumnHeaderFound = True
					iCol = i
					Exit For
				End If
			Next  'column
				
				'Call WriteToDebugLog("sRowHeader:" & sRowHeader & " sColumnHeader:" & sColumnHeader)
				'Call WriteToDebugLog("bRowHeaderFound:" & bRowHeaderFound & " bColumnHeaderFound:" & bColumnHeaderFound)
				'Call WriteToDebugLog("GetArrayValue ->  sRowHeader:" & sRowHeader & " sColumnHeader:" & sColumnHeader & "  iRow:" & iRow & " iCol:" & iCol & " RHFound:" & bRowHeaderFound & " CHFound:" & bColumnHeaderFound & " Value:" & aArray(iRow, iCol))
				
			If bRowHeaderFound And bColumnHeaderFound Then
				GetArrayValue = aArray(iRow, iCol)
			Else
				GetArrayValue = "ROW/COL HEADER NOT FOUND"
			End If
		End If
	End Function
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secA3 '   Section A3 - SET and CLEAR
		  ' ==========================================================================================================
	Sub SetPOVVariables()
		Dim sCallingCodeBlock : sCallingCodeBlock = sActiveCodeBlock : sActiveCodeBlock = "SetPOVVariables"
		
		Dim sPOVEntityPart, sPOVValuePart, sPOVValuePartShort, sUDA
		
		' Initial Checks
		' --------------
		If PRIORYEAR <> CURRENTYEAR - 1 Then Call AbortRules("INITIAL-CHECK", "Error in constant values. PRIORYEAR must equal CURRENTYEAR - 1. CURRENTYEAR:" & CURRENTYEAR & "  PRIORYEAR:" & PRIORYEAR)
		
		' POV variables assigned with current POV values
		' ---------------------------------------------------------'
		sPOVScenario 			= HS.Scenario.Member()
		sPOVEntity 				= HS.Entity.Member()
		sPOVYear 				= HS.Year.Member()
		iPOVYear 				= CInt(sPOVYear)
		sPOVPeriod 				= HS.Period.Member()
		iPOVPeriodNum 			= HS.Period.Number()
		sPOVValue 				= HS.Value.Member()
		sPOVEntityDefCurrency	= HS.Entity.DefCurrency("")
		sPOVParent 				= HS.Parent.Member()
		sPOVEntityDefParent 	= HS.Entity.DefaultParent(sPOVEntity)
		
		If IsEqual(sPOVValue, "[None]") Then
			sPOVCurrency = sPOVValue
		Else
			sPOVCurrency = HS.Value.Currency()
		End If
			
			'Call WriteToCellTextLog("iPOVYearPeriod: " & sPOVYear & Right("0" & iPOVPeriodNum, 2))
			
		iPOVYearPeriod			= CLng(sPOVYear & Right("0" & iPOVPeriodNum, 2))	'e.g. 201912
		
		' Scenario Booleans
		' -----------------
		bIsActual				= IsEqual(sPOVScenario, "Actual")
		bIsFlash				= IsEqual(sPOVScenario, "Flash")
		bIsBudget_Pre			= IsEqual(sPOVScenario, "Budget_Pre")
		bIsBudget				= IsEqual(sPOVScenario, "Budget")
		
		bIsForecast				= HS.Scenario.IsBase("Forecasts", sPOVScenario)
		bIsForecast7plus5		= IsEqual(sPOVScenario, "Forecast_P7")
		
		If bIsForecast Then
			sUDA = HS.Scenario.UD1(sPOVScenario)
			bIsForecastActualPeriod   = IsParameterValue(sUDA, "COPYACT", sPOVPeriod)
			bIsForecastForecastPeriod = Not bIsForecastActualPeriod
			
			If IsEqual(sPOVScenario, "Forecast_P11") Then
				sNextForecast = ""
			Else
				sNextForecast = Left(sPOVScenario, Len(sPOVScenario) - 1) & CStr(CInt(Right(sPOVScenario, 1)) + 1)
			End If
		Else
			bIsForecastActualPeriod   = False
			bIsForecastForecastPeriod = False
		End If
		
		' Entity Booleans
		' ---------------
		bIsNoneEntity 		= IsEqual(sPOVEntity, "[None]")
		bIsBaseEntity 		= HS.Entity.IsBase("", "") And Not bIsNoneEntity
		bIsParentEntity 	= Not bIsBaseEntity And Not bIsNoneEntity
		bIsGBPEntity 		= IsEqual(sPOVEntityDefCurrency, "GBP")
		bIsGroupEntity		= IsEqual(sPOVEntity, GROUPENTITY)
		
		sUDA				= HS.Entity.UD1(sPOVEntity)
		bIsJV				= IsParameter(sUDA, "JV")
		bIsAssociate		= IsParameter(sUDA, "ASSOCIATE")
		bIsJVorAssociate	= bIsJV Or bIsAssociate
		bIsHolding			= IsParameter(sUDA, "HOLDING")
		
		' Value Booleans
		' --------------
		bValueIsEC			= IsEqual(sPOVValue, "<Entity Currency>")
		bValueIsECA 		= IsEqual(sPOVValue, "<Entity Curr Adjs>")
		bValueIsECorECA 	= bValueIsEC Or bValueIsECA
		bValueIsTrans 		= HS.Value.IsTransCur()
		bValueIsPC			= bValueIsTrans And IsEqual(sPOVValue, sPOVCurrency)
		bValueIsNone 		= IsEqual(sPOVValue, "[None]")
		bValueIsElimination = IsEqual(sPOVValue, "[Elimination]")
		bValueIsProportion  = IsEqual(sPOVValue, "[Proportion]")
		bValueIsGBP			= IsEqual(sPOVCurrency, "GBP")
		
		' Period Booleans
		' ---------------
		bIsFirstPeriod 		= HS.Period.IsFirst() 			'P1  (Mar)
		bIsLastPeriod		= HS.Period.IsLast()  			'P12 (Feb)
		bIsHY 				= IsEqual(sPOVPeriod, "P6")		'HY: Half Year (Aug)
		bIsYE 				= IsEqual(sPOVPeriod, "P12")	'YE: Year End  (Feb)
		bIsHYorYE 			= bIsHY Or bIsYE
		bIsQtr 				= bIsHYorYE Or IsEqual(sPOVPeriod,"P3") Or IsEqual(sPOVPeriod,"P9")
		'bCutoverPeriod		= (iPOVYear = CUTOVERYEAR) And IsEqual(sPOVPeriod, CUTOVERPERIOD)
		'bCutoverPriorYearEnd = (iPOVYear = CUTOVERYEAR - 1) And bIsYE
		bBeforeCutover		= iPOVYearPeriod < CUTOVERYEARPERIOD
		bAfterCutover		= Not bBeforeCutover
		'bIsLive = (iPOVYear > FIRSTLIVEYEAR) Or (iPOVYear = FIRSTLIVEYEAR And iPOVPeriodNum >= FIRSTLIVEPERIODNUM)
		
		' Year Booleans
		' -------------
		bIsFirstYear 		= HS.Year.IsFirst()
		bIsSecondYear		= (iPOVYear = FIRSTAPPYEAR + 1)
		bIsThirdYear		= (iPOVYear = FIRSTAPPYEAR + 2)
		bIsLastYear 		= HS.Year.IsLast()
		bIsFirstYearWithOpenings = (iPOVYear = FIRSTYEAROPENINGS)				'UPDATE NEEDED - REMOVE LATER IF NOT NEEDED
		
		' Consolidation Method and Ownership
		' ----------------------------------
		If sPOVParent <> "" Then
			sPOVConsolMethod = UCase(HS.Node.Method(""))
			
			If sPOVConsolMethod = "" Then
				'Check if there is a default method set by the parent entity (DMFC: default method for children)
				sPOVConsolMethod = GetParameterValue(HS.Entity.UD2(sPOVParent), "DMFC")			'BY: REMOVE IF NOT REQUIRED !!!
			End If
			
			bIsMethodGLOBAL			= IsEqual(sPOVConsolMethod, "GLOBAL")
			bIsMethodHOLDING		= IsEqual(sPOVConsolMethod, "HOLDING")
			bIsMethodJV				= IsEqual(sPOVConsolMethod, "JV")
			bIsMethodASSOCIATE		= IsEqual(sPOVConsolMethod, "ASSOCIATE")
			bIsMethodDISCONTINUED	= IsEqual(sPOVConsolMethod, "DISCONTINUED")
			bIsMethodNOCONSOL		= IsEqual(sPOVConsolMethod, "NOCONSOL")
			bIsMethodUnknown		= Not (bIsMethodGLOBAL Or bIsMethodHOLDING Or bIsMethodJV Or bIsMethodASSOCIATE Or bIsMethodDISCONTINUED Or bIsMethodNOCONSOL)
			
			If bIsMethodUnknown Then	sPOVConsolMethod = "UNKNOWN"
		Else
			sPOVConsolMethod = ""
			
			' If bIsJVorAssociate Then											'UPDATE NEEDED: REMOVE IF NOT NEEDED
				' sDefaultParent = HS.Entity.DefaultParent(sPOVEntity)
				' dOwnershipPOWN = HS.GetCell("E#" & sDefaultParent & ".I#" & sPOVEntity & ".A#[POWN]" & NONESxI & ".V#[None]")
				' HS.Exp "A#SF9150" & ALLNONES & " = " & dOwnershipPOWN
			' End If
		End If
		
		' Other Variables
		' ---------------
		'bIsHistoricPeriod 	= (iPOVYear < CURRENTYEAR Or (iPOVYear = CURRENTYEAR And iPOVPeriodNum < CURRENTPERIOD))		'UPDATE NEEDED: REMOVE IF NOT NEEDED
		
		If sPOVParent <> "" Then
			sPOVEntityPart = sPOVParent & "." & sPOVEntity
		Else
			sPOVEntityPart = sPOVEntity
		End If
		
		bValueIsEC			= IsEqual(sPOVValue, "<Entity Currency>")
		bValueIsECA 		= IsEqual(sPOVValue, "<Entity Curr Adjs>")
		
		If bValueIsEC Then
			sPOVValuePart = "<Entity Currency>"  :  sPOVValuePartShort = "<EC>"
		ElseIf bValueIsECA Then
			sPOVValuePart = "<Entity Curr Adjs>" :  sPOVValuePartShort = "<ECA>"
		ElseIf bValueIsPC Then
			sPOVValuePart = "<Parent Currency>"  :  sPOVValuePartShort = "<PC>"
		Else
			sPOVValuePart = sPOVValue
			Select Case sPOVValue
				Case "[Elimination]" :	sPOVValuePartShort = "[Elim]"
				Case "[Proportion]"	 :	sPOVValuePartShort = "[Prop]"
				Case Else
					sPOVValuePartShort = sPOVValuePart
			End Select
		End If
		
		sProcessUnitPOV = sPOVScenario & "," & sPOVYear & "," & sPOVPeriod & "," & sPOVEntityPart & "," & sPOVValuePart & "," & sPOVCurrency
		sPUPOVshort 	= sPOVScenario & "," & sPOVYear & "," & sPOVPeriod & "," & sPOVEntityPart & "," & sPOVValuePartShort
		
		sActiveCodeBlock = sCallingCodeBlock
	End Sub   'SetPOVVariables
	
	Sub SetGlobalVariables()
		sActiveCodeBlock = "SetGlobalVariables"
		'This sub is used by all subs (including NOINPUT)
		
		' Initial Checks
		' --------------
		If PRIORYEAR <> CURRENTYEAR - 1 Then Call AbortRules("INITIAL-CHECK", "Error in constant values. PRIORYEAR must equal CURRENTYEAR - 1. CURRENTYEAR:" & CURRENTYEAR & "  PRIORYEAR:" & PRIORYEAR)
		
		bElseCaseFound = False
		
		Dim iYear, sMember, sUDA
		For iYear = FIRSTAPPYEAR To LASTAPPYEAR
			Call AddToArray(aYears, CStr(iYear))
		Next
		
		aPeriods		 = Array("P1","P2","P3","P4","P5","P6","P7","P8","P9","P10","P11","P12")
		aPeriodsExP12	 = Array("P1","P2","P3","P4","P5","P6","P7","P8","P9","P10","P11")
		aPeriodsExP1	 = Array(     "P2","P3","P4","P5","P6","P7","P8","P9","P10","P11","P12")
		aPeriodsExP6P12  = Array("P1","P2","P3","P4","P5",     "P7","P8","P9","P10","P11")
		aPeriodsExQtrs	 = Array("P1","P2",     "P4","P5",     "P7","P8",     "P10","P11")
		aP6P12			 = Array("P6","P12")
		
		If sActiveRules = "CONSOLIDATE" Then
			'---------------------------------------------------------------------------------------------------------
			'Create the C5 UDA attributes dictionary object to be used by ConsStandardTreatment
			' Set oCustom5_UDA_NOT_USED = CreateObject("Scripting.Dictionary")
			
			' For Each sMember In HS.Custom("Custom5").List("", "[Hierarchy]")
				' If oCustom5_UDA_NOT_USED.Exists(sMember) Then
					' 'already added before - skip
				' Else
					' sUDA = GetUDA("Custom5", sMember, "ALL")
					' oCustom5_UDA_NOT_USED.Add sMember, sUDA
				' End If
			' Next  'member
			
			'---------------------------------------------------------------------------------------------------------
			'Create the parameter values dictionary object to be used by GetParameterValueEfficiently		'UPDATE NEEDED: make this code smarter
			' Set oParameterValues_NOT_USED = CreateObject("Scripting.Dictionary")
			
			'---------------------------------------------------------------------------------------------------------
			'Rows/Cols for the Member Parameter Values Table:
			aParameterValues_NOT_USED(0,0) = "Member/Parameter"
			
		End If
		
	End Sub   'SetGlobalVariables
	
	Sub ClearGlobalObjects()				'BY: REMOVE IF NOT REQUIRED !!!
		sActiveCodeBlock = "ClearGlobalObjects"
		
		'Erase aAccountsProcessed
		ReDim aAccountsProcessed(0)
		'ReDim aParameterValues_NOT_USED(0,0)		'BY: giving error
		'ReDim aParameterValues_NOT_USED(100,0)		'BY: giving error
		
		Set oParameterValues_NOT_USED = Nothing
		Set oCustom5_UDA_NOT_USED = Nothing
		
	End Sub
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
	Sub SetArrayValue(aArray, sRowHeader, sColumnHeader, sValue)
		'This function, searches the row header and column header in a two dimensional array and updates the value in the cell at the intersection of these headers with the value passed in sValue.
		Dim i, iRow, iCol, bRowHeaderFound, bColumnHeaderFound, iLBoundDim1, iLBoundDim2
		bRowHeaderFound = False : bColumnHeaderFound = False
		
		If IsArray(aArray) Then
			iLBoundDim1 = LBound(aArray, 1) : iLBoundDim2 = LBound(aArray, 2)
			
			'Find the row header
			For i = iLBoundDim1 To UBound(aArray, 1)
				If IsEqual(aArray(i, iLBoundDim2), sRowHeader) Then
					bRowHeaderFound = True
					iRow = i
					Exit For
				End If
			Next  'row
			
			'Find the column header
			For i = iLBoundDim2 To UBound(aArray, 2)
				If IsEqual(aArray(iLBoundDim1, i), sColumnHeader) Then
					bColumnHeaderFound = True
					iCol = i
					Exit For
				End If
			Next  'column
			
			If bRowHeaderFound And bColumnHeaderFound Then
					'Call WriteToDebugLog("SetArrayValue ->  sRowHeader:" & sRowHeader & " sColumnHeader:" & sColumnHeader & "  iRow:" & iRow & " iCol:" & iCol & "  sValue:" & sValue)
				aArray(iRow, iCol) = sValue
			End If
		End If
	End Sub
	
	Sub AddToArray(aArray, xItem)
		Dim l, u, n
		
		If xItem = "" Then
			Exit Sub
			
		ElseIf IsArray(aArray) Then
			l = LBound(aArray)
			u = UBound(aArray)
			n = u
			'Check if array only has 1 element (u=0) and it's empty - this is the state of a dynamic-sized array when first created (with the initial ReDim aArray(0) statement). if so, we want to populate this first element; otherwise we want to re-size and add a new element on the end. if we didn't do this check, we'd end up with an unwanted empty element at the beginning of the array
			If Not (IsEmpty(aArray(u)) Or aArray(u) = "") Then
				If l = 0 Then   n = u + 1
				Redim Preserve aArray(n)
			End If
			aArray(n) = xItem
		Else
			'it is a variable, convert to array and add the item into it
			aArray = Array(xItem)
		End If
	End Sub   'AddToArray
	
	Sub AddUniqueToArray(aArray, xItem)
		If ExistsIn(aArray, xItem) Then   Exit Sub
		
		Call AddToArray(aArray, xItem)
	End Sub   'AddUniqueToArray
	
	Sub ArraySort(aArray)
		Dim i, j, u, xTemp
		
		If IsArray(aArray) Then
			u = Ubound(aArray)
			
			For i = u - 1 To 0 Step -1
				For j = 0 To i
					If aArray(j) > aArray(j + 1) Then
						xTemp = aArray(j + 1)
						aArray(j + 1) = aArray(j)
						aArray(j) = xTemp
					End If
				Next
			Next
		End If
	End Sub   'ArraySort
	
	Sub AppendArrays(aTargetArray, aArrayToAdd, sParameter)
		Dim xItem
		For Each xItem in aArrayToAdd
			If sParameter = "only unique items" Then
				Call AddUniqueToArray(aTargetArray, xItem)
			Else
				Call AddToArray(aTargetArray, xItem)
			End If
		Next
	End Sub   'AppendArrays
	
	Function IsEqual(sString1, sString2)
		'   Returns TRUE if sString1 and sString2 are the same strings (ignoring the case differences).
		IsEqual = UCase(sString1) = UCase(sString2)
	End Function   'IsEqual
	
	Function IsNotEqual(sString1, sString2)
		'   Returns TRUE if sString1 and sString2 are different strings (ignoring the case differences).
		IsNotEqual = UCase(sString1) <> UCase(sString2)
	End Function   'IsNotEqual
	
	Function BeginsWith(sString, sSubString)
		'   Returns TRUE if sString starts with sSubString (ignoring the case differences).
		BeginsWith = IsEqual(Left(sString, Len(sSubString)), sSubString)
	End Function   'BeginsWith
	
	Function EndsWith(sString, sSubString)
		'   Returns TRUE if sString ends with sSubString (ignoring the case differences).
		EndsWith = IsEqual(Right(sString, Len(sSubString)), sSubString)
	End Function   'EndsWith
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
	Function SendEmail()
		sActiveCodeBlock = "SendEmail"
		
		'  Configuration
		' ---------------
			'Create the objects required for sending email using CDO
			Set oSendEmail = CreateObject("CDO.Message")
			Set oEmailConfig = CreateObject("CDO.Configuration")
			Set oConfigFields = oEmailConfig.Fields
			
			'Set various parameters and properties of CDO object
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusing") = 2 'cdoSendUsingPort
			
			'your smtp server domain or IP address goes here such as smtp.yourdomain.com
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "127.0.0.1"
			
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = 25 'default port for email
			
			oConfigFields.Update
			oSendEmail.Configuration = oEmailConfig
			
		'  FROM, TO, CC, BCC, Reply To
		' -----------------------------
			If sSendFrom  <> "" Then  oSendEmail.From	 = sSendFrom	Else  Call AbortRules("EMAILFROM", "Missing Parameter in Rules - sSendFrom:" & sSendFrom)
			If sSendTO    <> "" Then  oSendEmail.To		 = sSendTO		Else  Call AbortRules("EMAILTO",   "Missing Parameter in Rules - sSendTo:"   & sSendTo)
			If sSendCC    <> "" Then  oSendEmail.CC		 = sSendCC
			If sSendBCC   <> "" Then  oSendEmail.BCC	 = sSendBCC
			If sReplyTo   <> "" Then  oSendEmail.ReplyTo = sReplyTo
			
		'  Subject & Message
		' -------------------
			If sSubject  <> "" Then  oSendEmail.Subject  = sSubject		Else  Call AbortRules("EMAILSUBJECT", "Missing Parameter in Rules - sSubject:" & sSubject)
			
			If sTextBody <> "" Then	 oSendEmail.TextBody = sTextBody
			If sHTMLBody <> "" Then	 oSendEmail.HTMLBody = sHTMLBody
			
			If sTextBody = "" And sHTMLBody = "" Then	Call AbortRules("EMAILBODY", "Missing Parameter in Rules - sTextBody:" & sTextBody & " - sHTMLBody:" & sHTMLBody)
			
		'  Attachment
		' ------------
				Call WriteToCellTextLog("sAttachmentFilePath:" & sAttachmentFilePath)
			If sAttachmentFilePath <> "" Then  oSendEmail.AddAttachment sAttachmentFilePath
			
		'  Send Email
		' ------------
			oSendEmail.Send
			
		'  Clear Variables
		' ---------------
			'Clear the global variables so that they are not reused incorrectly for another call to this functionn.
			sSendFrom = "" : sSendTO = "" : sSendCC = "" : sSendBCC = "" : sReplyTo = "" : sSubject = "" : sTextBody = "" : sHTMLBody = "" : sAttachmentFilePath = ""
			
		'  Clear Objects
		' ---------------
			'Set all objects to nothing after sending the email
			Set oConfigFields = Nothing
			Set oEmailConfig = Nothing
			Set oSendEmail = Nothing
		
		SendEmail = "sent"
		
		'Exit Sub
		'ErrorOccurred:
		'Call WriteToAllDebugLogs(">>> Error occurred")
		'SendEmail = "ERROR"
	End Function   'SendEmail
	
	Function Recursive(sSubOrFunction, vParameter)
		Select Case sSubOrFunction
			Case "ConsJVorAssociate"
				Call ConsJVorAssociate(vParameter)
				Recursive = ""
				
			Case Else
				'Unknown function. Make the HFM Rules abort with a message to the HFM Admin.
				Call AbortRules("ELSE-RECUR", "I am in ELSE within the If/ElseIf/Else block in Recursive() with the following parameters -> sSubOrFunction: " & sSubOrFunction & "   vParameter: " & vParameter)
		End Select
	End Function
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secD1 '   Section D1 - DEBUGGING
		  ' ==========================================================================================================
	Sub SetDebugParameters()
		Dim sComputerName
		
		sApplication = HS.ApplicationName
		
		' If Not (bDEBUG Or bTIMER) Then
			' Exit Sub       'no need to set parameters, they'll be false by default
		' End If
		
		On Error Resume Next
		nMaxDebugFileSize = MAXDEBUGFILESIZE * 1024 * 1024
		nNumberOfLinesWritten = 0
		
		sComputerName = UCase(ComputerName())
		
		Select Case sComputerName
			Case "PROD SERVER NAME ???"			'UPDATE NEEDED: server names?
				sEnvironment	 = "PROD"
				bDebugIsON		 = False   	'always turned off in PROD
				bTimerIsON		 = False   	'always turned off in PROD
				sDebugFolderPath = ""		'UPDATE NEEDED: what is the folder path?
				
			Case "OMCSBDCRXGIYPN", "OMCSBDCEGWQSFZ", "OMCSBDCTRJVXRU", "OMCSBDCXHKMRLF"
				sEnvironment	 = "PPE"
				bDebugIsON		 = False   	'always turned off in PPE
				bTimerIsON		 = False   	'always turned off in PPE
				sDebugFolderPath = ""		'UPDATE NEEDED: what is the folder path?
				
			Case "OMCSBDCPLWXHWV"
				sEnvironment	 = "SIT"
				bDebugIsON		 = False   	'always turned off in SIT
				bTimerIsON		 = False   	'always turned off in SIT
				sDebugFolderPath = ""		'UPDATE NEEDED: what is the folder path?
				
			Case "OMCSBDCDMDBULX"
				sEnvironment	 = "DEV"
				bDebugIsON		 = bDEBUG
				bTimerIsON		 = bTIMER
				'sDebugFolderPath = "\\SERVER123456\HFMShare\HFMDebug\"
				sDebugFolderPath = "D:\HFM_Files\Debug_Logs\"
				'sDebugFolderPath = ""
				
			Case Else
				sEnvironment	 = sComputerName
				bDebugIsON		 = False   	'always turned off in unknown environment
				bTimerIsON		 = False   	'always turned off in unknown environment
				sDebugFolderPath = ""
		End Select
		
		sApplication_Environment = sApplication & "_" & sEnvironment
		
		If bDebugIsON Or bTimerIsON Then
			' Dim sDay, sMonth, dDate
			' dDate = Date()
			' sDay = CStr(Day(dDate))
			' sMonth = CStr(Month(dDate))
			' If Len(sDay) = 1 Then   sDay = "0" & sDay
			' If Len(sMonth) = 1 Then   sMonth = "0" & sMonth
			' sDate = CStr(Year(Date)) & sMonth & sDay
			
			'sDebugFileName = sEnvironment & "_" & sApplication & "_" & sDate & "_" & DEBUGFILEPREFIX & "_Log.txt"
			'sTimerFileName = sEnvironment & "_" & sApplication & "_" & sDate & "_" & TIMERFILEPREFIX & "_Log.txt"
			sDebugFileName = sEnvironment & "_" & sApplication & "_" & DEBUGFILEPREFIX & "_Log.txt"
			sTimerFileName = sEnvironment & "_" & sApplication & "_" & TIMERFILEPREFIX & "_Log.txt"
			
			'name of the file to write a log for when the rules log gets deleted
			sFileDeleteLogPath = sDebugFolderPath & sEnvironment & "_DeletedFiles_Log.txt"
		End If
	End Sub   'SetDebugParameters
	
	Sub SetDebuggingTemporarilyON()
		'In case it is off. This sub should be called right before the call to WriteToDebugLog.
		bDebugSwitchWas = bDebugIsON
		bDebugIsON = True				'Temporarily switch it ON (in case it isn't on)
	End Sub   'SetDebuggingTemporarilyON
	
	Sub SetDebuggingBackToOriginalSetting()
		bDebugIsON = bDebugSwitchWas	'Switch it back to what it was
	End Sub   'SetDebuggingBackToOriginalSetting
	
	Sub WriteToDebugLog(sStringToWrite)
		If bDebugIsON Then   Call WriteToFile(sStringToWrite, sDebugFileName)
	End Sub   'WriteToDebugLog
	
	Sub WriteToAllDebugLogs(sStringToWrite)
		If bDebugIsON Then   Call WriteToFile(sStringToWrite, sDebugFileName)
		
		'Also write to CellText logs
		Call WriteToCellTextLog(sStringToWrite)
	End Sub   'WriteToDebugLog
	
	Sub WriteCurrentRuleVersion()
		'Write the version of the running rule to the current subcube as a log so that this can be traced in the future (to understand which version of the rule calculated data for which subcube)
		If RULES_VERSION > 0 Then
			HS.Exp "A#RULE_VER" & ALLNONES & " = " & RULES_VERSION
		End If
	End Sub   'WriteCurrentRuleVersion
	
	Sub WriteToTimerLog(sTextLine, nStartTime, sStartTime)
		If Not bTimerIsON Then   Exit Sub
		
		Dim nDuration, sStringToWrite, nTimer, sDelimiter
		sDelimiter = ";"
		
		nTimer = Timer()
		If nStartTime > 0 Then
			nDuration = nTimer - nStartTime
		Else
			nDuration = 0
		End If
		
		'If there is no process unit POV (e.g. noinput rules) then use comma separators to make columns in line with the other timer logs, so that when opened in excel, the columns will be in line.
		If sProcessUnitPOV = "" Then   sProcessUnitPOV = ",,,,,"
		
		'sStringToWrite = CStr(Time()) & sDelimiter & sProcessUnitPOV & sDelimiter & FormatNumber(nDuration,4) & sDelimiter & sTextLine
		sStringToWrite = sTextLine & sDelimiter & sProcessUnitPOV & sDelimiter & sStartTime & sDelimiter & CStr(Time()) & sDelimiter & FormatNumber(nDuration, 4)
		
		Call WriteToFile(sStringToWrite, sTimerFileName)
	End Sub   'WriteToTimerLog
	
	Sub WriteToFile(sWrite, sFileName)
		If nNumberOfLinesWritten > MAXDEBUGNUMBEROFLINES Then
			'Too many lines have been written already. Limit has been reached. Do not proceed.
			Exit Sub
		End If
		
		Const FORREADING = 1, FORWRITING = 2, FORAPPENDING = 8
		Dim sFilePath, oFileSys, f, nFileSize
		
		sFilePath = sDebugFolderPath & sFileName
		
		On Error Resume Next
		
		Set oFileSys = CreateObject("Scripting.FileSystemObject")
		'Set oFileWSys = oFileSys.CreateTextFile(sFilePath, True)
		'Set oFileWSys = oFileSys.GetFile(sFilePath)
		Set f = oFileSys.GetFile(sFilePath)
		nFileSize = f.Size
		Set f = Nothing
		
		'check if the log file reached the size limit
		If nFileSize > nMaxDebugFileSize Then
			Set f = oFileSys.OpenTextFile(sFileDeleteLogPath, FORAPPENDING, TRUE)
			f.WriteLine "Log file (" & sFileName & ") reached size limit of " & MAXDEBUGFILESIZE & "MB and was deleted at " & Now()
			f.Close
			Set f = Nothing
			
			'delete file because it surpassed the MAXDEBUGFILESIZE limitation we desire
			'Set f = oFileSys.DeleteFile(sFilePath)      'BY: this didn't work so commented out and added the line below - instead of deleting, recreate the file as a blank file.
			Set f = oFileSys.CreateTextFile(sFilePath, True)
			Set f = Nothing
		Else
			'continue writing to the same file because the size of the file is under the maximum size
		End If
		
		Set f = oFileSys.OpenTextFile(sFilePath, FORAPPENDING, True)
		
		If nNumberOfLinesWritten = MAXDEBUGNUMBEROFLINES Then
			f.WriteLine "  WARNING !!!"
			f.WriteLine "  The maximum number of lines (" & MAXDEBUGNUMBEROFLINES & " lines) that can be written in a single rule session has been reached."
			f.WriteLine "  Debugging is now turned off for this session."
			bDebugIsON = False
			bTimerIsON = False
		Else
			f.WriteLine sWrite
		End If
		
		nNumberOfLinesWritten = nNumberOfLinesWritten + 1
		f.Close
		Set f = Nothing
		On Error Goto 0
	End Sub   'WriteToFile
	
	Sub WriteToCellTextLog(sWrite)
		Dim sExpTargetPOVforText, sPOVforCounter, sC1C2C3combo, sC1, sC2, sC3, sNextLine, nLineNumber, sLineNumber, sWriteThisLine
		
		If sPOVScenario = "" Then
			Exit Sub   'call from input/no input rules - can't write celltext
			
		ElseIf bCELLTEXTLOG Then
			'1. Get the available line number
			sC1C2C3combo = ".C1#C1_COMB.C2#C2_COMB.C3#C3_COMB"
			'sPOVforCounter = "A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			'sPOVforCounter = "V#[None].A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			sPOVforCounter = "E#[None].V#[None].A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			sNextLine = HS.GetCellTextWithLabel(sPOVforCounter, "System")
			
			If sNextLine = "000001" Then
				'The maximum lines of logging that is allowed must have been reached so that the counter is set to 1 for the next line, clear previously written logs so that new logs aren't mixed with the old ones.
				Call OnDemand_ClearLogs
				sNextLine = "000001"
				
			ElseIf sNextLine = "" Then
				sNextLine = "000001"
			End If
			
			'2. Prepare the target POV for the line
			sC1 = Left (sNextLine, 2)
			sC2 = Mid  (sNextLine, 3, 2)
			sC3 = Right(sNextLine, 2)
			sC1C2C3combo = ".C1#C1_" & sC1 & ".C2#C2_" & sC2 & ".C3#C3_" & sC3
			nLineNumber  = (CInt(sC1) * 100) + (CInt(sC2) * 10) + CInt(sC3)
			
			'3. Write the line
			'sExpTargetPOVforText = "A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			'sExpTargetPOVforText = "V#[None].A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			sExpTargetPOVforText = "E#[None].V#[None].A#DEBUG_LINE" & sC1C2C3combo & NONESxC1C2C3
			'sWriteThisLine = Replace(sNextLine, "0", "") & "  " & sWrite
			sWriteThisLine = Right(String(3,"0") & nLineNumber, 3) & " - " & Now() & " - " & sWrite
			HS.SetCellTextWithLabel sExpTargetPOVforText, "System", sWriteThisLine
			
			'4. Calculate the next line
			nLineNumber = nLineNumber + 1  'next line
			sLineNumber = CStr(nLineNumber)
			
			If nLineNumber = MAXCELLTEXTLOGNUMBEROFLINES + 1 Then
				'The maximum lines of logging that is allowed has been reached for this Scenario x Year x Period. No more lines available, go back to 1
				sC1 = "00" : sC2 = "00" : sC3 = "01"
				
			ElseIf nLineNumber < 10 Then
				sC1 = "00"
				sC2 = "00"
				sC3 = "0" & sLineNumber
				
			ElseIf nLineNumber < 100 Then
				sC1 = "00"
				sC2 = "0" & Left (sLineNumber, 1)
				sC3 = "0" & Right(sLineNumber, 1)
				
			ElseIf nLineNumber < 1000 Then
				sC1 = "0" & Left (sLineNumber, 1)
				sC2 = "0" & Mid  (sLineNumber, 2, 1)
				sC3 = "0" & Right(sLineNumber, 1)
				
			Else
				'no more lines available, go back to 1
				sC1 = "00" : sC2 = "00" : sC3 = "01"
			End If
			
			'5. Update the counter with next line reference
			sNextLine = sC1 & sC2 & sC3
			HS.SetCellTextWithLabel sPOVforCounter, "System", sNextLine
		End If
	End Sub   'WriteToCellTextLog
	
	Sub WriteDataToLog(sPOV)
		Call WriteDataUnitToFile(HS.OpenDataUnit(sPOV), sPOV)
	End Sub   'WriteDataToLog
	
	Sub WriteDataUnitToFile(oDataUnit, sPOV)
		'UPDATE NEEDED: REMOVE IF NOT REQUIRED. Update to include C5.
		
		Dim nNumItems, i, nNumZeros, nZeroPercent
		Dim sAccount, sICP, sC1, sC2, sC3, sC4, nData
		
		Call SetDebuggingTemporarilyON()			'Temporarily switch debugging ON (in case it isn't on)
		
		Call WriteLineToDebugLog
		
		nNumItems = oDataUnit.GetNumItems
		nNumZeros = 0
		
		Call WriteToDebugLog(sProcessUnitPOV & " - Data Unit has "& CStr(nNumItems) & " items") 
		If sPOV <> "" Then
			Call WriteToDebugLog("POV: " & sPOV)
		End If
		
		For i = 0 To nNumItems - 1
			Call oDataUnit.GetItem(i, sAccount, sICP, sC1, sC2, sC3, sC4, nData)
			If nData = 0 Then   nNumZeros = nNumZeros + 1
			Call WriteToDebugLog("A#" & sAccount & ";I#" & sICP & ";C1#" & sC1 & ";C2#" & sC2 & ";C3#" & sC3 & ";C4#" & sC4 & " : " & CStr(nData))
		Next
		
		If nNumItems > 0 Then
			nZeroPercent = Round(nNumZeros/nNumItems * 100, 1)
			Call WriteToDebugLog(CStr(nNumZeros) & " zero records of " & CStr(nNumItems) & " (" & CStr(nZeroPercent) & "%)")
		End If
		
		Call WriteLineToDebugLog
		Call SetDebuggingBackToOriginalSetting	'Switch it back to what it was
		
		Set oDataUnit = Nothing
	End Sub   'WriteDataUnitToFile
	
	Sub WriteLineToDebugLog()
		Call WriteToDebugLog("---------------------------------------------------------------------------------------------")
	End Sub   'WriteLineToDebugLog
	
	Sub AbortRules(sREF, sErrorMessage)
		Dim sErrorToWrite, sReference, sProcessUnitDetail, sEmailStatus
		
		If sREF <> "" Then				sReference   = "REF:" & sREF & "  "
		If sProcessUnitPOV <> "" Then	sProcessUnitDetail = " (Process Unit POV: " & sProcessUnitPOV & ")"
		
		sErrorToWrite = ">>> " & Now() & " <<< ERROR: Rule is aborting... " & sErrorMessage & " (" & sReference & "Active Rules: " & sActiveRules & " | " & sActiveCodeBlock & ")" & sProcessUnitDetail & " >>>"
		
		Call SetDebuggingTemporarilyON
		Call WriteToAllDebugLogs(sErrorToWrite)
		Call SetDebuggingBackToOriginalSetting	'Switch it back to what it was
		
		If bNOTIFYADMINABOUTRULEABORT Then
			sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
			sSendTO    = "bulent.yildiz2@tesco.com"
			sSendCC    = "santosh.pai1@tesco.com"
			'sSendBCC  = ""
			
			sSubject = "HFM Rules Aborting in " & sEnvironment
			
			sHTMLBody = "HFM Business Rules are now being forced to abort by Sub AbortRules() with the rules reference and message to the HFM admin(s) below. <BR><BR>" & _
						"<B> REF: </B>"					& sREF 				& "<BR>" 	 & _
						"<B> Error Message: </B>"		& sErrorMessage 	& "<BR><BR>" & _
						"<B> Active Rules: </B>"		& sActiveRules 		& "<BR>" 	 & _
						"<B> Active Code Block: </B>"	& sActiveCodeBlock 	& "<BR><BR>" & _
						"<B> Process Unit: </B>"		& sProcessUnitPOV 	& "<BR><BR>" & _
						"<B> Date & Time: </B>" 		& CStr(Now()) 		& "<BR><BR>" & _
						"<B> Application: </B>"			& sApplication & " in " & sEnvironment
			sEmailStatus = SendEmail()
		End If
		
		If bABORTRULES Then
			Select Case sActiveRules
				Case "CALCULATE"	:	HS.NoInput sErrorToWrite
				Case "TRANSLATE"	:	HS.NoInput sErrorToWrite
				Case "CONSOLIDATE"	:	HS.NoInput sErrorToWrite
				Case "NOINPUT"		:	HS.Input   sErrorToWrite
				Case "INPUT"		:	HS.NoInput sErrorToWrite
				Case "DYNAMIC"		:	HS.NoInput sErrorToWrite
				Case "ON DEMAND"	:	HS.NoInput sErrorToWrite
			End Select
		End If
	End Sub   'AbortRules
	
	Function ComputerName()
		dim oNetwork
		
		On Error Resume Next
		Set oNetwork = CreateObject("WScript.Network")
		
		If Err.number <> 0 Then
			ComputerName = ""
		Else
			ComputerName = oNetwork.ComputerName
		End If
		
		Set oNetwork = Nothing
	End Function   'ComputerName
	
	Sub TEST_CODE()
		'This sub should be used to temporarily test a piece of code (e.g. a new functionn etc.)
		sActiveCodeBlock = "TEST_CODE"
		
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
		
		'========================================================================================================================================
		' sPOVScenario = HS.Scenario.Member()
		' sPOVEntity = HS.Entity.Member()
		' sPOVYear = HS.Year.Member()
		' iPOVYear = Cint(sPOVYear)
		' sPOVPeriod = HS.Period.Member()
		' iPOVPeriodNum = HS.Period.Number()
		' sPOVValue = HS.Value.Member()
		' sPOVCurrency = HS.Value.Currency()
		' sPOVEntityDefCurrency = HS.Entity.DefCurrency("")
		' sPOVParent = HS.Parent.Member()
		' bIsActual = (sPOVScenario = "Actual")
		'========================================================================================================================================
		' Call SetDebugParameters
		' Call SetGlobalVariables
		' Call SetPOVVariables
		'========================================================================================================================================
			'EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			' Dim oHyperion, sUser
			
			' Set oHyperion = CreateObject("Hyperion.HsvDSRulesOM")
			' sUser = oHyperion.GetUser
			
			' Call WriteToAllDebugLogs("sUser: " & sUser)
			' Call AbortRules("", "sUser: " & sUser)
			
		'========================================================================================================================================
			Call WriteToAllDebugLogs("TEST_CODE is running")
			
			Select Case sActiveRules
				Case "TRANSLATE", "CONSOLIDATE", "NOINPUT", "INPUT", "DYNAMIC" 		', "CALCULATE"
					'do not run the test code
					EXIT SUB
					
				Case Else
					'run the test code as an on-demand rule, triggered via a webform
					
					Call WriteToAllDebugLogs("TEST_CODE is in Case Else, sActiveRules:" & sActiveRules)
					
					Call OnDemand_TEST_CODE
			End Select
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Dim ToAddress
			Dim MessageSubject
			Dim MessageBody
			Dim MessageAttachment
			
			Dim ol, ns, newMail
			
			'ToAddress = "Yildiz, Bulent"   ' change this...
			ToAddress = "bulent.yildiz@oracle.com"   ' change this...
			MessageSubject = "TEST EMAIL BY"
			MessageBody = "Here is the test email body"
			
			'Set ol = WScript.CreateObject("Outlook.Application")
			Set ol = CreateObject("Outlook.Application")
			Set ns = ol.getNamespace("MAPI")
			ns.logon "","",true,false
			Set newMail = ol.CreateItem(olMailItem)
			newMail.Subject = MessageSubject
			newMail.Body = MessageBody & vbCrLf
			
			' validate the recipient, just in case...
			Set myRecipient = ns.CreateRecipient(ToAddress)
			myRecipient.Resolve
			If Not myRecipient.Resolved Then
				'MsgBox "unknown recipient"
				Call AbortRules("", "Unknown Recipient <" & ToAddress & ">")
			Else
				'newMail.Recipients.Add(myRecipient)
				newMail.Send
			End If
			
			Set ol = Nothing
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Dim sReference, sMessage
			
			sReference = "TEST-CODE"
			sMessage   = "Testing AbortRules()"
			
			Select Case sActiveRules
				Case "CALCULATE" 				:	'Call AbortRules(sReference, sMessage)
				Case "TRANSLATE"				:	'Call AbortRules(sReference, sMessage)
				Case "CONSOLIDATE" 				:	'Call AbortRules(sReference, sMessage)
				Case "NOINPUT"					:	'Call AbortRules(sReference, sMessage)
				Case "INPUT"					:	'Call AbortRules(sReference, sMessage)
				Case "DYNAMIC"					:	'Call AbortRules(sReference, sMessage)
			End Select
			
		'========================================================================================================================================
		' Dim outobj, mailobj    
		  ' Dim strFileText 
		  ' Dim objFileToRead    

		  ' Set outobj = CreateObject("Outlook.Application")    
		  ' Set mailobj = outobj.CreateItem(0)    
		  ' 'Set objFileToRead = CreateObject("Scripting.FileSystemObject").OpenTextFile("C:\Users\sonu\Desktop\auto\sha.txt", 1)    
		  ' 'strFileText = objFileToRead.ReadAll()
		  ' 'objFileToRead.Close
		  ' 'Set objFileToRead = Nothing    
		  ' With mailobj
			' .To = "bulent.yildiz@oracle.com"
			' .Subject = "Test Mail Subject - BY"
			' .Body = "TEST MAIL BODY - BY"
			' .Send
		  ' End With

		  ' 'Clear the memory
		  ' Set outobj = Nothing    
		  ' Set mailobj = Nothing    
		
		'========================================================================================================================================
		
		' Dim sFile, sFileName, sFolder, sDelimiter
		' Dim i
		' For i = 1 to 99
			' Call WriteToCellTextLog("Test again " & i)
		' Next
		
		' Call SetDebuggingTemporarilyON()
		' Call WriteToDebugLog("Process Unit POV: " & sProcessUnitPOV)
		' 'Switch it back to what it was
		' Call SetDebuggingBackToOriginalSetting()
		
		' Dim sUDA, sApplicability
		' Dim aResults(5,3), sResult, i, bApplicableToPOV, sCheckFor, sDimension
		' Dim aParams, sParamValue, sValuesDelimiter
		
		' sUDA = HS.Custom("Custom5").UD2("C5_TOTAL_ACT_RATE")
		' 'sApplicability = GetParameterValue(sUDA, "AppliesTo")
		' sApplicability = "Actual,Budget,P12,<EC>"
		' sCheckFor = "scenario, value, entity, period"
		' 'sCheckFor = "scenario"
		
		' 'Call WriteToDebugLog("sApplicability: " & sApplicability)
		' 'Call WriteToDebugLog("IsApplicableToPOV : " & IsApplicableToPOV(sApplicability, "Scenario"))
		
		' sCheckFor = UCase(sCheckFor) : bApplicableToPOV = True
		' If sCheckFor = "ALL" Or sCheckFor = "" Then sCheckFor = "SCENARIO, VALUE, YEAR, PERIOD, ENTITY"
		
		' Call WriteToDebugLog("sApplicability:" & sApplicability)
		' Call WriteToDebugLog("sCheckFor:" & sCheckFor)
		
		' 'Column Headers of the Results Table:
		' aResults(0,0) = "Dimension"
		' aResults(0,1) = "Needs Checking?"
		' aResults(0,2) = "A parameter found?"
		' aResults(0,3) = "Result"
		
		' 'Row Headers of the Results Table:
		' aResults(1,0) = "SCENARIO"
		' aResults(2,0) = "VALUE"
		' aResults(3,0) = "YEAR"
		' aResults(4,0) = "PERIOD"
		' aResults(5,0) = "ENTITY"
		
		' For i = 1 To 5
			' sDimension = aResults(i,0)
			' If InStr(sCheckFor, sDimension) Then
				' Call SetArrayValue(aResults, sDimension, "Needs Checking?", "YES")
				' Call SetArrayValue(aResults, sDimension, "A parameter found?", "NO")  'by default
				' Call SetArrayValue(aResults, sDimension, "Result", "FAIL")  'by default
				
					' Call WriteToDebugLog("Needs Checking? for " & sDimension & " - aResults " & i & ",1: " & aResults(i,1))
			' Else
				' Call SetArrayValue(aResults, sDimension, "Needs Checking?", "NO")
				' Call SetArrayValue(aResults, sDimension, "A parameter found?", "N/A")
				' Call SetArrayValue(aResults, sDimension, "Result", "PASS")
				
					' Call WriteToDebugLog("Needs Checking? for " & sDimension & " - aResults " & i & ",1: " & aResults(i,1))
			' End If
		' Next  'dimension in array
		
		
		' ' LOOP THROUGH MEMBERS
		' ' ====================
		' ' Loop through the members/values in parameter string (sApplicability)
			' sValuesDelimiter = ","		'delimiter separating the values of a parameter (e.g. AppliesTo:Actual,Forecast,P6,P12)
			' aParams = Split(Trim(sApplicability), sValuesDelimiter)
			
			' Dim sPOVmember
			
			' For Each sParamValue In aParams
				' sDimension = GetDimensionNameOrReference(WhichDimension(sParamValue))
				
				' If GetArrayValue(aResults, sDimension, "Needs Checking?") = "YES" Then
					' If GetArrayValue(aResults, sDimension, "Result") = "PASS" Then
						' 'Checks passed for this dimension before already - skip
					' Else
						' 'Check the parameter value against the Process Unit POV
						' Call SetArrayValue(aResults, sDimension, "A parameter found?", "YES")
							' Call WriteToDebugLog("A parameter found? for " & sDimension & " - aResults 1,2: " & aResults(1,2))
						
						' sResult = "FAIL"
						' Select Case sDimension
							' Case "SCENARIO" :  sPOVmember = sPOVScenario :	If IsEqual(sParamValue, sPOVScenario) Then	sResult = "PASS"
							' Case "VALUE"	:  sPOVmember = sPOVValue 	 :	If IsEqual(sParamValue, sPOVValue) 	 Then	sResult = "PASS"
							' Case "YEAR"		:  sPOVmember = sPOVYear 	 :	If IsEqual(sParamValue, sPOVYear) 	 Then	sResult = "PASS"
							' Case "PERIOD"	:  sPOVmember = sPOVPeriod   :	If IsEqual(sParamValue, sPOVPeriod)	 Then	sResult = "PASS"
							' Case "ENTITY"	:  sPOVmember = sPOVEntity   :	If IsEqual(sParamValue, sPOVEntity)	 Then	sResult = "PASS"
						' End Select
							' Call WriteToDebugLog("Parameter for " & sDimension & " sParamValue:" & sParamValue & " sPOVmember:" & sPOVmember)
							
						' Call SetArrayValue(aResults, sDimension, "Result", sResult)
							' Call WriteToDebugLog("Result for " & sDimension & " - " & sResult)
					' End If
				' Else
					' 'The dimension this member (in parameter value) is in doesn't need to be checked - skip
				' End If
			' Next  'parameter value
			
		' ' CHECK RESULTS
		' ' =============
			' Dim j,k, sRowPrint
			' For i = 1 To 5
				' sDimension = aResults(i,0)
					' 'Call WriteToDebugLog("GetArrayValue Needs Checking? : " & GetArrayValue(aResults, sDimension, "Needs Checking?"))
					' 'Call WriteToDebugLog("A parameter found? : " & GetArrayValue(aResults, sDimension, "A parameter found?"))
					
				' If GetArrayValue(aResults, sDimension, "Needs Checking?") = "YES" Then
					' If GetArrayValue(aResults, sDimension, "A parameter found?") = "YES" Then
						' If GetArrayValue(aResults, sDimension, "Result") = "PASS" Then
							' 'POV checks passed for this dimension
							' bApplicableToPOV = True
								' Call WriteToDebugLog("sDimension:" & sDimension & " - bApplicableToPOV = True")
						' Else
							' 'POV checks failed for this dimension, no need to check further, make it a fail
							' bApplicableToPOV = False
								' Call WriteToDebugLog("sDimension:" & sDimension & " GetArrayValue Result: " & GetArrayValue(aResults, sDimension, "Result"))
								' Call WriteToDebugLog("Result for " & sDimension & " - aResults " & i & ",3: " & aResults(i,3))
								' Call WriteToDebugLog("sDimension:" & sDimension & " - bApplicableToPOV = False")
								
									' Call WriteToDebugLog("ARRAY PRINT - aResults")
									' For j = LBound(aResults, 1) To UBound(aResults, 1)
										' For k = LBound(aResults, 2) To UBound(aResults, 2)
											' sRowPrint = sRowPrint & aResults(j,k) & ", "
										' Next  'col
										
										' Call WriteToDebugLog("ARRAY PRINT Row " & j & " - " & sRowPrint)
										' sRowPrint = ""
									' Next  'row
									
							' Exit For
						' End If
					' Else
						' 'No parameter value found for this dimension, which means no restrictions apply for it - skip
						' Call WriteToDebugLog("sDimension:" & sDimension & " - No parameter value found")
					' End If
				' Else
					' 'This dimension doesn't need to be checked - skip
					' Call WriteToDebugLog("sDimension:" & sDimension & " - This dimension doesn't need to be checked")
				' End If
			' Next  'dimension in array
		'========================================================================================================================================
	End Sub   'TEST_CODE
	
	Sub OnDemand_TEST_CODE()
		'This sub should be used to temporarily test a piece of code (e.g. a new functionn etc.)
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_TEST_CODE"
		
		Dim i, j, iNumberOfIterations, bExecute
		
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
		'	EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
		
		'========================================================================================================================================
			Call SetDebugParameters
			Call SetGlobalVariables
			Call SetPOVVariables
			
			Call WriteToAllDebugLogs("OnDemand_TEST_CODE is running... ")
			'Call WriteToCellTextLog("ApplicationName:" & sApplication)
		'========================================================================================================================================
			bExecute = TRUE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			Dim sEmailStatus
			
			Call WriteToFile("TEST SEND EMAIL WITH ATTACHMENT  " & CStr(Now()), sDebugFileName)
			
			If bExecute Then
				sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
				sSendTO    = "bulent.yildiz2@tesco.com"
				'sSendCC    = ""
				'sSendBCC  = ""
				
				sSubject = "TEST SEND EMAIL WITH ATTACHMENT"
				
				sHTMLBody = "TEST SEND EMAIL WITH ATTACHMENT <BR><BR>" & _
							"<B> Active Rules: </B>"		& sActiveRules 		& "<BR>" 	 & _
							"<B> Active Code Block: </B>"	& sActiveCodeBlock 	& "<BR><BR>" & _
							"<B> Process Unit: </B>"		& sProcessUnitPOV 	& "<BR><BR>" & _
							"<B> Date & Time: </B>" 		& CStr(Now()) 		& "<BR><BR>" & _
							"<B> Application: </B>"			& sApplication & " in " & sEnvironment
				
				sAttachmentFilePath = sDebugFolderPath & sDebugFileName
				
				sEmailStatus = SendEmail()
			End If
		'========================================================================================================================================
			bExecute = FALSE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			Dim sParameterValue, sSourcePOV, sExpSourcePOV, sTargetPOV, sExpTargetPOV, sExpTargetPOVforDifference, sAccount, dBalance, dInputData, aParamSections, sParamSection
			Dim iEqualSignPos, sYear, aParametricCalcAccs, sApplicability, sExceptions, sUDA, sUDA3, bApplicableToPOV, sSourceValue
			
			If bExecute Then					' >>>  LOOP FOR ONE ACCOUNT  <<<
				sSourceValue = sValueECT
				
				iNumberOfIterations = 10000
				
				'sAccount = "KP2721"			'CALC: BS1760 + BS1900 + BB1875 + BB2221 + BB2222 + BB2223 + BB2411 + BB2415 + BB2417 + BS2500 + BS2800 + BS2850 + BB2841 + BS3390 + BS3600 + BS3700
				sAccount = "CB1220_05"		'CALC: - BB4551.C1_1168
				
				sUDA = HS.Account.UD1(sAccount)
				bApplicableToPOV = True
				
				Call WriteToAllDebugLogs("ConvertToExpression LOOP started for " & sAccount & " - Number of Iterations: " & iNumberOfIterations)
				
				For i = 1 to iNumberOfIterations
					If bApplicableToPOV Then
						sParameterValue = GetParameterValue(sUDA, "CALC")
						If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
							'Extra parentheses, remove them.
							sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
						End If
						
						aParamSections = Split(sParameterValue, ",")
						
						For Each sParamSection In aParamSections
							iEqualSignPos = InStr(sParamSection, "=")
							If iEqualSignPos > 0 Then
								'There is custom member(s) specified as the target POV on the left side of the =
								sTargetPOV = Left(sParamSection, iEqualSignPos - 1)
								sSourcePOV = Mid(sParamSection, iEqualSignPos + 1)
								
								If Not BeginsWith(sTargetPOV, sAccount) Then
									'The account itself is not included in the target POV part. Let's add it to the beginning of it.
									sTargetPOV = sAccount & "." & sTargetPOV
								End If
							Else
								'Whole parameter section is for source pov - target is the account itself (for all its valid custom members)
								sTargetPOV = sAccount
								sSourcePOV = sParamSection
							End If
							
							sExpTargetPOV = ConvertToExpression(sTargetPOV, sAccount, "NONES FOR UNUSED DIMENSIONS", "C5#C5_MANINP", "ALL", "")
							sExpSourcePOV = ConvertToExpression(sSourcePOV, sAccount, "TOPS EXCLUDING SAME ANALYSIS", "C5#C5_TOP", "ALL", sSourceValue)
							
							'Call WriteToAllDebugLogs("HS.Exp " & sExpTargetPOV & " = " & sExpSourcePOV)
						Next  'section in parameter value
					End If  'account is applicable to the pov
				Next  'i
				
				Call WriteToAllDebugLogs("ConvertToExpression LOOP ended for " & sAccount & " - Number of Iterations: " & i)
			End If
		'========================================================================================================================================
			bExecute = FALSE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			If bExecute Then					' >>>  LOOP WITH CELL TEXT METHOD  <<<
				sSourceValue = sValueECT
				bApplicableToPOV = True
				
				iNumberOfIterations = 10000
				
				sAccount = "CB1010"
				
				Call WriteToAllDebugLogs("CELL TEXT METHOD LOOP started for " & sAccount & " - Number of Iterations: " & iNumberOfIterations)
				
				For i = 1 to iNumberOfIterations
					If bApplicableToPOV Then
						'Cell Text in : Actual 2018 P1 YTD [None] <Entity Curr Total> CB1010 [ICP Top] C1_TOP C2_TOP C3_TOP C4_TOP C5_TOP
						sExpTargetPOV = HS.GetCellTextWithLabel("Y#2018.P#P1.E#[None].V#[None].A#CB1010" & ALLTOPS, "System")
						
						'Call WriteToAllDebugLogs("HS.Exp " & sExpTargetPOV & " = " & sExpSourcePOV)
					End If  'account is applicable to the pov
				Next  'i
				
				Call WriteToAllDebugLogs("CELL TEXT METHOD LOOP ended for " & sAccount & " - Number of Iterations: " & i)
			End If
		
	End Sub   'OnDemand_TEST_CODE
	
	Sub OnDemand_EmailDebugLog()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_EmailDebugLog"
		
		Dim sEmailStatus
		
		sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
		sSendTO    = "bulent.yildiz2@tesco.com"
		sSendCC    = "santosh.pai1@tesco.com"
		'sSendBCC  = ""
		
		sSubject = "HFM Rules Debug Log"
		
		sHTMLBody = "Please find HFM Rules Debug Log file attached <BR><BR>" & _
					"<B> File Path: </B>"		& sAttachmentFilePath	& "<BR>" & _
					"<B> Date & Time: </B>" 	& CStr(Now()) 			& "<BR>" & _
					"<B> Application: </B>"		& sApplication & " in " & sEnvironment
		
		sAttachmentFilePath = sDebugFolderPath & sDebugFileName
		
		sEmailStatus = SendEmail()
	End Sub   'OnDemand_EmailDebugLog
	
	Sub OnDemand_EmailTimerLog()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_EmailTimerLog"
		
		Dim sEmailStatus
		
		sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
		sSendTO    = "bulent.yildiz2@tesco.com"
		sSendCC    = "santosh.pai1@tesco.com"
		'sSendBCC  = ""
		
		sSubject = "HFM Rules Timer Log"
		
		sHTMLBody = "Please find HFM Rules Timer Log file attached <BR><BR>" & _
					"<B> File Path: </B>"		& sAttachmentFilePath	& "<BR>" & _
					"<B> Date & Time: </B>" 	& CStr(Now()) 			& "<BR>" & _
					"<B> Application: </B>"		& sApplication & " in " & sEnvironment
		
		sAttachmentFilePath = sDebugFolderPath & sTimerFileName
		
		sEmailStatus = SendEmail()
	End Sub   'OnDemand_EmailTimerLog
	
	Sub OnDemand_ClearLogs()
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_ClearLogs"
		
		Dim oCellTextUnit, nNumItems, i, CTURecord, sCellTextLabel
		sCellTextLabel = "System"
		
		Set oCellTextUnit = HS.OpenCellTextUnit("E#[None].V#[None].A#DEBUG_LINE", sCellTextLabel, "", "")
		nNumItems = oCellTextUnit.GetNumItems
		
		If nNumItems > 0 Then
			For i = 0 To nNumItems - 1
				Set CTURecord = oCellTextUnit.Item(i)
					'Call WriteToDebugLog(CTURecord.POV & ": " & CTURecord.Label & ": " & CTURecord.CellText)
				HS.SetCellTextWithLabel CTURecord.POV, sCellTextLabel, ""
				Set CTURecord = Nothing
			Next
		End If
		
		Set oCellTextUnit = Nothing
	End Sub   'OnDemand_ClearLogs
	
	
	'Sub _________________________    End Sub		'separator for notepad++ add-in
	
	
dim secD2 '   Section D2 - Debugging HS Commands
		  ' ==========================================================================================================
		 'These sub-routines have been added to be used instead of the standard HFM functions to make debugging much easier.
	Sub HS_NoInput(sPOVExpression)
		Call WriteToAllDebugLogs("HS.NoInput """ & sPOVExpression & """")
		
		HS.NoInput sPOVExpression
	End Sub
	
	Sub HS_Input(sPOVExpression)
		Call WriteToAllDebugLogs("HS.Input """ & sPOVExpression & """")
		
		HS.Input sPOVExpression
	End Sub
	
	Sub HS_Clear(sPOVExpression)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.Clear """ & sPOVExpression & """")
		
		HS.Clear sPOVExpression
	End Sub
	
	Sub HS_Exp(sExpression)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.Exp """ & sExpression & """")
		
		HS.Exp sExpression
	End Sub
	
	Sub HS_Con(sDestPOV, nFactor, sNature)
		'On Error GoTo ErrorOccurred
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.Con """ & sDestPOV & """, " & nFactor & ", """ & sNature & """")
		
		HS.Con sDestPOV, nFactor, sNature
		
		'Exit Sub
		'ErrorOccurred:
		''Call WriteToAllDebugLogs(">>> Error occurred trying to execute the code below:" & vbCrlf & vbTab & sPUPOVshort & "   HS.Con " & sDestPOV & ", " & nFactor & ", " & sNature)
	End Sub
	
	Sub HS_Con2(sDestPOV, nFactor, sNature)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.Con """ & sDestPOV & """, " & nFactor & ", """ & sNature & """" & vbTab & vbTab & sDataWithPOV)
		
		HS.Con sDestPOV, nFactor, sNature
	End Sub
	
	Sub HS_Trans(sDestPOV, sSourcePOV, nRate1, nRate2)
		Dim sRate1, sRate2
		sRate1 = CStr(nRate1)
		sRate2 = CStr(nRate2)
		
		If sRate1 = "" Then
			sRate1 = """"""
		ElseIf nRate1 <> 0 Then
			sRate1 = sRate1 & "(" & CStr(1 / nRate1) & ")"
		End If
		
		If sRate2 = "" Then
			sRate2 = """"""
		ElseIf nRate2 <> 0 Then
			sRate2 = sRate2 & "(" & CStr(1 / nRate2) & ")"
		End If
		
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.Trans """ & sDestPOV & """, """ & sSourcePOV & """, " & sRate1 & ", " & sRate2)
		
		HS.Trans sDestPOV, sSourcePOV, nRate1, nRate2
	End Sub
	
	Sub HS_TransPeriodic(sDestPOV, sSourcePOV, nRate1, nRate2)
		Dim sRate1, sRate2
		sRate1 = CStr(nRate1)
		sRate2 = CStr(nRate2)
		
		If sRate1 = "" Then
			sRate1 = """"""
		ElseIf nRate1 <> 0 Then
			sRate1 = sRate1 & "(" & CStr(1 / nRate1) & ")"
		End If
		
		If sRate2 = "" Then
			sRate2 = """"""
		ElseIf nRate2 <> 0 Then
			sRate2 = sRate2 & "(" & CStr(1 / nRate2) & ")"
		End If
		
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.TransPeriodic """ & sDestPOV & """, """ & sSourcePOV & """, " & sRate1 & ", " & sRate2)
		
		HS.TransPeriodic sDestPOV, sSourcePOV, nRate1, nRate2
	End Sub
	
	Sub HS_ImpactStatus(sPOVExpression)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.ImpactStatus """ & sPOVExpression & """")
		
		HS.ImpactStatus sPOVExpression
	End Sub
	
	Sub HS_SetDataWithPOV(sDestPOV, dData, bAddToExistingData)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.SetDataWithPOV """ & sDestPOV & """, " & dData & ", " & bAddToExistingData)
		
		HS.SetDataWithPOV sDestPOV, dData, bAddToExistingData
	End Sub
	
	Sub HS_SetCellTextWithLabel(sPOVExpression, sCellTextLabel, sCellTextString)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.SetCellTextWithLabel """ & sPOVExpression & """, """ & sCellTextLabel & """, """ & sCellTextString & """")
		
		HS.SetCellTextWithLabel sPOVExpression, sCellTextLabel, sCellTextString
	End Sub
	
	
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
	Function HS_GetCell(sPOVExpression)
		Dim dData
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.GetCell(""" & sPOVExpression & """) >>> see with data below")
		
		dData = HS.GetCell(sPOVExpression)
		
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.GetCell("".........."")" & vbTab & vbTab & " -> DATA: " & dData)
		
		HS_GetCell = dData
	End Function
	
	Function HS_GetCellRealData(sPOVExpression, ByRef bIsRealData)
		Dim dData
		dData = HS.GetCellRealData(sPOVExpression, bIsRealData)
		
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.GetCellRealData(""" & sPOVExpression & """, bIsRealData) " & vbTab & vbTab & " -> DATA: " & dData & vbTab & "  Real?: " & CStr(bIsRealData))
		
		HS_GetCellRealData = dData
	End Function
	
	Function HS_GetRate(sPOVExpression)
		Dim dData, nRateForLog, nRateInReverse, sAdditionalInfo
		dData			= HS.GetRate(sPOVExpression)
		'nRateForLog = Round(dData, 4)
		nRateForLog		= dData
		If dData <> 0 Then   nRateInReverse	= 1 / dData
		sAdditionalInfo = "    ->  From: " & sPOVEntityDefCurrency & "  To: " & sPOVCurrency & "  RATE: " & nRateForLog & " (" & nRateInReverse & ")"
		
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.GetRate(""" & sPOVExpression & """) " & vbTab & vbTab & sAdditionalInfo)
		
		HS_GetRate = dData
	End Function
	
	Function HS_CalcStatus(sPOVExpression)
		Dim sCalcStatus
		sCalcStatus = HS.CalcStatus(sPOVExpression)
		Call WriteToAllDebugLogs(sPUPOVshort & "   HS.CalcStatus(""" & sPOVExpression & """) " & vbTab & vbTab & " -> Calc Status: " & sCalcStatus)
		
		HS_CalcStatus = sCalcStatus
	End Function
	
	
	'Sub 	  _________________________    End Sub			'separator for notepad++ add-in
	'Function _________________________    End Function		'separator for notepad++ add-in
	
	
dim secD3 '   Section D3 - Temporary versions of the subs and functions being debugged 
		  ' ==========================================================================================================
	
	
dim secE1 '   Section E1 - Temporary Rules for Data Migration and Reconciliations
		  ' ==========================================================================================================
	Sub CalcDataMigrationRelated(sWhatToDo)
		sActiveCodeBlock = "CalcDataMigrationRelated"
		
		'This sub has been added for data migration only, to calculate MVCALC also at C5_GCS for parent entities (C5_GCS is used for reconciliations)
		Dim sSourceBalance, sC5
		
		Select Case sWhatToDo
			Case "Calculate MVCALC for Adjustments"				'KEEP THIS - needed for Historic (DM) Periods.
				'Balance sheet calculated movement
				'MVCALC:[C1_9998 Movement Calculated]
				'CBLOAD:[C1_9999 Closing Balance Load]
				'OBTOT: [C1_M000 Opening balance Total]
				'MVATOT:[C1_M110 Movement Analysis]
				'FXTOT: [C1_M200 Foreign currency translation]
				'[C5_GLLOAD GL Load], [C5_GCS GCS Parent Entity Data (<EC>)]
				'BY: UPDATE NEEDED for Custom 5 !!!
				If bIsBaseEntity And bValueIsEC Then
					For Each sC5 In Array("C5_LOCADJ", "C5_FVADJ", "C5_SYNADJ", "C5_SEGADJ", "C5_GRPADJ", "C5_EXCEPT", "C5_P13ADJ", "C5_P14ADJ")
						HS.Clear "C1#" & MVCALC & ".C5#" & sC5
						HS.Exp "C1#" & MVCALC & ".C5#" & sC5 & " = C1#" & CBLOAD & ".C5#" & sC5 & " - C1#" & OBTOT & ".C5#" & sC5 & " - C1#" & MVATOT & ".C5#" & sC5 & " - C1#" & FXTOT & ".C5#" & sC5
					Next
				End If
				
			Case "Calculate MVCALC for Temporary Members"				'UPDATE NEEDED: REMOVE LATER (needed only for DM Reconciliation members)
				'Balance sheet calculated movement
				'MVCALC:[C1_9998 Movement Calculated]
				'CBLOAD:[C1_9999 Closing Balance Load]
				'OBTOT: [C1_M000 Opening balance Total]
				'MVATOT:[C1_M110 Movement Analysis]
				'FXTOT: [C1_M200 Foreign currency translation]
				'[C5_GLLOAD GL Load], [C5_GCS GCS Parent Entity Data (<EC>)]
				'BY: UPDATE NEEDED for Custom 5 !!!
				If bValueIsEC Then
					If bIsBaseEntity Then
						For Each sC5 In Array("C5_GCS_GBP", "C5_GCS_ACT_RATE", "C5_GCS_BUD_RATE")
							HS.Clear "C1#" & MVCALC & ".C5#" & sC5
							HS.Exp "C1#" & MVCALC & ".C5#" & sC5 & " = C1#" & CBLOAD & ".C5#" & sC5 & " - C1#" & OBTOT & ".C5#" & sC5 & " - C1#" & MVATOT & ".C5#" & sC5 & " - C1#" & FXTOT & ".C5#" & sC5
						Next
						
					ElseIf bIsParentEntity Then
						sC5 = "C5_GCS"
						HS.Clear "C1#" & MVCALC & ".C5#" & sC5
						HS.Exp "C1#" & MVCALC & ".C5#" & sC5 & " = C1#" & CBLOAD & ".C5#" & sC5 & " - C1#" & OBTOT & ".C5#" & sC5 & " - C1#" & MVATOT & ".C5#" & sC5 & " - C1#" & FXTOT & ".C5#" & sC5
					End If
				End If
		End Select
		
	End Sub   'CalcDataMigrationRelated
	
	Sub ImpactCalcStatus_Temp_ForDM()						'UPDATE NEEDED: REMOVE LATER (needed only for DM apps to 	help with performance)
		sActiveCodeBlock = "ImpactCalcStatus_Temp_ForDM"
		
		Dim i
		
		If bIsNoneEntity And bValueIsNone Then
			If bIsLastPeriod Then
				'If last period is being calculated 	-> next year's first period is impacted
				'If iPOVYear <= 2018 Then
				'	HS.ImpactStatus "Y#NEXT.P#LAST"		'temporary - skipping P1 to P11 as these periods don't have data currently.
				'Else
					HS.ImpactStatus "Y#NEXT.P#FIRST"
				'End If
			End If
			
		ElseIf bValueIsECorECA Then
			If bIsActual And bIsLastPeriod Then
				'If iPOVYear <= 2018 Then
				'	HS.ImpactStatus "Y#NEXT.P#LAST"		'temporary - skipping P1 to P11 as these periods don't have data currently.
				'Else
					HS.ImpactStatus "Y#NEXT.P#FIRST"
				'End If
				
				If bValueIsECA Then
					'Impact <EC> next year as well, so the updated <ECT> closing balance can be pulled into <EC> opening balance next year.
					'If iPOVYear <= 2018 Then
					'	HS.ImpactStatus "Y#NEXT.P#LAST"	& sValueEC		'temporary - skipping P1 to P11 as these periods don't have data currently.
					'Else
						HS.ImpactStatus "Y#NEXT.P#FIRST" & sValueEC
					'End If
				End If
			End If
			
			' If bIsActual Then
				' 'Impact the Forecast scenarios for the Actual part
				' For i = iPOVPeriodNum To 11
					' HS.ImpactStatus "S#Forecast_P" & i
				' Next  'period
				
			' ElseIf bIsForecast7plus5 Then			'UPDATE NEEDED: this should be made parametric so that if they need to they can pull closing balances from a different Forecast scenario into Budget Opening B.
				' 'Impact the Budget scenario next year (Budget opening balance are pulled from Forecast_P7 scenario). UPDATE NEEDED: Do we need to impact any other budget scenario?
				' If bIsLastPeriod Then
					' HS.ImpactStatus "S#Budget_W.Y#NEXT.P#FIRST"
					
					' If bValueIsECA Then
						' 'Impact <EC> next year as well, so the updated <ECT> closing balance can be pulled into <EC> opening balance next year.
						' HS.ImpactStatus "S#Budget_W.Y#NEXT.P#FIRST" & sValueEC
					' End If
				' End If
			' End If
			
		' ElseIf bValueIsTrans Then
			' If bIsActual And bIsLastPeriod Then		HS.ImpactStatus "Y#NEXT.P#FIRST"		'UPDATE NEEDED: do we need these impact rules? if an alternate entity hierarchy is added, we may need.
			
		' ElseIf bValueIsProportion Then
			' If bIsActual And bIsLastPeriod Then		HS.ImpactStatus "Y#NEXT.P#FIRST"		'UPDATE NEEDED: do we need these impact rules? if an alternate entity hierarchy is added, we may need.
			
		' ElseIf bValueIsElimination Then
			' If bIsActual And bIsLastPeriod Then		HS.ImpactStatus "Y#NEXT.P#FIRST"		'UPDATE NEEDED: do we need these impact rules? if an alternate entity hierarchy is added, we may need.
			
		End If
	End Sub   'ImpactCalcStatus_Temp_ForDM
	
	
dim secE2 '   Section E2 - Subs and Functions That Are Not Used
		  ' ==========================================================================================================
	Sub TransFXTranslationReserve_NOT_USED()
		Dim sFX, sAccount, sTargetPOV, sSourcePOV
		
		'Move FX calculated on the accounts that need to feed the CTR to CTR
		'FXTOT:[C1_M200 Foreign currency translation], CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated]
		For Each sFX In HS.Custom("Custom1").List(FXTOT, "[Base]")
			HS.Clear "A#" & CTR & ".C1#" & sFX		'UPDATE NEEDED: added this, but may remove later. shouldn't be needed as it is calculated:Y
			
			For Each sAccount In HS.Account.List("", "A_AccountsForCTR")
				'Move FX from the account to CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated]
				'If HS.Account.IsICP(sAccount) Then
				sTargetPOV = "A#" & CTR 	 & ".C1#" & sFX & ".C2#C2_" & sAccount
				sSourcePOV = "A#" & sAccount & ".C1#" & sFX & ".C2#C2_TOP"
				
				HS.Exp sTargetPOV & " = " & sSourcePOV
				
				'Clear FX from the account
				HS.Clear "A#" & sAccount & ".C1#" & sFX
			Next  'account feeding CTR
		Next  'fx member
	End Sub   'TransFXTranslationReserve_NOT_USED
	
	Sub TransHistoricForAlternateRates_NOT_USED(sWhichBalances)						'UPDATE NEEDED: for CTR on MI
		sActiveCodeBlock = "TransHistoricForAlternateRates_NOT_USED"
		
		'All opening balances are translated at opening rate, and movements at average rate by default and these are retranslated at historic rates if those rates exists (i.e. input by the user), but if not then the standard translation is kept.
		
		Dim nAlternateOpeningRate, nAlternateClosingRate, nAlternateAverageRate, nHistoricOpeningRate, nSpotRate, sRateAccountPrefix, sRateAccount, bOneRate, nAlternateRate, nAlternateClosingRatePriorMonth
		Dim sReTransGroup, sReTransMember, aReTransMembers, sApplicability, sExceptions, dEntityCurr, dTransCurr, nHistoricOpeningForAlternateRate
		Dim sUD1, sUD3, sHistAccount, sHistMovements, aHistMovements, sHistMovement, sHistFX, sSourcePOV, sTargetPOV, sTranslatedAtSpotRate, aHistAccounts, sMovement, sC1TopMember, sTargetICP, bFXonCTR, sClearedFXAVGfor
		
		'[C5_TRANS Translations at Reporting Rates]
		For Each sReTransGroup In HS.Custom("Custom5").List("C5_TRANS", "[Children]")
			
			' CHECK APPLICABILITY
			' -------------------
			sUD1 = HS.Custom("Custom5").UD1(sReTransGroup)
			sUD3 = HS.Custom("Custom5").UD3(sReTransGroup)
			sApplicability = GetParameterValue(sUD3, "AppliesTo")
			sExceptions    = GetParameterValue(sUD3, "NotAppliesTo")
			
			If IsApplicableToPOV(sApplicability, sExceptions, "Scenario") And IsParameterValue(sUD1, "ACCS", "BS") Then			'UPDATE NEEDED: it may be worth to add period condition in case they want to retranslate only one period (e.g. P12) at a different rate
				
				' GET RATES
				' ---------
				sTranslatedAtSpotRate = "": nAlternateClosingRatePriorMonth = 0		': nAlternateClosingRatePriorYear = 0
				bOneRate = IsParameter(sUD1, "RATE")
				
				If bOneRate Then
					'One rate account - get the rate
					sRateAccount = GetParameterValue(sUD1, "RATE")
					nAlternateRate = HS.GetRate("A#" & sRateAccount)
					
					nAlternateOpeningRate = nAlternateRate
					nAlternateAverageRate = nAlternateRate
					nAlternateClosingRate = nAlternateRate
					
					' If Not bIsFirstYear Then
						' nAlternateClosingRatePriorYear = HS.GetRate("A#" & sRateAccount & ".Y#PRIOR.P#LAST")			'UPDATE NEEDED: remove if not needed
					' End If
					
					If Not bIsFirstPeriod Then
						nAlternateClosingRatePriorMonth = HS.GetRate("A#" & sRateAccount & ".P#PRIOR")
					End If
					
				Else
					'Three rate accounts: opening, average and closing
					sRateAccountPrefix = GetParameterValue(sUD1, "RATEPREFIX")
					
					nAlternateOpeningRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & OPENINGRATE)
					nAlternateAverageRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & AVERAGERATE)
					nAlternateClosingRate = HS.GetRate("A#" & sRateAccountPrefix & "_" & CLOSINGRATE)
					
					' If Not bIsFirstYear Then
						' nAlternateClosingRatePriorYear = HS.GetRate("A#" & sRateAccountPrefix & "_" & CLOSINGRATE & ".Y#PRIOR.P#LAST")			'UPDATE NEEDED: remove if not needed
					' End If
					
					If Not bIsFirstPeriod Then
						nAlternateClosingRatePriorMonth = HS.GetRate("A#" & sRateAccountPrefix & "_" & CLOSINGRATE & ".P#PRIOR")
					End If
				End If
				
				
				' LOOP: C5 TRANSLATION MEMBERS
				' ----------------------------
				If HS.Custom("Custom5").IsBase("", sReTransGroup) Then
					'Not a hierarhcy but a single member
					aReTransMembers = Array(sReTransGroup)
				Else
					aReTransMembers = HS.Custom("Custom5").List(sReTransGroup, "[Base]")
				End If
				
				'Loop through the members of C5_TRANS to avoid retranslating [C5_TOTAL Total Published] members at the restated rates
				For Each sReTransMember In aReTransMembers
					
					' ======================
					'  OPENING BALANCE & FX
					' ======================
						For Each sRateAccount In HS.Account.List("HISTORIC_RATES", "[Base]")
							nHistoricOpeningForAlternateRate = 0: dEntityCurr = 0: dTransCurr = 0
							
							' GET THE HISTORIC RATE
							' ---------------------
							'Formula: Historic Opening Rate = Prior year-end blended closing rate (<PC>.BBxxxx.C1_T000.YTD / <EC>.BBxxxx.C1_T000.YTD)
							sUD1 = Trim(HS.Account.UD1(sRateAccount))
							
							' Historic Opening Rate
							' ---------------------
							nHistoricOpeningRate = HS.GetRate("A#" & sRateAccount)
							
							If nHistoricOpeningRate = 0 Or sUD1 = "" Then
								'Parameters not defined and/or no historic rate exists - skip to the next rate account
							Else
								sHistAccount   = GetParameterValue(sUD1, "ACC")
								sHistMovements = GetParameterValue(sUD1, "MVT")
								aHistMovements = Split(sHistMovements, ",")
								
								bFXonCTR = IsParameter(HS.Account.UD1(sHistAccount), "FXCTR")										'UPDATE NEEDED: The updates done on 20190321 must be replicated here for CTR on Minority to work.
								If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""   Else   sTargetICP = ".I#[ICP None]"
								
								' Blended Opening Rate
								' --------------------
									'Calculate blended historic rate for this restated rate (C5)
									If Not bIsFirstYear Then
										dEntityCurr = HS.GetCell("A#" & sHistAccount & ".C5#" & sReTransMember & TOPSxC5 & sValueECT & ".Y#PRIOR.P#LAST")
										dTransCurr  = HS.GetCell("A#" & sHistAccount & ".C5#" & sReTransMember & TOPSxC5 & ".V#" & sPOVCurrency & " Total" & ".Y#PRIOR.P#LAST")
									End If
									
									If dEntityCurr = 0 Or dTransCurr = 0 Then
										'No data / zero at the closing balance level in <EC>, no translation is needed
										nHistoricOpeningForAlternateRate = 0
									Else
										'nHistoricOpeningForAlternateRate = 1 / (dTransCurr / dEntityCurr)
										nHistoricOpeningForAlternateRate = dTransCurr / dEntityCurr
									End If
									
								' Clear Standard FX on CTR
								' ------------------------		'Commented Out - REMOVE THIS SECTION IF NOT NEEDED - C2#[None] is now invalid for CTR since we changed custom top member (from C2_TOP to C2_S1000)
									' 'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated]
									' If sHistAccount = CTR And bFXonCTR Then
										' 'CTR account itself. The FX calculated by Standard Alternate Rate Translation (TransAlternateRates) for the data (if there is any) in C2#[None] (coming from CTR.<EC>) should be cleared, because it'll be recalculated by the code below and put into C2_BB9361. If not cleared, it causes double counting.
										' 'Clear previous FX calculated by TransAlternateRates() @ Restated Closing Rate - Restated Opening Rate by recalculating it in reverse at Res. Opening Rate - Res. Closing Rate
										' sSourcePOV = "A#" & sHistAccount & ".C1#" & OBTOT & ".C2#[None].C5#" & sReTransMember
										' sTargetPOV = "A#" & sHistAccount & ".C1#" & FXOPE & ".C2#[None].C5#" & sReTransMember
										
										' HS.Trans sTargetPOV, sSourcePOV, nAlternateOpeningRate, nAlternateClosingRate			'cleared by recalculating in reverse (opening rate - closing rate)
									' End If
									
								'Loop through the movements this historic rate applies to (normally one movement per rate)
								For Each sHistMovement In aHistMovements
									
									' Clear Alternate Rate Translation
									' --------------------------------
										'Clear previous translation data produced by TransAlternateRates() @ Restated Opening Rate by retranslating at the minus opening rate
										HS.Trans "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember, "", nAlternateOpeningRate * (-1), ""
										
									' ReTranslate at Historic Rate
									' ----------------------------
										'Retranslate @ Historic Opening Rate
										'HS.Trans "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember, "", nHistoricOpeningRate, ""
										HS.Trans "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember, "", nHistoricOpeningForAlternateRate, ""
										
									' Clear Standard FX - not needed
									' ------------------------------
										'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) and there shouldn't be any fx movement valid for the historic accounts, so no FX to clear. For exceptional accounts (e.g. [BB1671 Investment in JVs], [SF9110 Investment in JV / Associate]) the FX is on the account, however this doesn't require a change in calculation of FXOPE:[C1_5501 FX Opening to Closing], so the standard calculation by TransAlternateRates is correct.
										
									' Calculate FX
									' ------------
										'CTR Opening Balance - Recalculate based on the current year's restated opening rate.
										If bFXonCTR Then
											'If only one rate then opening rate is same as closing rate but is different from last year's closing rate, so the CTR opening balance need to be recalculated
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sReTransMember & sTargetICP
											sTargetPOV = "A#" & CTR			 & ".C1#" & sHistMovement & ".C2#C2_" & sHistAccount & ".C5#" & sReTransMember & sTargetICP			'UPDATE NEEDED: ".C1#" & sHistMovement is this correct? shouldn't C1 be an FX mvt?
											
											HS.Trans sTargetPOV, sSourcePOV, nAlternateOpeningRate, nHistoricOpeningForAlternateRate
										End If
										
										'FXOPE:[C1_5501 FX Opening to Closing]
										'The FX element related to the historic (blended) opening rate to standard opening rate (i.e. prior year-end blended rate to closing rate) is brought forward in the Opening Balance of CTR. What is left to calculate is the standard opening rate to month-end closing rate
										If bFXonCTR And bOneRate Then
											'No FX Opening to Closing difference because it is the same one rate used for both opening and closing balances
											
										ElseIf bFXonCTR Then	'3 Rates
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sReTransMember & sTargetICP
											sTargetPOV = "A#" & CTR			 & ".C1#" & FXOPE		  & ".C2#C2_" & sHistAccount & ".C5#" & sReTransMember & sTargetICP
											
											HS.Trans sTargetPOV, sSourcePOV, nAlternateClosingRate, nAlternateOpeningRate
										Else
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember
											sTargetPOV = "A#" & sHistAccount & ".C1#" & FXOPE		  & ".C5#" & sReTransMember
											
											HS.Trans sTargetPOV, sSourcePOV, nAlternateClosingRate, nAlternateOpeningRate
										End If
										
								Next  'historic movement (C1)
							End If
						Next  'historic opening rate
						
					' ================
					'  MOVEMENTS & FX
					' ================
						For Each sRateAccount In HS.Account.List("FIXED_RATES", "[Base]")
							
							' GET THE FIXED/SPOT RATE
							' -----------------------
							'nSpotRate = The spot/blended rate for the transaction(s) in the month that make(s) up this monthly movement (PERIODIC.BB?????.C1_####)
							nSpotRate = HS.GetRate("A#" & sRateAccount)
							sUD1 = Trim(HS.Account.UD1(sRateAccount))
							
							If sUD1 = "" Then
								'UDA parameters not defined. Make the HFM Rules abort with a message to the HFM Admin.
								Call AbortRules("BLANK-UDA-FX_NOTUSED", "Missing Metadata Attribute - UDA parameters not defined for " & sRateAccount)
								
							Else
								'If spot rate is zero (no rate input), still translate at zero rate to clear the effect of default translation (at average) and standard fx calc (average to closing)
								sHistAccount   = GetParameterValue(sUD1, "ACC")
								sHistMovements = GetParameterValue(sUD1, "MVT")
								sHistFX 	   = GetParameterValue(sUD1, "FX")
								aHistMovements = Split(sHistMovements, ",")
								
								bFXonCTR = IsParameter(HS.Account.UD1(sHistAccount), "FXCTR")
								If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""   Else   sTargetICP = ".I#[ICP None]"
								
								' Clear Standard FX
								' -----------------
									If InStr(sClearedFXAVGfor, sHistAccount) Then
										'Standard FX for this account has already been cleared - skip
										
									ElseIf sHistAccount = CTR And bFXonCTR Then
										'Commented Out - REMOVE THIS SECTION IF NOT NEEDED - C2#[None] is now invalid for CTR since we changed custom top member (from C2_TOP to C2_S1000)
											' 'CTR account itself. The FX calculated by Standard Translation Rules (TransAlternateRates) for the data (if there is any) in C2#[None] (coming from <EC>) should be cleared, because it'll be recalculated by the code below and put into C2_BB9361. If not cleared, it causes double counting.
											' 'Clear previous FX calculated by TransAlternateRates() @ Restated Closing Rate - Restated Averate Rate by recalculating it in reverse at Restated Average Rate - Restated Closing Rate
											' sSourcePOV = "A#" & sHistAccount & ".C1#" & MVTOT & ".C2#[None].C5#" & sReTransMember
											' sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG & ".C2#[None].C5#" & sReTransMember
												
											' HS.Trans sTargetPOV, sSourcePOV, nAlternateAverageRate, nAlternateClosingRate
											
											' sClearedFXAVGfor = sClearedFXAVGfor & sHistAccount & ","
										
									ElseIf bFXonCTR Then
										'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) and there shouldn't be any fx movement valid for the historic accounts, so no FX to clear.
										
									Else
										'Exceptional to the design principle stated above (e.g. [BB1671 Investment in JVs], [SF9110 Investment in JV / Associate])
										'Clear previous FX calculated by TransAlternateRates() @ Restated Closing Rate - Restated Averate Rate by recalculating it in reverse at Restated Average Rate - Restated Closing Rate
										sSourcePOV = "A#" & sHistAccount & ".C1#" & MVTOT & ".C5#" & sReTransMember
										sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG & ".C5#" & sReTransMember
										
										HS.Trans sTargetPOV, sSourcePOV, nAlternateAverageRate, nAlternateClosingRate
										
										sClearedFXAVGfor = sClearedFXAVGfor & sHistAccount & ","
									End If
									
								'Loop through the movements this historic rate applies to (normally one movement per rate)
								For Each sHistMovement In aHistMovements
									'Call WriteToDebugLog ("sRateAccount:" & sRateAccount & " sUD1:" & sUD1 & "__sHistAccount:" & sHistAccount & " sHistMovement:" & sHistMovement)
									
									' Clear Alternate Rate Translation
									' --------------------------------
										'Clear previous translation data produced by TransAlternateRates() @ Restated Average Rate by retranslating at the minus average rate
										HS.Trans "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember, "", nAlternateAverageRate * (-1), ""
										
									' ReTranslate at Historic Rate
									' ----------------------------
										HS.TransPeriodic "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember, "", nSpotRate, ""
										
										'HS.Trans "A#" & sHistAccount & ".C1#" & sHistFX & ".C5#" & sReTransMember, "", nAlternateClosingRate, ""	'UPDATE NEEDED !!! - is this needed? this is for the second translation e.g. EUR->GBP->USD, EUR->USD->GBP etc.
										
									' Clear Standard FX - not needed
									' ------------------------------
										'As a design principle, no FX is kept on the historic B/S accounts (kept on CTR instead) and there shouldn't be any fx movement valid for the historic accounts, so no FX to clear. For exceptional accounts (e.g. [BB1671 Investment in JVs], [SF9110 Investment in JV / Associate]) the FX is on the account, however this doesn't require a change in calculation of FXOPE:[C1_5501 FX Opening to Closing], so the standard calculation by TransAlternateRates is correct.
										
									' Calculate Historic FX
									' ---------------------
										'Add FX to Historic FX for this movement (e.g. [C1_5504 FX Historic Movement to Closing])
										'Part 1: The difference due to the difference between closing and spot rates
											If bFXonCTR Then
												sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sReTransMember & sTargetICP
												sTargetPOV = "A#" & CTR 		 & ".C1#" & sHistFX		  & ".C2#C2_" & sHistAccount & ".C5#" & sReTransMember & sTargetICP
											Else
												sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember
												sTargetPOV = "A#" & sHistAccount & ".C1#" & sHistFX		  & ".C5#" & sReTransMember
											End If
											
											HS.TransPeriodic sTargetPOV, sSourcePOV, nAlternateClosingRate, nSpotRate
											
										'Part 2: The difference due to the difference between closing and prior month closing rates, applicable to the prior month YTD number which was translated at prior month closing rate.
											If Not bIsFirstPeriod Then
												If bFXonCTR Then
													sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C2#C2_TOP"			 & ".C5#" & sReTransMember & ".P#PRIOR.W#YTD" & sTargetICP
													sTargetPOV = "A#" & CTR 		 & ".C1#" & sHistFX		  & ".C2#C2_" & sHistAccount & ".C5#" & sReTransMember & ".W#Periodic"    & sTargetICP
												Else
													sSourcePOV = "A#" & sHistAccount & ".C1#" & sHistMovement & ".C5#" & sReTransMember & ".P#PRIOR.W#YTD"
													sTargetPOV = "A#" & sHistAccount & ".C1#" & sHistFX		  & ".C5#" & sReTransMember & ".W#Periodic"
												End If
												
												HS.Trans sTargetPOV, sSourcePOV, nAlternateClosingRate, nAlternateClosingRatePriorMonth
											End If
									
									sTranslatedAtSpotRate = sTranslatedAtSpotRate & sHistAccount & "." & sHistMovement & ","
									Call AddUniqueToArray(aHistAccounts, sHistAccount)											'UPDATE NEEDED: for every retrans member (C5) same list is generated again, improve performance if possible
								Next  'historic movement (C1)
							End If
						Next  'fixed/spot rate
						
					' =================
					'  CLOSING BALANCE
					' =================
						'CBTOT:[C1_T000 Closing Balance]			Parent member - not translated
						'CBLOAD:[C1_9999 Closing Balance Load]		Translated in TransHistoricCalc @ blended rate (historic opening & spot rates) to match CBTOT(C1_T000)
						
					' ==========
					'  OTHER FX
					' ==========
						'Calculate FXAVG:[C1_5502 FX Average to Closing] for the movements that have not been retranslated at spot rate
						If IsArray(aHistAccounts) Then
							For Each sHistAccount in aHistAccounts
								bFXonCTR = IsParameter(HS.Account.UD1(sHistAccount), "FXCTR")
								If HS.Account.IsICP(sHistAccount) Then   sTargetICP = ""   Else   sTargetICP = ".I#[ICP None]"
								sC1TopMember = HS.Account.CustomTop(sHistAccount, "Custom1")
								
								'MVTOT:[C1_M100 Movements]
								For Each sMovement In HS.Custom("Custom1").List(MVTOT, "[Base]")
									If Not HS.Custom("Custom1").IsBase(sC1TopMember, sMovement) Then
										'This movement is not a valid movement for this historic account - skip
										
									ElseIf InStr(sTranslatedAtSpotRate, sHistAccount & "." & sMovement) Then
										'This movement has been translated at spot rate and the FX for it has already been calculated - skip
										
									Else
										'Recalculate FXAVG:[C1_5502 FX Average to Closing] for this movement
										If bFXonCTR Then
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sMovement & ".C2#C2_TOP"			 & ".C5#" & sReTransMember & sTargetICP
											sTargetPOV = "A#" & CTR 		 & ".C1#" & FXAVG 	  & ".C2#C2_" & sHistAccount & ".C5#" & sReTransMember & sTargetICP
										Else
											'UPDATE NEEDED: the relevant updates made in this section in TransHistoric() should be applied here as well.
											sSourcePOV = "A#" & sHistAccount & ".C1#" & sMovement & ".C5#" & sReTransMember
											sTargetPOV = "A#" & sHistAccount & ".C1#" & FXAVG 	  & ".C5#" & sReTransMember
										End If
										
										HS.Trans sTargetPOV, sSourcePOV, nAlternateClosingRate, nAlternateAverageRate
									End If
								Next  'movement
							Next  'historic account
						End If
				Next  're-translation member (C5)
			Else
				'Not applicable to this scenario
			End If  'rate is applicable to the scenario
		Next  're-translation group
	End Sub   'TransHistoricForAlternateRates_NOT_USED
	
	Sub ConsJVorAssociateCalc_NOT_USED()
		sActiveCodeBlock = "ConsJVorAssociateCalc_NOT_USED"
		
		'Apply ownership to the P&L for the year, Hedging Reserve and Translation Reserve and write to the movements of the memo account used for JV consolidation to determine whether it is a profit or loss making JV.
		Dim sHedgingReservePOV, sTransReserveGrossPOV, sCTRpov
		
		If bBeforeCutover Then
			'Data Migration Period - Legacy HFM didn't have automation for loss making JVs & Associates. Consolidate all JVs & Associates using the standard JV rules at the ownership %.
			Exit Sub
		End If
		
		'If bValueIsECorECA Or bValueIsTrans Then
		If bIsBaseEntity And bValueIsECorECA Then
				'Call WriteToCellTextLog("sPOVEntity: " & sPOVEntity & "   dOwnershipPOWN: " & dOwnershipPOWN)
			' --------------
			'  P&L Reserves
			' --------------
			'[SF9110 Investment in JV / Associate], [C1_5007 Share of Joint Venture and Associates - Profit and Loss Reserves]
			'[BB9511 Profit and Loss Reserve], [C1_5020 Profit/(Loss) for the Period]
			HS.Exp "A#SF9110.C1#C1_5007" & NONESxC1C5 & " = - A#BB9511.C1#C1_5020" & TOPSxC1C5 & " * " & dOwnershipPOWN / 100
			
			' ----------------
			'  Other Reserves
			' ----------------
			'[SF9110 Investment in JV / Associate], [C1_7213 Other reserves], MVTOT:[C1_M100 Movements], FXTOT:[C1_M200 Foreign currency translation]
			sHedgingReservePOV    = "A#BB9311.C1#" & MVTOT & TOPSxC1C5			'[BB9311 Hedging Reserve - Gross]
			sTransReserveGrossPOV = "A#BB9331.C1#" & MVTOT & TOPSxC1C5			'[BB9331 Translation Reserves - NIH - Gross]
			
			'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [C2_BB9311 Source - Hedging Reserve - Gross], [C2_BB9361 Source - Foreign Currency Translation Reserves], [C2_BB9511 Source - Profit and Loss Reserve]
			sCTRpov				  = "A#" & CTR & ".C1#" & MVTOT & ".C2#C2_BB9311" & TOPSxC1C2C5 & " + A#" & CTR & ".C1#" & FXTOT & ".C2#C2_BB9311" & TOPSxC1C2C5 & " + " & _
									"A#" & CTR & ".C1#" & MVTOT & ".C2#C2_BB9361" & TOPSxC1C2C5 & " + A#" & CTR & ".C1#" & FXTOT & ".C2#C2_BB9361" & TOPSxC1C2C5 & " + " & _
									"A#" & CTR & ".C1#" & MVTOT & ".C2#C2_BB9511" & TOPSxC1C2C5 & " + A#" & CTR & ".C1#" & FXTOT & ".C2#C2_BB9511" & TOPSxC1C2C5 & " + " & _
									"A#" & CTR & ".C1#" & MVTOT & ".C2#[None]"    & TOPSxC1C2C5 & " + A#" & CTR & ".C1#" & FXTOT & ".C2#[None]"    & TOPSxC1C2C5
			
			HS.Exp "A#SF9110.C1#C1_7213" & NONESxC1C5 & " = - (" & sHedgingReservePOV & " + " & sTransReserveGrossPOV & " + " & sCTRpov & ") * " & dOwnershipPOWN / 100
			
		End If
	End Sub   'ConsJVorAssociateCalc_NOT_USED
	
	
	Sub CalcForWebforms_NOT_USED()
		sActiveCodeBlock = "CalcForWebforms_NOT_USED"
		
		' Dim oCellTextUnit, nNumItems, i, CTURecord
		
		' Set oCellTextUnit = HS.OpenCellTextUnit("", sCellTextLabel, "", "")
		' nNumItems = oCellTextUnit.GetNumItems
		
		' If nNumItems > 0 Then
			' For i = 0 To nNumItems - 1
				' Set CTURecord = oCellTextUnit.Item(i)
					' 'Call WriteToDebugLog(CTURecord.POV & ": " & CTURecord.Label & ": " & CTURecord.CellText)
				' HS.SetCellTextWithLabel CTURecord.POV, sCellTextLabel, ""
				' Set CTURecord = Nothing
			' Next
		' End If
		
		' Set oCellTextUnit = Nothing
		
		'---------------------------------------------------
		
		Dim oCellTextUnit, nNumItems, i, CTURecord, sCellTextLabel
		sCellTextLabel = "System"
		
		Set oCellTextUnit = HS.OpenCellTextUnit("A#NoSuppress_Products", sCellTextLabel, "", "")
		nNumItems = oCellTextUnit.GetNumItems
		
		If nNumItems > 0 Then
			For i = 0 To nNumItems - 1
				Set CTURecord = oCellTextUnit.Item(i)
					'Call WriteToDebugLog(CTURecord.POV & ": " & CTURecord.Label & ": " & CTURecord.CellText)
				HS.SetCellTextWithLabel CTURecord.POV, sCellTextLabel, ""
				Set CTURecord = Nothing
			Next
		End If
		
		Set oCellTextUnit = Nothing
		
		' For Each sC2 In 
			' HS.Exp "A#NoSuppress_BaseProducts"
		
	End Sub   'CalcForWebforms_NOT_USED
	
	Sub SystemHealthCheck_NOT_USED()
		sActiveCodeBlock = "SystemHealthCheck_NOT_USED"
		
		'BY: Code to be written, or REMOVE IF NOT REQUIRED !!!
	End Sub   'SystemHealthCheck_NOT_USED
	
	Sub SetDebugParameters_TEMP_NOT_USED()		'BY: REMOVE if not used !!!
		bDebugIsON = True
		bTimerIsON = False
		
		sDebugFolderPath = "D:\HFM_Files\Debug_Logs\"
		'sDebugFolderPath = "\\oc-141-144-146-41.compute.oraclecloud.com\HFMDebug\"
		'sDebugFolderPath = "\\omcsbdcxhkmrlf\HFMDebug\"
		'sDebugFolderPath = ""
		sDebugFileName = "HFM_Debug_Log.txt"
	End Sub   'SetDebugParameters_TEMP_NOT_USED
	
	Function GetParamValueFromDict_NOT_USED(sMember, sUDAString, sParameter)
		'This function tries to find the parameter (sParameter: the name of the parameter) in the UDA string (sUDAString), and returns the parameter value after ':' if it finds.
		Dim sMemberParameter, sParamValue
		
		'Check if this parameter value was retrieved from this string before (combination of string & parameter)
		sMemberParameter = sMember & " ~ " & sParameter
		
		If oParameterValues_NOT_USED.Exists(sMemberParameter) Then
			'this parameter's value was requested before - return the previously found value
			sParamValue = oParameterValues_NOT_USED(sMemberParameter)
		Else
			sParamValue = GetParameterValue(sUDAString, sParameter)
			oParameterValues_NOT_USED.Add sMemberParameter, sParamValue
		End If
		
		GetParamValueFromDict_NOT_USED = sParamValue
	End Function   'GetParamValueFromDict_NOT_USED
	
	Function GetParamValueFromArray_NOT_USED(sMember, sUDAString, sParameter)
		'This function tries to find the parameter (sParameter: the name of the parameter) in the UDA string (sUDAString), and returns the parameter value after ':' if it finds.
		Dim sParamValue, i, iRow, iCol, bMemberFound, bParameterFound, sCurrentRow, sCurrentCol, sCurrentValue
		
		bMemberFound = False : bParameterFound = False
		sParamValue = ""   'return blank by default
		
		'Check if a parameter for this member was requested before (if it is in the rows)
		For i = 1 To UBound(aParameterValues_NOT_USED, 1)
			sCurrentRow = aParameterValues_NOT_USED(i, 0)
			
			If sCurrentRow = "" Then
				'end of the table, member not found
				iRow = i : Exit For
				
			ElseIf sCurrentRow = sMember Then
				bMemberFound = True
				iRow = i : Exit For
			End If
		Next  'row
		
		'Check if this parameter was requested for any member before (if it is in the columns)
		For i = 1 To UBound(aParameterValues_NOT_USED, 2)
			sCurrentCol = aParameterValues_NOT_USED(0, i)
			
			If sCurrentCol = "" Then
				'end of the table, parameter not found
				iCol = i : Exit For
				
			ElseIf sCurrentCol = sParameter Then
				bParameterFound = True
				iCol = i : Exit For
			End If
		Next  'column
		
		If bMemberFound And bParameterFound Then
			'Check if the value of this parameter was requested for this member before (if there is a value in the table for this combination)
			sCurrentValue = aParameterValues_NOT_USED(iRow, iCol)
			
			If sCurrentValue = "no value found!" Then
				'a request was made before and no value was found
				
			ElseIf sCurrentValue = "" Then
				'no request was made before - get the value for this parameter
				sParamValue = GetParameterValue(sUDAString, sParameter)
			Else
				'there is a value in the table which must have been from a previous request for the same member & parameter combination
				sParamValue = sCurrentValue
			End If
			
		Else
			If Not bMemberFound Then 	aParameterValues_NOT_USED(iRow, 0) = sMember
			If Not bParameterFound Then aParameterValues_NOT_USED(0, iCol) = sParameter
			
			sParamValue = GetParameterValue(sUDAString, sParameter)
			
			If sParamValue = "" Then
				'no value found, record this so we don't try to find a value again for this combination
				aParameterValues_NOT_USED(iRow, iCol) = "no value found!"
			Else
				'a value found, record it so we don't try to find a value again for this combination (and return this value directly from the array - faster)
				aParameterValues_NOT_USED(iRow, iCol) = sParamValue
			End If
		End If
		
		GetParamValueFromArray_NOT_USED = sParamValue
	End Function   'GetParamValueFromArray_NOT_USED
	
	
dim secE3 '   Section E3 - Old Versions of Subs and Functions
		  ' ==========================================================================================================
	Sub ConsDiscontinuedOps_OLD()
		sActiveCodeBlock = "ConsDiscontinuedOps_OLD"
		
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sPlugAcc, sTargetAcc, sTargetPOV, sTreatment
		
		Set oDataUnit = HS.OpenDataUnit("")		'YTD by default
		nNumItems = oDataUnit.GetNumItems
		
		For i = 0 To nNumItems - 1
			'Get the next item from the data unit
			sAccount = oDataUnit.Item(i).Account
			sICP	 = oDataUnit.Item(i).ICP
			sC1		 = oDataUnit.Item(i).Custom("Custom1")
			sC2		 = oDataUnit.Item(i).Custom("Custom2")
			sC3		 = oDataUnit.Item(i).Custom("Custom3")
			sC4		 = oDataUnit.Item(i).Custom("Custom4")
			sC5		 = oDataUnit.Item(i).Custom("Custom5")
			dData	 = oDataUnit.Item(i).Data
				
				'Call WriteToDebugLog ("oDataUnit.Item(i).POV -> " & oDataUnit.Item(i).POV)
				
			sTreatment = ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
			
			If sTreatment = "processed" Then
				'This data has been processed/consolidated already or skipped (because of its pov or it's zero) - no need for further action
			Else
				If HS.Account.IsICP(sAccount) Then						'UPDATE NEEDED: the plug accounts themselves shouldn't be collapsed either.
					'Account is an ICP account
					sPlugAcc = HS.Account.PlugAcct(sAccount)
					If sPlugAcc <> "" Then
						'The ICP account has a plug account - will be eliminated at the right parent
						sTreatment = "eliminated account"
						
						'------------------------------------------
						'|  Standard Consolidation & Elimination  |
						'------------------------------------------
						'Proportionalize this account
						HS.Con "", dConsolidationPercentage, ""
						
						'Eliminate this account at the first common parent entity
						Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
					End If
				End If
				
				If sTreatment = "eliminated account" Then
					'It has been or will be eliminated before reaching Group - skip
				Else
				'-------------------
				'|  Profit & Loss  |
				'-------------------
					'[PS9999 Retained Profit]
					If HS.Account.IsBase("PS9999", sAccount) Then
						'Collapse all P&L into [PB9100 Profit/(loss) for the year from discontinued Operations]
						HS.Con "A#PB9100" & NONESxC4C5, dConsolidationPercentage, ""
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
				'------------------
				'|  B/S - Assets  |
				'------------------
					'[BS1999 Non Current Assets], [BS2999 Current Assets]
					ElseIf HS.Account.IsBase("BS1999", sAccount) Or HS.Account.IsBase("BS2999", sAccount) Then
						'Collapse all assets into [BB2995 Assets of Disposal Group]
						HS.Con "A#BB2995" & NONESxC1C2C3C4C5, dConsolidationPercentage, ""
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
				'-----------------------
				'|  B/S - Liabilities  |
				'-----------------------
					'[BS3989 Current Labilities], [BS4999 Non Current Liabilities]
					ElseIf HS.Account.IsBase("BS3989", sAccount) Or HS.Account.IsBase("BS4999", sAccount) Then
						'Collapse all liabilities into [BB3398 Liabilities of Disposal GroUp Classified as Held for Sale]
						HS.Con "A#BB3398" & NONESxC1C2C3C4C5, dConsolidationPercentage, ""
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
				'------------------
				'|  B/S - Equity  |
				'------------------
					'[BS9999 Total Equity]
					ElseIf HS.Account.IsBase("BS9999", sAccount) Then
						'Consolidate normally
						HS.Con "", dConsolidationPercentage, ""
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
					Else
				'--------------------
				'|  Other Accounts  |
				'--------------------
						'KP and SF accounts, validations etc - consolidate normally
						HS.Con "", dConsolidationPercentage, ""
					End If
				End If
			End If  'standard treatment result check
		Next  'data
		
		Set oDataUnit = Nothing
	End Sub   'ConsDiscontinuedOps_OLD
	
	Sub ConsJVorAssociate_OLD(sRunningFor)
		'THIS IS THE OLD VERSION THAT AUTOMATED CONSOLIDATION TREATMENT OF LOSS MAKING JVs
		
		sActiveCodeBlock = "ConsJVorAssociate_OLD"
		
		'nAdjustedPercentage: used mainly to reduce the investment closing balance at group to zero but not let it go negative
		Dim oDataUnit, nNumItems, i, sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData, sPlugAcc, sTargetAcc, sTargetPOV, sTreatment, sC5POV, sReTransMember, sDataUnitPOV, sResult
		Dim dInvestmentOpeningBalance, dInvestmentClosingBalance, nPercentageForPLandReserves, nAdjustedPercentage, nAdjustmentFactor, dChangeInInvestment, dDeferredIncomeOnInvestment, dShareOfOtherReserves, dShareOfProfitOrLoss, dTotalProfitOrLoss, dShareOfIncomeFromJVorAssoc, dFXAVG, dFXAVGfromJVorAssoc
		
		' DEFINITIONS
		' -----------
		Select Case sRunningFor
			Case "EXCEPT_C5_TRANS"
				sReTransMember	= "N/A"
				sC5POV			= ".C5#C5_TOP"
				sDataUnitPOV	= "C5{C5_SYS_BASE_EXCEPT_C5_TRANS}"
				
			Case "C5_TRANS"
				'Run consolidation for each retranslation (at alternate/restated rate) separately, by calling this consol method recursively
				For Each sReTransMember In HS.Custom("Custom5").List("C5_TRANS", "[Base]")
					'Call ConsJVorAssociate(sReTransMember)
					sResult = Recursive("ConsJVorAssociate", sReTransMember)		'recursive call(functionn calling itself)
				Next  're-translation member
				
				'No further code for this iteration - trigger further iterations only
				Exit Sub
				
			Case Else
				If HS.Custom("Custom5").IsBase("C5_TRANS", sRunningFor) Then
					sReTransMember = sRunningFor	'repurposed sReTransMember in this recursive call
					sC5POV 		   = ".C5#" & sReTransMember
					sDataUnitPOV   = "C5#" & sReTransMember
					
				Else
					'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
					Call AbortRules("ELSE-JV-1", "I am in ELSE within the If/ElseIf/Else block (1) in ConsJVorAssociate() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
				End If
				
		End Select
		
		' CHECK IF LOSS MAKING
		' --------------------
		' Check if it is a loss making JV/Assoc.
		dInvestmentOpeningBalance = HS.GetCell("A#SF9110.C1#" & OBCALC & TOPSxC1C5 & sC5POV)
		dInvestmentClosingBalance = HS.GetCell("A#SF9110"			   & TOPSxC5   & sC5POV)
		
		If bBeforeCutover Then
			'Data Migration Period - Legacy HFM didn't have automation for loss making JVs & Associates. Consolidate all JVs & Associates using the standard JV rules at the ownership %.
			nPercentageForPLandReserves = dOwnershipPercentage
			
		ElseIf dInvestmentOpeningBalance >= 0 And dInvestmentClosingBalance >= 0 Then
			' CASES (OB/CB): zero/zero, positive/positive, zero/positive, positive/zero
			' Not loss making currently and wasn't loss making last year - consolidate as normal
			nPercentageForPLandReserves = dOwnershipPercentage
			
		Else
			
			' CALCULATE ADJUSTED PERCENTAGE
			' -----------------------------
			'Calculate adjusted percentage to bring the investment closing balance to the correct number in line with the reporting requirements
			'[SF9110 Investment in JV / Associate], [C1_1117 Net Increase/Decrease in Investments], [C1_7213 Other reserves], [C1_5007 Share of Joint Venture and Associates - Profit and Loss Reserves], [C1_5025 Deferred Income Adjustment on Investment in JVs and Associates], [PS9999 Retained Profit]
			
			dChangeInInvestment			= HS.GetCell("A#SF9110.C1#C1_1117" & TOPSxC1C5 & sC5POV)	'from Holding Company
			dDeferredIncomeOnInvestment	= HS.GetCell("A#SF9110.C1#C1_5025" & TOPSxC1C5 & sC5POV)	'from Holding Company
			
			dShareOfOtherReserves		= HS.GetCell("A#SF9110.C1#C1_7213" & TOPSxC1C5 & sC5POV)	'from JV / Associate
			dShareOfProfitOrLoss		= HS.GetCell("A#SF9110.C1#C1_5007" & TOPSxC1C5 & sC5POV)	'from JV / Associate
			dTotalProfitOrLoss			= HS.GetCell("A#PS9999"			   & TOPSxC5   & sC5POV)	'from JV / Associate
			
			'FXAVG:[C1_5502 FX Average to Closing]
			dFXAVG 						= HS.GetCell("A#SF9110.C1#" & FXAVG & TOPSxC1C5 & sC5POV)	'from Holding Company + JV / Associate
			
			'The CTR portion (from JV/Assoc) included in FXAVG in this SF account should be included in calculation of the adjusted percentage.
			If dDeferredIncomeOnInvestment = 0 Then
				'No deferred income from the Holding Company. All FXAVG is due to share of income from the JV/Assoc.
				dFXAVGfromJVorAssoc = dFXAVG
			Else
				'Calculate the portion from JV/Assoc
				nAdjustmentFactor	= (dShareOfProfitOrLoss + dShareOfOtherReserves) / (dShareOfProfitOrLoss + dShareOfOtherReserves + dDeferredIncomeOnInvestment)
				dFXAVGfromJVorAssoc = dFXAVG * nAdjustmentFactor
			End If
			
			dShareOfIncomeFromJVorAssoc	= dShareOfProfitOrLoss + dShareOfOtherReserves + dFXAVGfromJVorAssoc		'from JV / Associate
			
			'If dTotalProfitOrLoss = 0 Then
			'	'No profit or loss - consolidate as normal
			'	nPercentageForPLandReserves = dOwnershipPercentage
			'	
			'ElseIf dInvestmentOpeningBalance > 0 And dInvestmentClosingBalance < 0 Then
			
			If dInvestmentOpeningBalance >= 0 And dInvestmentClosingBalance < 0 Then
				' CASES (OB/CB): zero/negative, positive/negative
				' Loss making now but wasn't loss making last year - reduce the Share of JV/Assoc P&L to bring the closing balance (investment + profit) at Group level to nil.
				
				If dShareOfIncomeFromJVorAssoc = 0 Then
					'No Income from JV/Assoc, apply the ownership %
					nPercentageForPLandReserves	= dOwnershipPercentage
				Else
					'Calculate a percentage to apply to P&L, Retained Earnings and Other Reserves that will bring the closing balance (investment + profit) at Group level to nil.
					nAdjustmentFactor	= -(dInvestmentOpeningBalance + dChangeInInvestment + dDeferredIncomeOnInvestment) / dShareOfIncomeFromJVorAssoc
					nAdjustedPercentage = dOwnershipPercentage * nAdjustmentFactor
					nPercentageForPLandReserves	= nAdjustedPercentage
				End If
				
			ElseIf dInvestmentOpeningBalance < 0 And dInvestmentClosingBalance <= 0 Then
				' CASES (OB/CB): negative/negative, negative/zero
				' Loss making / zero closing balance now and was loss making last year - reduce the Share of JV/Assoc P&L to bring the closing balance (investment + profit) at Group level to nil.
				
				If dShareOfIncomeFromJVorAssoc = 0 Then
					'No Income from JV/Assoc, apply the ownership %
					nPercentageForPLandReserves	= dOwnershipPercentage
				Else
					'Calculate a percentage to apply to P&L, Retained Earnings and Other Reserves that will bring the closing balance (investment + profit) at Group level to nil.
					nAdjustmentFactor	= -(dChangeInInvestment + dDeferredIncomeOnInvestment) / dShareOfIncomeFromJVorAssoc
					nAdjustedPercentage = dOwnershipPercentage * nAdjustmentFactor
					nPercentageForPLandReserves = nAdjustedPercentage
				End If
				
			ElseIf dInvestmentOpeningBalance < 0 And dInvestmentClosingBalance > 0 Then
				' CASES (OB/CB): negative/positive
				'Loss making - reduce the Share of JV/Assoc profit to bring the closing balance (investment + profit) at Group level to the correct figure (same as SF9110).
				
				If dShareOfIncomeFromJVorAssoc = 0 Then
					'No Income from JV/Assoc, apply the ownership %
					nPercentageForPLandReserves	= dOwnershipPercentage
				Else
					'Calculate a percentage to apply to P&L, Retained Earnings and Other Reserves that will bring the closing balance (investment + profit) at Group level to the correct figure (same as SF9110).
					nAdjustmentFactor	= (dInvestmentOpeningBalance + dShareOfIncomeFromJVorAssoc) / dShareOfIncomeFromJVorAssoc
					nAdjustedPercentage = dOwnershipPercentage * nAdjustmentFactor
					nPercentageForPLandReserves	= nAdjustedPercentage
				End If
				
			Else
				'There shouldn't be an else case. Make the HFM Rules abort with a message to the HFM Admin.
				Call AbortRules("ELSE-JV-2", "I am in ELSE within the If/ElseIf/Else block (2) in ConsJVorAssociate() where there shouldn't be an Else case. Add this case as an ElseIf condition.")
			End If
		End If
		
			'Call WriteToCellTextLog("nPercentageForPLandReserves: " & nPercentageForPLandReserves & " - dOwnershipPercentage:" & dOwnershipPercentage & " - nAdjustedPercentage:" & nAdjustedPercentage)
			
		' CONSOLIDATE
		' -----------
		Set oDataUnit = HS.OpenDataUnit(sDataUnitPOV)		'YTD by default
		nNumItems = oDataUnit.GetNumItems
		
		For i = 0 To nNumItems - 1
			'Get the next item from the data unit
			sAccount = oDataUnit.Item(i).Account
			sICP	 = oDataUnit.Item(i).ICP
			sC1		 = oDataUnit.Item(i).Custom("Custom1")
			sC2		 = oDataUnit.Item(i).Custom("Custom2")
			sC3		 = oDataUnit.Item(i).Custom("Custom3")
			sC4		 = oDataUnit.Item(i).Custom("Custom4")
			sC5		 = oDataUnit.Item(i).Custom("Custom5")
			dData	 = oDataUnit.Item(i).Data
			
			sTreatment = ConsStandardTreatment(sAccount, sICP, sC1, sC2, sC3, sC4, sC5, dData)
			
			If sTreatment = "processed" Then
				'This data has been processed/consolidated already or skipped (because of its pov or it's zero) - no need for further action
			Else
				Select Case UCase(sAccount)
					
				'-----------------------------------------
				'|  Share of Other Comprehensive Income  |
				'-----------------------------------------
				Case "BB9311"
					'[BB9311 Hedging Reserve - Gross], [C1_5006 Share of Joint Venture and Associates  - Hedge Reserves]
					'Consolidate all movements to C1_5006
					HS.Con "C1#C1_5006", nPercentageForPLandReserves, ""
					
					'Consolidate the same movement to the JV/Assoc asset account (double entry)
					'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
					If bIsMethodJV Then
						HS.Con "A#BB1678.C1#C1_5002", nPercentageForPLandReserves * (-1), ""
					ElseIf bIsMethodASSOCIATE Then
						HS.Con "A#BB1698.C1#C1_5002", nPercentageForPLandReserves * (-1), ""
					End If
					
				Case "BB9331"
					'[BB9331 Translation Reserves - NIH - Gross], [C1_5011 Share of Joint Venture and Associates  - Translation Reserves]
					'Consolidate all movements to C1_5011
					HS.Con "C1#C1_5011", nPercentageForPLandReserves, ""
					
					'Consolidate the same movement to the JV/Assoc asset account (double entry)
					'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
					If bIsMethodJV Then
						HS.Con "A#BB1678.C1#C1_5002", nPercentageForPLandReserves * (-1), ""
					ElseIf bIsMethodASSOCIATE Then
						HS.Con "A#BB1698.C1#C1_5002", nPercentageForPLandReserves * (-1), ""
					End If
					
				Case CTR
					'CTR:[BB9361 - Foreign Currency Translation Reserves - Calculated], [C1_5011 Share of Joint Venture and Associates  - Translation Reserves]
					Select Case UCase(sC2)
						Case "C2_BB9311", "C2_BB9361", "C2_BB9511", "[NONE]"
							'[C2_BB9311 Source - Hedging Reserve - Gross], [C2_BB9361 Source - Foreign Currency Translation Reserves], [C2_BB9511 Source - Profit and Loss Reserve]
							
							If IsEqual(sC2, "C2_BB9511") And IsEqual(sC1, "C1_5509") Then
								'[C1_5509 FX Historic to Closing - Data Migration Only] is used for [C1_9990 Data Migration] - skip, don't consolidate it up. This movement is used for data migration only and Arun requested it to be not consolidated for P&L reserves to be able to reconcile to Legacy HFM (GCS).
								
							Else
								'Consolidate all movements to C1_5011
								HS.Con "C1#C1_5011", nPercentageForPLandReserves, ""
								
								'Consolidate the same movement to the JV/Assoc asset account (double entry)
								'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5002 Share of Other Comprehensive Income]
								If bIsMethodJV Then
									HS.Con "A#BB1678.C1#C1_5002.C2#[None]", nPercentageForPLandReserves * (-1), ""
								ElseIf bIsMethodASSOCIATE Then
									HS.Con "A#BB1698.C1#C1_5002.C2#[None]", nPercentageForPLandReserves * (-1), ""
								End If
							End If
						Case Else
							'FX in CTR from other source accounts (e.g. Share Capital) will not be consolidated.
					End Select
					
				'-------------------------------------------
				'|  Share of Profit/(Loss) for the Period  |
				'-------------------------------------------
				Case "BB9511"
					'[BB9511 Profit and Loss Reserve], [C1_5020 Profit/(Loss) for the Period], [C1_5007 Share of Joint Venture and Associates - Profit and Loss Reserves]
					If IsEqual(sC1, "C1_5027") Then
						'[C1_5027 Dividends] - skip, don't consolidate it up. This movements is made of Intercompany Dividends + Dividends to Shareholders
						
					ElseIf IsEqual(sC1, "C1_9990") Then
						'[C1_9990 Data Migration] - skip, don't consolidate it up. This movement is used for data migration only and Arun requested it to be not consolidated for P&L reserves.
						
					Else
						'Other movements of P&L Reserve - Consolidate to C1_5007
						HS.Con "C1#C1_5007", nPercentageForPLandReserves, ""
						
						'Consolidate the same movement to the JV asset account (double entry)
						'[BB1678 Share of Post Acquisition Reserves - JV], [BB1698 Share of Post Acquisition Reserves - Associate], [C1_5001 Share of Profit/(Loss) for the Period]
						If bIsMethodJV Then
							HS.Con "A#BB1678.C1#C1_5001", nPercentageForPLandReserves * (-1), ""
						ElseIf bIsMethodASSOCIATE Then
							HS.Con "A#BB1698.C1#C1_5001", nPercentageForPLandReserves * (-1), ""
						End If
						
						'Consolidate C1_5020 also to the [SF9110 Investment in JV / Associate], the account used to track the total investment value	'UPDATE NEEDED: Remove if not needed
						'HS.Con "A#SF9110.C1#C1_5007", nPercentageForPLandReserves * (-1), ""
					End If
					
				Case "SF9110"
					'[SF9110 Investment in JV / Associate] - skip, don't consolidate it up. It is used only to determine if the JV is in a loss making state.
					
				Case Else
					
				'-------------------
				'|  Profit & Loss  |
				'-------------------
					If HS.Account.IsBase("PS9900", sAccount) Then
						'An account under [PS9900 External Dividends] - skip, don't consolidate it up.		UPDATE NEEDED: This is a temporary solution for Data Migration, check if it should be a different rule after cutover
						
					ElseIf HS.Account.IsBase("PS9999", sAccount) Then
						'Any other P&L account (all others under [PS9999 Retained Profit])
						
						If bIsMethodJV Then
							'Proportionalize [PB7201 Share of Post Tax Profits/ (Losses) - Joint Ventures] at the ownership percentage
							HS.Con "A#PB7201" & NONESxC4C5, nPercentageForPLandReserves, ""
							
						ElseIf bIsMethodASSOCIATE Then
							'Proportionalize [PB7202 Share of Post Tax Profits/ (Losses) - Associates] at the ownership percentage
							HS.Con "A#PB7202" & NONESxC4C5, nPercentageForPLandReserves, ""
						End If
						
						'See if we should eliminate this account
						'Call Eliminate_ICP(n100Percent)
						'Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
						
					Else
						'Other accounts (Assets, Liabilities and Equity accounts, and also the memo accounts won't be consolidated.		'UPDATE NEEDED: Validations and validation lock accounts need to consolidate up.
						'Retained Earnings, Investment in Associates/Joint Ventures accounts will be calculated in Sub Calculate()
					End If
				End Select  'account check
				
				' '------------------------------------------
				' '|  Standard Consolidation & Elimination  |
				' '------------------------------------------
				' 'Proportionalize this account
				' HS.Con "", dConsolidationPercentage, ""
				
				' 'Eliminate this account at the first common parent entity
				' Call Eliminate_ICP(sAccount, sICP, sC5, dConsolidationPercentage, "", "")
				
			End If  'standard treatment result check
		Next  'data
		
		Set oDataUnit = Nothing
	End Sub   'ConsJVorAssociate_OLD
	
	Sub OnDemand_TEST_CODE_OLD()
		'This sub should be used to temporarily test a piece of code (e.g. a new functionn etc.)
		sActiveRules = "ON DEMAND"
		sActiveCodeBlock = "OnDemand_TEST_CODE_OLD"
		
		Dim i, j, iNumberOfIterations, bExecute
		
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
		'	EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
		' <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
		
		'========================================================================================================================================
			' sPOVScenario = HS.Scenario.Member()
			' sPOVEntity = HS.Entity.Member()
			' sPOVYear = HS.Year.Member()
			' iPOVYear = Cint(sPOVYear)
			' sPOVPeriod = HS.Period.Member()
			' iPOVPeriodNum = HS.Period.Number()
			' sPOVValue = HS.Value.Member()
			' sPOVCurrency = HS.Value.Currency()
			' sPOVEntityDefCurrency = HS.Entity.DefCurrency("")
			' sPOVParent = HS.Parent.Member()
			' bIsActual = (sPOVScenario = "Actual")
		'========================================================================================================================================
			Call SetDebugParameters
			Call SetGlobalVariables
			Call SetPOVVariables
			
			Call WriteToAllDebugLogs("OnDemand_TEST_CODE_OLD is running... ")
			'Call WriteToCellTextLog("ApplicationName:" & sApplication)
		'========================================================================================================================================
			bExecute = TRUE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			Dim sEmailStatus
			
			Call WriteToFile("TEST SEND EMAIL WITH ATTACHMENT  " & CStr(Now()), sDebugFileName)
			
			If bExecute Then
				sSendFrom  = """HFM RULES"" <no-reply@em3.opc.oracleoutsourcing.com>"
				sSendTO    = "bulent.yildiz2@tesco.com"
				'sSendCC    = ""
				'sSendBCC  = ""
				
				sSubject = "TEST SEND EMAIL WITH ATTACHMENT"
				
				sHTMLBody = "TEST SEND EMAIL WITH ATTACHMENT <BR><BR>" & _
							"<B> Active Rules: </B>"		& sActiveRules 		& "<BR>" 	 & _
							"<B> Active Code Block: </B>"	& sActiveCodeBlock 	& "<BR><BR>" & _
							"<B> Process Unit: </B>"		& sProcessUnitPOV 	& "<BR><BR>" & _
							"<B> Date & Time: </B>" 		& CStr(Now()) 		& "<BR><BR>" & _
							"<B> Application: </B>"			& sApplication & " in " & sEnvironment
				
				sAttachmentFilePath = sDebugFolderPath & sDebugFileName
				
				sEmailStatus = SendEmail()
			End If
		'========================================================================================================================================
			bExecute = FALSE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			Dim sParameterValue, sSourcePOV, sExpSourcePOV, sTargetPOV, sExpTargetPOV, sExpTargetPOVforDifference, sAccount, dBalance, dInputData, aParamSections, sParamSection
			Dim iEqualSignPos, sYear, aParametricCalcAccs, sApplicability, sExceptions, sUDA, sUDA3, bApplicableToPOV, sSourceValue
			
			If bExecute Then					' >>>  LOOP FOR ONE ACCOUNT  <<<
				sSourceValue = sValueECT
				
				iNumberOfIterations = 10000
				
				'sAccount = "KP2721"			'CALC: BS1760 + BS1900 + BB1875 + BB2221 + BB2222 + BB2223 + BB2411 + BB2415 + BB2417 + BS2500 + BS2800 + BS2850 + BB2841 + BS3390 + BS3600 + BS3700
				sAccount = "CB1220_05"		'CALC: - BB4551.C1_1168
				
				sUDA = HS.Account.UD1(sAccount)
				bApplicableToPOV = True
				
				Call WriteToAllDebugLogs("ConvertToExpression LOOP started for " & sAccount & " - Number of Iterations: " & iNumberOfIterations)
				
				For i = 1 to iNumberOfIterations
					If bApplicableToPOV Then
						sParameterValue = GetParameterValue(sUDA, "CALC")
						If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
							'Extra parentheses, remove them.
							sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
						End If
						
						aParamSections = Split(sParameterValue, ",")
						
						For Each sParamSection In aParamSections
							iEqualSignPos = InStr(sParamSection, "=")
							If iEqualSignPos > 0 Then
								'There is custom member(s) specified as the target POV on the left side of the =
								sTargetPOV = Left(sParamSection, iEqualSignPos - 1)
								sSourcePOV = Mid(sParamSection, iEqualSignPos + 1)
								
								If Not BeginsWith(sTargetPOV, sAccount) Then
									'The account itself is not included in the target POV part. Let's add it to the beginning of it.
									sTargetPOV = sAccount & "." & sTargetPOV
								End If
							Else
								'Whole parameter section is for source pov - target is the account itself (for all its valid custom members)
								sTargetPOV = sAccount
								sSourcePOV = sParamSection
							End If
							
							sExpTargetPOV = ConvertToExpression(sTargetPOV, sAccount, "NONES FOR UNUSED DIMENSIONS", "C5#C5_MANINP", "ALL", "")
							sExpSourcePOV = ConvertToExpression(sSourcePOV, sAccount, "TOPS EXCLUDING SAME ANALYSIS", "C5#C5_TOP", "ALL", sSourceValue)
							
							'Call WriteToAllDebugLogs("HS.Exp " & sExpTargetPOV & " = " & sExpSourcePOV)
						Next  'section in parameter value
					End If  'account is applicable to the pov
				Next  'i
				
				Call WriteToAllDebugLogs("ConvertToExpression LOOP ended for " & sAccount & " - Number of Iterations: " & i)
			End If
		'========================================================================================================================================
			bExecute = FALSE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			If bExecute Then					' >>>  LOOP WITH CELL TEXT METHOD  <<<
				sSourceValue = sValueECT
				bApplicableToPOV = True
				
				iNumberOfIterations = 10000
				
				sAccount = "CB1010"
				
				Call WriteToAllDebugLogs("CELL TEXT METHOD LOOP started for " & sAccount & " - Number of Iterations: " & iNumberOfIterations)
				
				For i = 1 to iNumberOfIterations
					If bApplicableToPOV Then
						'Cell Text in : Actual 2018 P1 YTD [None] <Entity Curr Total> CB1010 [ICP Top] C1_TOP C2_TOP C3_TOP C4_TOP C5_TOP
						sExpTargetPOV = HS.GetCellTextWithLabel("Y#2018.P#P1.E#[None].V#[None].A#CB1010" & ALLTOPS, "System")
						
						'Call WriteToAllDebugLogs("HS.Exp " & sExpTargetPOV & " = " & sExpSourcePOV)
					End If  'account is applicable to the pov
				Next  'i
				
				Call WriteToAllDebugLogs("CELL TEXT METHOD LOOP ended for " & sAccount & " - Number of Iterations: " & i)
			End If
		'========================================================================================================================================
			bExecute = FALSE			'  <------  S E T   T O   T R U E      (to execute the test code)
			
			If bExecute Then					' >>>  LOOP FOR PARAMETRIC CALC ACCOUNTS  <<<
				sSourceValue = sValueECT
				
				iNumberOfIterations = 3000
				i = 0
				Call WriteToAllDebugLogs("ConvertToExpression LOOP started for PARAMETRIC ACCOUNTS - Number of Iterations: " & iNumberOfIterations)
				
				Do
					aParametricCalcAccs = HS.Account.List("", "A_ParametricCalcAccs")
					For Each sAccount In aParametricCalcAccs
						sUDA = HS.Account.UD1(sAccount)
						bApplicableToPOV = True
						
						If bApplicableToPOV Then
							sParameterValue = GetParameterValue(sUDA, "CALC")
							If BeginsWith(sParameterValue, "(") And EndsWith(sParameterValue, ")") Then
								'Extra parentheses, remove them.
								sParameterValue = Mid(sParameterValue, 2, Len(sParameterValue) - 2)
							End If
							
							aParamSections = Split(sParameterValue, ",")
							
							For Each sParamSection In aParamSections
								iEqualSignPos = InStr(sParamSection, "=")
								If iEqualSignPos > 0 Then
									'There is custom member(s) specified as the target POV on the left side of the =
									sTargetPOV = Left(sParamSection, iEqualSignPos - 1)
									sSourcePOV = Mid(sParamSection, iEqualSignPos + 1)
									
									If Not BeginsWith(sTargetPOV, sAccount) Then
										'The account itself is not included in the target POV part. Let's add it to the beginning of it.
										sTargetPOV = sAccount & "." & sTargetPOV
									End If
								Else
									'Whole parameter section is for source pov - target is the account itself (for all its valid custom members)
									sTargetPOV = sAccount
									sSourcePOV = sParamSection
								End If
								
								sExpTargetPOV = ConvertToExpression(sTargetPOV, sAccount, "NONES FOR UNUSED DIMENSIONS", "C5#C5_MANINP", "ALL", "")
								sExpSourcePOV = ConvertToExpression(sSourcePOV, sAccount, "TOPS EXCLUDING SAME ANALYSIS", "C5#C5_TOP", "ALL", sSourceValue)
								
								'Call WriteToAllDebugLogs("HS.Exp " & sExpTargetPOV & " = " & sExpSourcePOV)
							Next  'section in parameter value
						End If  'account is applicable to the pov
						
						i = i + 1
						If i >= iNumberOfIterations Then Exit For
					Next  'parametric calc account
				Loop Until i >= iNumberOfIterations
				
				Call WriteToAllDebugLogs("ConvertToExpression LOOP ended for PARAMETRIC ACCOUNTS - Number of Iterations: " & i)
			End If
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Dim sCalcStatus
			sCalcStatus = HS_CalcStatus("")
			sCalcStatus = HS_CalcStatus("S#Actual" & sValueECT)
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Call WriteToCellTextLog("ComputerName:" & UCase(ComputerName()))
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Call WriteToCellTextLog("Testing Loop - MAXCELLTEXTLOGNUMBEROFLINES:" & MAXCELLTEXTLOGNUMBEROFLINES )
			
			For i = 1 to MAXCELLTEXTLOGNUMBEROFLINES + 1
				Call WriteToCellTextLog("Testing Loop - " & i)
			Next  'i
			
			Call WriteToCellTextLog("TEST of MAXCELLTEXTLOGNUMBEROFLINES completed")
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			' Dim oHyperion, sUser
			
			' Set oHyperion = CreateObject("Hyperion.HsvDSRulesOM")
			' sUser = oHyperion.GetUser
			
			' Call WriteToAllDebugLogs("sUser: " & sUser)
			' Call AbortRules("", "sUser: " & sUser)
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Dim sTableHTML
			
			sTableHTML = "<table style=""undefined;table-layout: fixed; width: 676px""><colgroup><col style=""width: 244px""><col style=""width: 85px""><col style=""width: 126px""><col style=""width: 78px""><col style=""width: 21px""><col style=""width: 122px""></colgroup><tr><th></th><th>GL Load</th><th>Local Adjustments</th><th>Local Total</th><th></th><th>Exceptional Items</th></tr><tr><td>Account Description 1</td><td>1,000,000</td><td>-15,000</td><td>9,985,000</td><td></td><td>80,000</td></tr><tr><td>Account Description 2</td><td>500,000</td><td></td><td>500,000</td><td></td><td>25,000</td></tr><tr><td>Account Description 3</td><td>20,500</td><td>-500</td><td>20,000</td><td></td><td> </td></tr><tr><td>TOTAL</td><td>1,520,500</td><td>-15,500</td><td>1,505,000</td><td></td><td>105,000</td></tr></table>"
			
			'Create the objects require for sending email using CDO
			Set oSendEmail = CreateObject("CDO.Message")
			Set oEmailConfig = CreateObject("CDO.Configuration")
			Set oConfigFields = oEmailConfig.Fields
			
			'Set various parameters and properties of CDO object
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusing") = 2 'cdoSendUsingPort
			
			'your smtp server domain or IP address goes here such as smtp.yourdomain.com
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "smtp.yourdomain.com"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "stbeehive.oracle.com"
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "oc-141-145-121-156.compute.oraclecloud.com"
			
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = 25 'default port for email
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = 465
			
			'uncomment next three lines if you need to use SMTP Authorization
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusername") = "bulent.yildiz@oracle.com"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusername") = "oc-141-144-21-113@em3.opc.oracleoutsourcing.com"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendpassword") = "YOUR PASSWORD"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate") = 1 'cdoBasic
			
			oConfigFields.Update
			oSendEmail.Configuration = oEmailConfig
			oSendEmail.From	 = "oc-141-144-21-113@em3.opc.oracleoutsourcing.com"
			'oSendEmail.From	 = """HFM PIN"" <no-reply@tesco.com>"
			'oSendEmail.From	 = """HFM PIN"" <no-reply@em3.opc.oracleoutsourcing.com>"
			oSendEmail.To		 = "bulent.yildiz@oracle.com"
			'oSendEmail.To		 = "bulentyildiz@gmail.com"
			'oSendEmail.To		 = "bulent.yildiz1@tesco.com"
			'oSendEmail.CC		 = "bulent.yildiz1@tesco.com"
			'oSendEmail.CC		 = "bulent.yildiz@oracle.com"
			'oSendEmail.BCC		 = "bulent.yildiz@oracle.com"
			oSendEmail.Subject  = "HFM REVIEW & SIGN OFF" & Now()
			'oSendEmail.TextBody = "TEST EMAIL BODY " & Now()
			oSendEmail.HTMLBody = "<H3><B>Dear Reviewer</B></H3>" & "Please visit this website to review the financial reports.<BR>" & "<A HREF=""http://www.tesco.com"">TESCO</A>" & "<BR><BR>" & sTableHTML & "<BR><BR>" & Now()
			
			oSendEmail.Send
			
			'Set all objects to nothing after sending the email
			Set oConfigFields = Nothing
			Set oEmailConfig = Nothing
			Set oSendEmail = Nothing
			
		'========================================================================================================================================
			EXIT SUB	'  <------  C O M M E N T   O U T      (to execute the test code)
			
			Dim ToAddress
			Dim MessageSubject
			Dim MessageBody
			Dim MessageAttachment
			
			Dim ol, ns, newMail
			
			'ToAddress = "Yildiz, Bulent"   ' change this...
			ToAddress = "bulent.yildiz@oracle.com"   ' change this...
			MessageSubject = "TEST EMAIL BY"
			MessageBody = "Here is the test email body"
			
			'Set ol = WScript.CreateObject("Outlook.Application")
			Set ol = CreateObject("Outlook.Application")
			Set ns = ol.getNamespace("MAPI")
			ns.logon "","",true,false
			Set newMail = ol.CreateItem(olMailItem)
			newMail.Subject = MessageSubject
			newMail.Body = MessageBody & vbCrLf
			
			' validate the recipient, just in case...
			Set myRecipient = ns.CreateRecipient(ToAddress)
			myRecipient.Resolve
			If Not myRecipient.Resolved Then
				'MsgBox "unknown recipient"
				Call AbortRules("", "Unknown Recipient <" & ToAddress & ">")
			Else
				'newMail.Recipients.Add(myRecipient)
				newMail.Send
			End If
			
			Set ol = Nothing
			
		'========================================================================================================================================
		' Dim outobj, mailobj    
		  ' Dim strFileText 
		  ' Dim objFileToRead    

		  ' Set outobj = CreateObject("Outlook.Application")    
		  ' Set mailobj = outobj.CreateItem(0)    
		  ' 'Set objFileToRead = CreateObject("Scripting.FileSystemObject").OpenTextFile("C:\Users\sonu\Desktop\auto\sha.txt", 1)    
		  ' 'strFileText = objFileToRead.ReadAll()
		  ' 'objFileToRead.Close
		  ' 'Set objFileToRead = Nothing    
		  ' With mailobj
			' .To = "bulent.yildiz@oracle.com"
			' .Subject = "Test Mail Subject - BY"
			' .Body = "TEST MAIL BODY - BY"
			' .Send
		  ' End With

		  ' 'Clear the memory
		  ' Set outobj = Nothing    
		  ' Set mailobj = Nothing    
		
		'========================================================================================================================================
		
	End Sub   'OnDemand_TEST_CODE_OLD
	
	Sub OnDemand_TEST_CODE_2_OLD()
		'This sub should be used to temporarily test a piece of code (e.g. a new functionn etc.)
			sActiveRules = "ON DEMAND"
			sActiveCodeBlock = "OnDemand_TEST_CODE_2_OLD"
			
			Call SetDebugParameters
			Call SetGlobalVariables
			Call SetPOVVariables
			Call WriteToAllDebugLogs("OnDemand_TEST_CODE_2_OLD is running... " & Now())
		'========================================================================================================================================
			
			'Create the objects require for sending email using CDO
			Set oSendEmail = CreateObject("CDO.Message")
			Set oEmailConfig = CreateObject("CDO.Configuration")
			Set oConfigFields = oEmailConfig.Fields
			
			'Set various parameters and properties of CDO object
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusing") = 2 'cdoSendUsingPort
			
			'your smtp server domain or IP address goes here such as smtp.yourdomain.com
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "oc-141-145-121-156.compute.oraclecloud.com"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "127.0.0.1.compute.oraclecloud.com"
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "127.0.0.1"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = "http://localhost"
			
			oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = 25 'default port for email
			
			'uncomment next three lines if you need to use SMTP Authorization
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendusername") = "oc-141-144-21-113@em3.opc.oracleoutsourcing.com"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/sendpassword") = "YOUR PASSWORD"
			'oConfigFields.Item("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate") = 1 'cdoBasic
			
			oConfigFields.Update
			oSendEmail.Configuration = oEmailConfig
			'oSendEmail.From	 = "oc-141-144-21-113@em3.opc.oracleoutsourcing.com"
			'oSendEmail.From	 = "omcsbdcdmdbulx@em3.opc.oracleoutsourcing.com"   'ip: 141.144.21.44
			oSendEmail.From	 = "oc-141-144-21-44@em3.opc.oracleoutsourcing.com"		'UPDATE NEEDED: change this to no-reply once the issue with Tesco Mail System is resolved.
			'oSendEmail.From	 = """HFM PIN"" <no-reply@em3.opc.oracleoutsourcing.com>"	'This didn't work when sending to Tesco email address. Tesco Mail Server might be rejecting it.
			'oSendEmail.From	 = "no-reply@em3.opc.oracleoutsourcing.com"		'This also didn't work when sending to Tesco email address. Tesco Mail Server might be rejecting it.
			
			'oSendEmail.To		 = "bulent.yildiz@oracle.com"
			'oSendEmail.To		 = "bulentyildiz@gmail.com"
			oSendEmail.To		 = "bulent.yildiz1@tesco.com"
			oSendEmail.CC		 = "bulent.yildiz@oracle.com"
			
			oSendEmail.Subject  = "TEST EMAIL SUBJECT " & Now()
			oSendEmail.TextBody = "TEST EMAIL BODY " & Now()
			
			oSendEmail.Send
			
			'Set all objects to nothing after sending the email
			Set oConfigFields = Nothing
			Set oEmailConfig = Nothing
			Set oSendEmail = Nothing
	End Sub   'OnDemand_TEST_CODE_2_OLD
	
'*************************************************************************************************************************
'**************************************************** END OF FILE ********************************************************
'**************************************************************************************************************************